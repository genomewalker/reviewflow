<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rebuttr</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Clean, minimal design */
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap');

        :root {
            --text: #1a1a1a;
            --text-secondary: #666;
            --text-muted: #999;
            --bg: #fafafa;
            --bg-card: #fff;
            --border: #e5e5e5;
            --border-light: #f0f0f0;
            --accent: #2563eb;
            --accent-light: #eff6ff;
            --success: #16a34a;
            --warning: #ca8a04;
            --danger: #dc2626;
        }

        body {
            font-family: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
        }

        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            color: var(--text);
            letter-spacing: -0.01em;
        }

        code, pre {
            font-family: 'IBM Plex Mono', monospace;
        }

        /* Cards */
        .comment-card {
            transition: box-shadow 0.15s ease;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
        }
        .comment-card:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .status-badge {
            font-weight: 500;
            font-size: 0.75rem;
        }

        /* Priority - simple left border */
        .priority-high { border-left: 3px solid var(--danger); }
        .priority-medium { border-left: 3px solid var(--warning); }
        .priority-low { border-left: 3px solid var(--success); }

        /* Tabs */
        .tab-active {
            border-bottom: 2px solid var(--accent);
            color: var(--accent);
            font-weight: 500;
        }

        .response-textarea {
            min-height: 150px;
            border: 1px solid var(--border);
            border-radius: 6px;
            transition: border-color 0.15s;
        }
        .response-textarea:focus {
            border-color: var(--accent);
            outline: none;
            box-shadow: 0 0 0 2px var(--accent-light);
        }

        .markdown-preview {
            background: var(--bg);
            border-radius: 6px;
        }
        .markdown-preview h1, .markdown-preview h2, .markdown-preview h3 {
            font-weight: 600;
            margin-top: 1em;
        }
        .markdown-preview ul, .markdown-preview ol { padding-left: 1.5em; margin: 0.5em 0; }
        .markdown-preview li { margin: 0.25em 0; }
        .markdown-preview code {
            background: var(--border-light);
            padding: 0.15em 0.4em;
            border-radius: 3px;
            font-size: 0.875em;
        }

        .progress-ring { transform: rotate(-90deg); }

        /* Sidebar */
        .sidebar {
            width: 280px;
            min-width: 280px;
            background: var(--bg-card);
            border-right: 1px solid var(--border);
        }
        @media (max-width: 1024px) { .sidebar { width: 100%; min-width: 100%; } }

        /* Cards - flat, no gradients */
        .agent-card {
            background: var(--text);
            color: #fff;
        }
        .skill-card {
            background: var(--accent);
            color: #fff;
        }
        .export-btn {
            background: var(--text);
            color: #fff;
            transition: opacity 0.15s;
        }
        .export-btn:hover {
            opacity: 0.9;
        }

        .drag-handle { cursor: grab; }
        .drag-handle:active { cursor: grabbing; }

        /* Scrollbar - subtle */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #ccc;
        }

        /* Simple animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Chat window - clean */
        .floating-chat {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }
        .floating-chat.minimized .chat-window {
            transform: translateY(20px);
            opacity: 0;
            pointer-events: none;
        }
        .chat-window {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 380px;
            height: 500px;
            background: var(--bg-card);
            border-radius: 12px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.12), 0 0 0 1px var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: transform 0.2s ease, opacity 0.2s ease;
        }
        .chat-header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            color: var(--text);
            padding: 14px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }
        .chat-header h3 {
            font-weight: 600;
            font-size: 0.9rem;
        }
        .chat-header-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            transition: background 0.15s;
        }
        .chat-header-btn:hover {
            background: var(--border-light);
        }
        .chat-header-btn.danger:hover {
            background: #fee2e2;
            color: var(--danger);
        }
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            background: var(--bg);
        }
        .chat-message {
            margin-bottom: 12px;
            animation: fadeIn 0.2s ease;
        }
        .chat-message.user {
            text-align: right;
        }
        .chat-message.user .message-bubble {
            background: var(--accent);
            color: white;
            display: inline-block;
            padding: 10px 14px;
            border-radius: 12px 12px 4px 12px;
            max-width: 85%;
            text-align: left;
            font-size: 0.875rem;
        }
        .chat-message.assistant .message-bubble {
            background: var(--bg-card);
            border: 1px solid var(--border);
            display: inline-block;
            padding: 10px 14px;
            border-radius: 12px 12px 12px 4px;
            max-width: 85%;
            font-size: 0.875rem;
        }
        .chat-message.assistant .message-bubble pre {
            background: var(--bg);
            padding: 8px 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 0.8rem;
            margin: 6px 0;
        }
        .chat-message.assistant .message-bubble code {
            background: var(--bg);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.8rem;
        }
        .chat-input-area {
            padding: 14px 16px;
            border-top: 1px solid var(--border);
            background: var(--bg-card);
            flex-shrink: 0;
        }
        .chat-input-wrapper {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        .chat-input {
            flex: 1;
            resize: none;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 0.875rem;
            max-height: 100px;
            outline: none;
            transition: border-color 0.15s;
            background: var(--bg);
        }
        .chat-input:focus {
            border-color: var(--accent);
            background: var(--bg-card);
        }
        .chat-input::placeholder {
            color: var(--text-muted);
        }
        .chat-send-btn {
            width: 38px;
            height: 38px;
            border-radius: 8px;
            background: var(--accent);
            color: white;
            border: none;
            cursor: pointer;
            transition: opacity 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .chat-send-btn:hover {
            opacity: 0.9;
        }
        .chat-send-btn:disabled {
            background: var(--border);
            cursor: not-allowed;
        }
        .chat-fab {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--accent);
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.25);
            transition: box-shadow 0.15s, transform 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        .chat-fab:hover {
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.35);
            transform: translateY(-1px);
        }
        .chat-typing {
            display: flex;
            gap: 4px;
            padding: 10px 14px;
        }
        .chat-typing span {
            width: 8px;
            height: 8px;
            background: #9ca3af;
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out;
        }
        .chat-typing span:nth-child(1) { animation-delay: 0s; }
        .chat-typing span:nth-child(2) { animation-delay: 0.2s; }
        .chat-typing span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-8px); }
        }
        .chat-context-indicator {
            font-size: 10px;
            padding: 3px 10px;
            background: rgba(255,255,255,0.25);
            border-radius: 12px;
            font-weight: 500;
        }
        /* Chat clear confirmation toast */
        .chat-confirm-toast {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%) translateY(-10px);
            background: white;
            padding: 12px 16px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: all 0.2s ease;
        }
        .chat-confirm-toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
        }
        .chat-confirm-toast button {
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        .chat-confirm-toast .confirm-btn {
            background: #ef4444;
            color: white;
        }
        .chat-confirm-toast .confirm-btn:hover {
            background: #dc2626;
        }
        .chat-confirm-toast .cancel-btn {
            background: #f3f4f6;
            color: #374151;
        }
        .chat-confirm-toast .cancel-btn:hover {
            background: #e5e7eb;
        }

        /* Progress Widget - clean */
        .progress-widget {
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 999;
        }
        .progress-widget.hidden {
            display: none;
        }
        .progress-widget.minimized .progress-panel {
            transform: translateY(20px);
            opacity: 0;
            pointer-events: none;
        }
        .progress-widget.minimized .progress-fab {
            display: flex;
        }
        .progress-fab {
            display: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--text);
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transition: box-shadow 0.15s;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            position: relative;
        }
        .progress-fab:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .progress-fab .progress-indicator {
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 16px;
            height: 16px;
            background: var(--success);
            border-radius: 50%;
            border: 2px solid white;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .progress-panel {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 320px;
            background: var(--bg-card);
            border-radius: 10px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.12), 0 0 0 1px var(--border);
            overflow: hidden;
            transition: transform 0.2s ease, opacity 0.2s ease;
        }
        .progress-panel-header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            color: var(--text);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .progress-panel-header h4 {
            font-weight: 600;
            font-size: 0.875rem;
        }
        .progress-panel-header .header-btn {
            width: 26px;
            height: 26px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            transition: background 0.15s;
        }
        .progress-panel-header .header-btn:hover {
            background: var(--border-light);
        }
        .progress-panel-content {
            padding: 18px;
            max-height: 300px;
            overflow-y: auto;
            background: var(--slate-100);
        }
        .progress-panel-content::-webkit-scrollbar {
            width: 6px;
        }
        .progress-panel-content::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }
        .progress-log-entry {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 6px 0;
            font-size: 12px;
            border-bottom: 1px solid #f3f4f6;
        }
        .progress-log-entry:last-child {
            border-bottom: none;
        }
        .progress-log-entry.info i { color: #3b82f6; }
        .progress-log-entry.success i { color: #10b981; }
        .progress-log-entry.warning i { color: #f59e0b; }
        .progress-log-entry.error i { color: #ef4444; }

        @media (max-width: 640px) {
            .chat-window {
                width: calc(100vw - 32px);
                height: calc(100vh - 100px);
                bottom: 16px;
                right: 16px;
            }
            .floating-chat {
                bottom: 16px;
                right: 16px;
            }
        }
        /* Rotate utility for chevrons */
        .rotate-90 {
            transform: rotate(90deg);
        }

        /* Skeleton loading animations */
        @keyframes skeleton-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        .skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-shimmer 1.5s ease-in-out infinite;
            border-radius: 4px;
        }
        .skeleton-text {
            height: 1em;
            margin-bottom: 0.5em;
        }
        .skeleton-text:last-child {
            width: 70%;
        }
        .skeleton-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #e5e7eb;
        }
        .skeleton-circle {
            border-radius: 50%;
        }
        .skeleton-badge {
            height: 24px;
            width: 60px;
            border-radius: 12px;
        }
        /* Loading overlay for content areas */
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            backdrop-filter: blur(2px);
        }
        .loading-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }
        .loading-spinner i {
            font-size: 1.5rem;
            color: var(--accent);
        }
        .loading-spinner span {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Status indicator */
        .ai-knowledge-not-loaded {
            background: var(--warning) !important;
        }
        .ai-knowledge-loaded {
            background: var(--success) !important;
        }
        .ai-knowledge-warning-icon {
            animation: pulse-warning 1.5s ease-in-out infinite;
        }
        /* Scrollbar styling for file lists */
        .max-h-48::-webkit-scrollbar {
            width: 6px;
        }
        .max-h-48::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        .max-h-48::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }
        .max-h-48::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div id="app" class="flex flex-col lg:flex-row min-h-screen">
        <!-- Sidebar -->
        <aside class="sidebar bg-white border-r border-gray-200 flex-shrink-0">
            <div class="p-4 border-b border-gray-200">
                <a href="landing.html" class="flex items-center gap-2 text-gray-500 hover:text-gray-700 text-sm mb-3">
                    <i class="fas fa-arrow-left text-xs"></i>
                    All papers
                </a>
                <h1 class="text-base font-semibold text-gray-900 flex items-center gap-2">
                    <span class="w-6 h-6 rounded bg-blue-600 flex items-center justify-center">
                        <i class="fas fa-pen-nib text-white text-xs"></i>
                    </span>
                    Rebuttr
                </h1>
            </div>

            <!-- Current Paper -->
            <div class="p-4 border-b border-gray-200">
                <div id="paper-selector">
                    <h3 class="font-medium text-gray-900 text-sm" id="manuscript-title">Loading...</h3>
                    <p class="text-xs text-gray-500 mt-1" id="paper-field"></p>
                </div>
            </div>

            <!-- Progress Overview -->
            <div class="p-4 border-b border-gray-200">
                <h3 class="font-semibold text-gray-700 text-sm mb-3">Progress Overview</h3>
                <div class="space-y-3">
                    <div class="flex items-center justify-between">
                        <span class="text-sm text-gray-600">Completed</span>
                        <span class="text-sm font-semibold text-green-600" id="completed-count">0</span>
                    </div>
                    <div class="flex items-center justify-between">
                        <span class="text-sm text-gray-600">In Progress</span>
                        <span class="text-sm font-semibold text-blue-600" id="inprogress-count">0</span>
                    </div>
                    <div class="flex items-center justify-between">
                        <span class="text-sm text-gray-600">Pending</span>
                        <span class="text-sm font-semibold text-yellow-600" id="pending-count">0</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                        <div class="bg-green-600 h-2 rounded-full transition-all duration-500" id="progress-bar" style="width: 0%"></div>
                    </div>
                    <p class="text-xs text-center text-gray-500" id="progress-text">0% Complete</p>
                </div>
            </div>

            <!-- Navigation -->
            <nav class="p-4 space-y-1">
                <button onclick="setView('overview')" class="nav-btn w-full text-left px-4 py-2.5 rounded-xl hover:bg-blue-50 flex items-center justify-between transition-all group">
                    <div class="flex items-center gap-3">
                        <i class="fas fa-home w-5 text-gray-400 group-hover:text-blue-500"></i>
                        <span>Overview</span>
                    </div>
                    <kbd class="hidden group-hover:inline-block px-1.5 py-0.5 bg-gray-100 rounded text-[10px] text-gray-400 font-mono">1</kbd>
                </button>
                <button onclick="setView('taskqueue')" class="nav-btn w-full text-left px-4 py-2.5 rounded-xl hover:bg-blue-50 flex items-center justify-between transition-all group">
                    <div class="flex items-center gap-3">
                        <i class="fas fa-tasks w-5 text-gray-400 group-hover:text-blue-500"></i>
                        <span>Task Queue</span>
                    </div>
                    <kbd class="hidden group-hover:inline-block px-1.5 py-0.5 bg-gray-100 rounded text-[10px] text-gray-400 font-mono">T</kbd>
                </button>
                <button onclick="setView('comments')" class="nav-btn w-full text-left px-4 py-2.5 rounded-xl hover:bg-blue-50 flex items-center justify-between transition-all group">
                    <div class="flex items-center gap-3">
                        <i class="fas fa-comments w-5 text-gray-400 group-hover:text-blue-500"></i>
                        <span>All Comments</span>
                    </div>
                    <kbd class="hidden group-hover:inline-block px-1.5 py-0.5 bg-gray-100 rounded text-[10px] text-gray-400 font-mono">2</kbd>
                </button>
                <button onclick="setView('byreviewer')" class="nav-btn w-full text-left px-4 py-2.5 rounded-xl hover:bg-blue-50 flex items-center justify-between transition-all group">
                    <div class="flex items-center gap-3">
                        <i class="fas fa-users w-5 text-gray-400 group-hover:text-blue-500"></i>
                        <span>By Reviewer</span>
                    </div>
                    <kbd class="hidden group-hover:inline-block px-1.5 py-0.5 bg-gray-100 rounded text-[10px] text-gray-400 font-mono">3</kbd>
                </button>
                <button onclick="setView('agents')" class="nav-btn w-full text-left px-4 py-2.5 rounded-xl hover:bg-blue-50 flex items-center justify-between transition-all group">
                    <div class="flex items-center gap-3">
                        <i class="fas fa-robot w-5 text-gray-400 group-hover:text-blue-500"></i>
                        <span>AI Agents</span>
                    </div>
                    <kbd class="hidden group-hover:inline-block px-1.5 py-0.5 bg-gray-100 rounded text-[10px] text-gray-400 font-mono">4</kbd>
                </button>
                <button onclick="setView('experts')" class="nav-btn w-full text-left px-4 py-2.5 rounded-xl hover:bg-blue-50 flex items-center justify-between transition-all group">
                    <div class="flex items-center gap-3">
                        <i class="fas fa-microscope w-5 text-gray-400 group-hover:text-blue-500"></i>
                        <span>Expert Insights</span>
                    </div>
                    <kbd class="hidden group-hover:inline-block px-1.5 py-0.5 bg-gray-100 rounded text-[10px] text-gray-400 font-mono">5</kbd>
                </button>
                <button onclick="setView('export')" class="nav-btn w-full text-left px-4 py-2.5 rounded-xl hover:bg-blue-50 flex items-center justify-between transition-all group">
                    <div class="flex items-center gap-3">
                        <i class="fas fa-file-export w-5 text-gray-400 group-hover:text-blue-500"></i>
                        <span>Export</span>
                    </div>
                    <kbd class="hidden group-hover:inline-block px-1.5 py-0.5 bg-gray-100 rounded text-[10px] text-gray-400 font-mono">6</kbd>
                </button>
                <div class="pt-2 mt-2 border-t border-gray-100">
                    <button onclick="openSettingsModal()" class="nav-btn w-full text-left px-4 py-2.5 rounded-xl hover:bg-gray-100 flex items-center gap-3 transition-all group">
                        <i class="fas fa-cog w-5 text-gray-400 group-hover:text-gray-600"></i>
                        <span>AI Settings</span>
                    </button>
                </div>
            </nav>

            <!-- AI Context Status -->
            <div class="p-4 border-t border-gray-200">
                <div id="ai-knowledge-container" class="ai-knowledge-not-loaded rounded-lg p-3 text-white">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-xs font-medium flex items-center gap-1">
                            <i id="ai-knowledge-icon" class="fas fa-exclamation-triangle ai-knowledge-warning-icon"></i>
                            AI Knowledge
                        </span>
                        <span id="context-status-badge" class="text-xs bg-white bg-opacity-30 px-2 py-0.5 rounded font-semibold">Not Loaded</span>
                    </div>
                    <p class="text-xs opacity-90 mb-2" id="context-status-text">Load manuscript & reviews for better AI responses</p>
                    <button onclick="openContextModal()" class="w-full px-3 py-2 bg-white bg-opacity-20 hover:bg-opacity-30 rounded text-xs font-medium flex items-center justify-center gap-2 transition-all">
                        <i class="fas fa-book-reader"></i>
                        <span id="context-btn-text">Load Context</span>
                    </button>
                    <button onclick="openImportReviewsModal()" class="w-full mt-2 px-3 py-2 bg-white bg-opacity-20 hover:bg-opacity-30 rounded text-xs font-medium flex items-center justify-center gap-2 transition-all">
                        <i class="fas fa-file-import"></i>
                        <span>Import Reviews with AI</span>
                    </button>
                </div>
            </div>

            <!-- Data Management -->
            <div class="p-4 border-t border-gray-200">
                <h3 class="font-semibold text-gray-700 text-sm mb-3">Data Management</h3>
                <div class="space-y-2">
                    <button onclick="openCleanStartModal()" class="w-full text-left px-3 py-2 text-sm rounded hover:bg-red-50 flex items-center gap-2 text-red-600">
                        <i class="fas fa-redo text-xs"></i>
                        Clean Start / Re-extract
                    </button>
                </div>
            </div>

            <!-- Quick Filters -->
            <div class="p-4 border-t border-gray-200">
                <h3 class="font-semibold text-gray-700 text-sm mb-3">Quick Filters</h3>
                <div class="space-y-2">
                    <button onclick="filterByPriority('high')" class="w-full text-left px-3 py-2 text-sm rounded hover:bg-red-50 flex items-center gap-2">
                        <span class="w-2 h-2 rounded-full bg-red-500"></span>
                        High Priority
                    </button>
                    <button onclick="filterByPriority('medium')" class="w-full text-left px-3 py-2 text-sm rounded hover:bg-yellow-50 flex items-center gap-2">
                        <span class="w-2 h-2 rounded-full bg-yellow-500"></span>
                        Medium Priority
                    </button>
                    <button onclick="filterByType('major')" class="w-full text-left px-3 py-2 text-sm rounded hover:bg-purple-50 flex items-center gap-2">
                        <i class="fas fa-exclamation-circle text-purple-500 text-xs"></i>
                        Major Comments
                    </button>
                    <button onclick="filterByAnalysis(true)" class="w-full text-left px-3 py-2 text-sm rounded hover:bg-blue-50 flex items-center gap-2">
                        <i class="fas fa-flask text-blue-500 text-xs"></i>
                        Needs Analysis
                    </button>
                </div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="flex-1 overflow-auto">
            <!-- Header -->
            <header class="bg-white border-b border-gray-200 px-6 py-4 sticky top-0 z-10">
                <div class="flex items-center justify-between">
                    <div>
                        <h2 class="text-lg font-semibold text-gray-800" id="view-title">Overview</h2>
                        <p class="text-sm text-gray-500" id="view-subtitle">Manage your manuscript reviews</p>
                    </div>
                    <div class="flex items-center gap-3">
                        <button onclick="showKeyboardShortcutsHelp()" class="px-3 py-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg text-sm transition-all" title="Keyboard shortcuts">
                            <i class="fas fa-keyboard"></i>
                        </button>
                        <div class="relative">
                            <input type="text" id="search-input" placeholder="Search comments..."
                                   class="pl-10 pr-4 py-2 border border-gray-200 rounded-xl text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-gray-50 focus:bg-white transition-all"
                                   onkeyup="searchComments(this.value)">
                            <i class="fas fa-search absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                        </div>
                        <!-- Autosave indicator -->
                        <div id="autosave-indicator" class="text-xs text-gray-400 flex items-center gap-1 hidden">
                            <i class="fas fa-check-circle text-green-500"></i>
                            <span>Saved</span>
                        </div>
                        <button onclick="openPaperManager()" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-xl text-sm font-medium transition-all">
                            <i class="fas fa-folder-tree mr-2"></i>Papers
                        </button>
                    </div>
                </div>
            </header>

            <!-- Content Area -->
            <div id="content-area" class="p-6">
                <!-- Dynamic content will be inserted here -->
            </div>
        </main>
    </div>

    <!-- Comment Edit Modal -->
    <div id="comment-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
        <div class="bg-white rounded-2xl max-w-5xl w-full max-h-[92vh] overflow-hidden flex flex-col shadow-2xl">
            <div class="px-6 py-4 border-b border-gray-200 flex items-center justify-between bg-gradient-to-r from-blue-600 to-indigo-600 text-white rounded-t-2xl">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 bg-white bg-opacity-20 rounded-xl flex items-center justify-center">
                        <i class="fas fa-pen-to-square text-lg"></i>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold" id="modal-title">Response Builder</h3>
                        <p class="text-xs text-white text-opacity-80">Craft your response to reviewer feedback</p>
                    </div>
                </div>
                <button onclick="closeModal()" class="w-8 h-8 flex items-center justify-center rounded-lg bg-white bg-opacity-20 hover:bg-opacity-30 transition-all">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="flex-1 overflow-auto p-6 bg-gray-50">
                <div id="modal-content"></div>
            </div>
            <div class="px-6 py-4 border-t border-gray-200 flex justify-between items-center bg-white">
                <div class="text-xs text-gray-500">
                    <i class="fas fa-keyboard mr-1"></i>Press <kbd class="px-1.5 py-0.5 bg-gray-100 rounded text-gray-600 font-mono">Esc</kbd> to close
                </div>
                <div class="flex gap-3">
                    <button onclick="closeModal()" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 font-medium text-gray-700">Cancel</button>
                    <button onclick="saveComment()" class="px-5 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium shadow-sm">
                        <i class="fas fa-save mr-2"></i>Save Changes
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Agent Consultation Modal -->
    <div id="agent-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
        <div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] overflow-hidden flex flex-col">
            <div class="p-6 border-b border-gray-200 flex items-center justify-between">
                <h3 class="text-lg font-semibold" id="agent-modal-title">Consult AI Agent</h3>
                <button onclick="closeAgentModal()" class="text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="flex-1 overflow-auto p-6" id="agent-modal-content">
                <!-- Agent consultation content -->
            </div>
        </div>
    </div>

    <!-- Context Loading Modal -->
    <div id="context-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
        <div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] flex flex-col overflow-hidden">
            <!-- Header - Fixed -->
            <div class="p-4 border-b border-gray-200 flex items-center justify-between bg-gradient-to-r from-blue-500 to-indigo-600 text-white flex-shrink-0">
                <h3 class="text-lg font-semibold">
                    <i class="fas fa-book-reader mr-2"></i>
                    Load AI Context
                </h3>
                <div class="flex items-center gap-3">
                    <button onclick="selectAllFiles()" class="text-xs bg-white bg-opacity-20 hover:bg-opacity-30 px-2 py-1 rounded">
                        Select All
                    </button>
                    <button onclick="selectNoneFiles()" class="text-xs bg-white bg-opacity-20 hover:bg-opacity-30 px-2 py-1 rounded">
                        Select None
                    </button>
                    <button onclick="closeContextModal()" class="text-white hover:text-gray-200 ml-2">
                        <i class="fas fa-times text-xl"></i>
                    </button>
                </div>
            </div>

            <!-- Scrollable Content -->
            <div class="flex-1 overflow-y-auto p-4">
                <!-- Quick Selection Bar -->
                <div class="flex flex-wrap gap-2 mb-4 p-3 bg-gray-100 rounded-lg">
                    <span class="text-xs text-gray-500 mr-2 py-1">Quick select:</span>
                    <button onclick="selectCategory('manuscript')" class="text-xs bg-blue-100 text-blue-700 hover:bg-blue-200 px-2 py-1 rounded">
                        <i class="fas fa-file-word mr-1"></i>Manuscript
                    </button>
                    <button onclick="selectCategory('reviews')" class="text-xs bg-purple-100 text-purple-700 hover:bg-purple-200 px-2 py-1 rounded">
                        <i class="fas fa-comments mr-1"></i>Reviews
                    </button>
                    <button onclick="selectCategory('supplementary')" class="text-xs bg-orange-100 text-orange-700 hover:bg-orange-200 px-2 py-1 rounded">
                        <i class="fas fa-folder mr-1"></i>Supplementary
                    </button>
                    <button onclick="selectCategory('taxonomic_data')" class="text-xs bg-yellow-100 text-yellow-700 hover:bg-yellow-200 px-2 py-1 rounded">
                        <i class="fas fa-bacteria mr-1"></i>Taxonomic
                    </button>
                    <button onclick="refreshContextFiles()" class="text-xs bg-gray-200 text-gray-700 hover:bg-gray-300 px-2 py-1 rounded ml-auto">
                        <i class="fas fa-sync-alt mr-1"></i>Refresh
                    </button>
                </div>

                <!-- Files Grid -->
                <div class="space-y-3" id="context-files-checkboxes">
                    <div class="text-sm text-gray-500 p-4 text-center">
                        <i class="fas fa-spinner fa-spin mr-2"></i>Loading available files...
                    </div>
                </div>

                <!-- Loading Progress -->
                <div id="context-loading-progress" class="hidden mt-4">
                    <div class="p-4 bg-blue-50 rounded-lg border border-blue-200">
                        <div class="flex items-center gap-3 mb-2">
                            <i class="fas fa-spinner fa-spin text-blue-600"></i>
                            <div class="font-medium text-blue-800">Loading Files into AI Memory...</div>
                        </div>
                        <div class="text-sm text-blue-700" id="context-loading-status">Initializing...</div>
                    </div>
                </div>
            </div>

            <!-- Footer - Fixed -->
            <div class="p-3 border-t border-gray-200 bg-gray-50 flex-shrink-0">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-4">
                        <span id="selected-files-info" class="text-sm text-gray-700 font-medium">0 files (0 B)</span>
                        <div class="flex items-center gap-2 text-xs">
                            <span id="context-status-indicator" class="w-2 h-2 rounded-full bg-gray-400"></span>
                            <span id="context-detail-status" class="text-gray-500">No context loaded</span>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="clearContext()" class="px-3 py-1.5 text-red-600 hover:bg-red-50 rounded text-sm">
                            <i class="fas fa-trash mr-1"></i>Clear
                        </button>
                        <button onclick="closeContextModal()" class="px-3 py-1.5 border border-gray-300 rounded hover:bg-gray-100 text-sm">
                            Cancel
                        </button>
                        <button onclick="loadContext()" id="load-context-main-btn" class="px-4 py-1.5 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm font-medium">
                            <i class="fas fa-download mr-1"></i>Load Selected
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Import Reviews Modal -->
    <div id="import-reviews-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
        <div class="bg-white rounded-xl max-w-4xl w-full max-h-[90vh] flex flex-col overflow-hidden">
            <!-- Header -->
            <div class="p-4 border-b border-gray-200 flex items-center justify-between bg-gradient-to-r from-purple-500 to-indigo-600 text-white flex-shrink-0">
                <h3 class="text-lg font-semibold">
                    <i class="fas fa-file-import mr-2"></i>
                    Import & Parse Reviews with AI
                </h3>
                <button onclick="closeImportReviewsModal()" class="text-white hover:text-gray-200">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>

            <!-- Content -->
            <div class="flex-1 overflow-y-auto p-4">
                <!-- Step Indicator -->
                <div class="flex items-center justify-center gap-2 mb-6">
                    <div class="flex items-center gap-1" id="import-step-1">
                        <span class="w-7 h-7 rounded-full bg-purple-600 text-white flex items-center justify-center text-sm font-bold">1</span>
                        <span class="text-sm font-medium text-purple-600">Paste Reviews</span>
                    </div>
                    <div class="w-8 h-px bg-gray-300"></div>
                    <div class="flex items-center gap-1 opacity-50" id="import-step-2">
                        <span class="w-7 h-7 rounded-full bg-gray-300 text-gray-600 flex items-center justify-center text-sm font-bold">2</span>
                        <span class="text-sm font-medium text-gray-500">Extract & Categorize</span>
                    </div>
                    <div class="w-8 h-px bg-gray-300"></div>
                    <div class="flex items-center gap-1 opacity-50" id="import-step-3">
                        <span class="w-7 h-7 rounded-full bg-gray-300 text-gray-600 flex items-center justify-center text-sm font-bold">3</span>
                        <span class="text-sm font-medium text-gray-500">Generate Expert Analysis</span>
                    </div>
                </div>

                <!-- Step 1: Paste Reviews -->
                <div id="import-step-content-1">
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">
                            Paste Raw Reviewer Comments
                            <span class="text-gray-400 font-normal">(from Nature, Science, etc.)</span>
                        </label>
                        <textarea id="raw-reviews-input" rows="12" placeholder="Paste the complete reviewer comments here...

Example:
Referee #1

This is an interesting study but I have several concerns:

1. The methodology section lacks detail on...
2. Figure 3 is unclear because...

Major comments:
- The authors should clarify...

Minor comments:
- Line 42: typo 'teh' should be 'the'"
                            class="w-full border border-gray-300 rounded-lg p-3 text-sm font-mono focus:ring-2 focus:ring-purple-500 focus:border-purple-500"></textarea>
                    </div>

                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Reviewer ID</label>
                            <input type="text" id="reviewer-id-input" value="R1" placeholder="R1, R2, etc."
                                class="w-full border border-gray-300 rounded px-3 py-2 text-sm">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Reviewer Name</label>
                            <input type="text" id="reviewer-name-input" value="Referee #1" placeholder="Referee #1"
                                class="w-full border border-gray-300 rounded px-3 py-2 text-sm">
                        </div>
                    </div>

                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm text-blue-800">
                        <i class="fas fa-info-circle mr-2"></i>
                        <strong>Tip:</strong> Paste the complete text including all comments. The AI will extract and categorize each individual point.
                    </div>
                </div>

                <!-- Step 2: Review Extracted Comments -->
                <div id="import-step-content-2" class="hidden">
                    <div class="mb-4 flex items-center justify-between">
                        <h4 class="font-medium text-gray-700">Extracted Comments</h4>
                        <span id="extracted-count" class="text-sm text-gray-500">0 comments found</span>
                    </div>
                    <div id="extracted-comments-list" class="space-y-2 max-h-96 overflow-y-auto border rounded-lg p-2 bg-gray-50">
                        <!-- Will be populated by JS -->
                    </div>
                </div>

                <!-- Step 3: Generate Expert Analysis -->
                <div id="import-step-content-3" class="hidden">
                    <div class="text-center py-8">
                        <i class="fas fa-brain text-6xl text-purple-300 mb-4"></i>
                        <h4 class="text-lg font-medium text-gray-700 mb-2">Generate Expert Analysis</h4>
                        <p class="text-gray-500 mb-4">AI will analyze each comment with domain experts and generate recommended responses.</p>
                        <div id="expert-generation-progress" class="hidden">
                            <div class="w-full bg-gray-200 rounded-full h-2 mb-2">
                                <div id="expert-progress-bar" class="bg-purple-600 h-2 rounded-full transition-all" style="width: 0%"></div>
                            </div>
                            <p id="expert-progress-text" class="text-sm text-gray-600">Processing...</p>
                        </div>
                    </div>
                </div>

                <!-- Processing indicator -->
                <div id="import-processing" class="hidden mt-4">
                    <div class="p-4 bg-purple-50 rounded-lg border border-purple-200">
                        <div class="flex items-center gap-3">
                            <i class="fas fa-spinner fa-spin text-purple-600"></i>
                            <div>
                                <div class="font-medium text-purple-800">Processing with AI...</div>
                                <div class="text-sm text-purple-700" id="import-processing-status">Extracting comments...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <div class="p-3 border-t border-gray-200 bg-gray-50 flex-shrink-0">
                <div class="flex items-center justify-between">
                    <button onclick="prevImportStep()" id="import-prev-btn" class="px-3 py-1.5 text-gray-600 hover:bg-gray-100 rounded text-sm hidden">
                        <i class="fas fa-arrow-left mr-1"></i>Back
                    </button>
                    <div class="flex gap-2 ml-auto">
                        <button onclick="closeImportReviewsModal()" class="px-3 py-1.5 border border-gray-300 rounded hover:bg-gray-100 text-sm">
                            Cancel
                        </button>
                        <button onclick="nextImportStep()" id="import-next-btn" class="px-4 py-1.5 bg-purple-600 text-white rounded hover:bg-purple-700 text-sm font-medium">
                            <i class="fas fa-magic mr-1"></i>Extract Comments
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Clean Start Modal -->
    <div id="clean-start-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
        <div class="bg-white rounded-xl max-w-2xl w-full max-h-[90vh] flex flex-col overflow-hidden">
            <!-- Header -->
            <div class="p-4 border-b border-gray-200 flex items-center justify-between bg-gradient-to-r from-red-500 to-orange-500 text-white flex-shrink-0">
                <h3 class="text-lg font-semibold">
                    <i class="fas fa-redo mr-2"></i>
                    Clean Start / Re-extract Reviews
                </h3>
                <button onclick="closeCleanStartModal()" class="text-white hover:text-gray-200">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>

            <!-- Content -->
            <div class="flex-1 overflow-y-auto p-4">
                <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
                    <div class="flex items-start gap-3">
                        <i class="fas fa-exclamation-triangle text-yellow-600 mt-0.5"></i>
                        <div>
                            <h4 class="font-medium text-yellow-800">Warning</h4>
                            <p class="text-sm text-yellow-700">This will clear all current data and re-extract from source files. Any draft responses you've written will be lost.</p>
                        </div>
                    </div>
                </div>

                <h4 class="font-medium text-gray-700 mb-3">What would you like to do?</h4>

                <div class="space-y-3">
                    <!-- Option 1: Clear all and start fresh -->
                    <label class="flex items-start gap-3 p-4 border rounded-lg hover:bg-gray-50 cursor-pointer">
                        <input type="radio" name="clean-option" value="re-extract" class="mt-1" checked>
                        <div>
                            <div class="font-medium text-gray-800">Clear & Re-extract from Review Files</div>
                            <p class="text-sm text-gray-500">Clear all data and use AI to extract fresh comments from review files.</p>
                        </div>
                    </label>

                    <!-- Option 2: Clear only -->
                    <label class="flex items-start gap-3 p-4 border rounded-lg hover:bg-gray-50 cursor-pointer">
                        <input type="radio" name="clean-option" value="clear-all" class="mt-1">
                        <div>
                            <div class="font-medium text-gray-800">Clear All Data Only</div>
                            <p class="text-sm text-gray-500">Remove all data without re-extracting. Start with empty state.</p>
                        </div>
                    </label>

                    <!-- Option 3: Clear expert analysis only -->
                    <label class="flex items-start gap-3 p-4 border rounded-lg hover:bg-gray-50 cursor-pointer">
                        <input type="radio" name="clean-option" value="clear-experts" class="mt-1">
                        <div>
                            <div class="font-medium text-gray-800">Clear Expert Analysis Only</div>
                            <p class="text-sm text-gray-500">Keep comments but regenerate all expert analysis from scratch.</p>
                        </div>
                    </label>

                    <!-- Option 4: Clear responses only -->
                    <label class="flex items-start gap-3 p-4 border rounded-lg hover:bg-gray-50 cursor-pointer">
                        <input type="radio" name="clean-option" value="clear-responses" class="mt-1">
                        <div>
                            <div class="font-medium text-gray-800">Clear Draft Responses Only</div>
                            <p class="text-sm text-gray-500">Keep comments and expert analysis, but reset all draft responses.</p>
                        </div>
                    </label>
                </div>

                <!-- File selection for re-extract -->
                <div id="clean-start-files" class="hidden mt-4">
                    <h4 class="font-medium text-gray-700 mb-2">Select Review Files to Process</h4>
                    <div id="clean-start-file-list" class="border rounded-lg p-3 bg-gray-50 max-h-48 overflow-y-auto">
                        <div class="text-sm text-gray-500 text-center">
                            <i class="fas fa-spinner fa-spin mr-2"></i>Loading files...
                        </div>
                    </div>
                </div>

                <!-- Processing status -->
                <div id="clean-start-processing" class="hidden mt-4">
                    <div class="p-4 bg-blue-50 rounded-lg border border-blue-200">
                        <div class="flex items-center gap-3">
                            <i class="fas fa-spinner fa-spin text-blue-600"></i>
                            <div>
                                <div class="font-medium text-blue-800">Processing...</div>
                                <div class="text-sm text-blue-700" id="clean-start-status">Initializing...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <div class="p-3 border-t border-gray-200 bg-gray-50 flex-shrink-0">
                <div class="flex items-center justify-end gap-2">
                    <button onclick="closeCleanStartModal()" class="px-3 py-1.5 border border-gray-300 rounded hover:bg-gray-100 text-sm">
                        Cancel
                    </button>
                    <button onclick="executeCleanStart()" id="clean-start-btn" class="px-4 py-1.5 bg-red-600 text-white rounded hover:bg-red-700 text-sm font-medium">
                        <i class="fas fa-redo mr-1"></i>Execute
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Project Manager Modal -->
    <div id="project-manager-modal" class="fixed inset-0 bg-slate-50 z-50 hidden">
        <div class="min-h-screen flex flex-col">
            <!-- Header -->
            <div class="bg-white border-b border-slate-200 px-6 py-4">
                <div class="max-w-5xl mx-auto flex items-center justify-between">
                    <div class="flex items-center gap-3">
                        <div class="w-8 h-8 bg-slate-900 rounded-lg flex items-center justify-center">
                            <i class="fas fa-feather-alt text-white text-sm"></i>
                        </div>
                        <span class="text-lg font-semibold text-slate-900">Rebuttr</span>
                    </div>
                    <div class="flex items-center gap-6">
                        <!-- Compact Stats -->
                        <div class="hidden md:flex items-center gap-4 text-sm text-slate-500">
                            <span><span class="font-medium text-slate-700" id="pm-total-papers">0</span> papers</span>
                            <span class="text-slate-300">|</span>
                            <span><span class="font-medium text-amber-600" id="pm-in-progress">0</span> in progress</span>
                            <span class="text-slate-300">|</span>
                            <span><span class="font-medium text-emerald-600" id="pm-completed">0</span> done</span>
                            <span class="text-slate-300">|</span>
                            <span><span class="font-medium text-slate-700" id="pm-total-comments">0</span> comments</span>
                        </div>
                        <button onclick="closeProjectManager()" id="project-manager-close" class="hidden text-slate-500 hover:text-slate-700 text-sm flex items-center gap-2 px-3 py-1.5 rounded-md hover:bg-slate-100">
                            <i class="fas fa-arrow-left text-xs"></i>
                            Back
                        </button>
                    </div>
                </div>
            </div>

            <!-- Content -->
            <div class="flex-1 overflow-y-auto py-6">
                <div class="max-w-5xl mx-auto px-6">
                    <!-- Tabs and Actions -->
                    <div class="flex items-center justify-between mb-5">
                        <div class="flex items-center gap-1 bg-slate-200/50 p-1 rounded-lg">
                            <button id="tab-papers" onclick="showPapersTab()" class="px-3 py-1.5 bg-white text-slate-700 rounded-md text-sm font-medium shadow-sm flex items-center gap-2">
                                Papers
                                <span id="papers-count-badge" class="bg-slate-100 text-slate-600 px-1.5 py-0.5 rounded text-xs">0</span>
                            </button>
                            <button id="tab-trash" onclick="showTrashTab()" class="px-3 py-1.5 text-slate-500 hover:text-slate-700 rounded-md text-sm font-medium flex items-center gap-2">
                                Trash
                                <span id="trash-count-badge" class="hidden bg-red-100 text-red-600 px-1.5 py-0.5 rounded text-xs">0</span>
                            </button>
                        </div>
                        <button id="add-paper-btn" onclick="showAddPaperForm()" class="px-3 py-1.5 bg-slate-900 text-white rounded-md hover:bg-slate-800 text-sm font-medium flex items-center gap-2">
                            <i class="fas fa-plus text-xs"></i>
                            New Paper
                        </button>
                    </div>

                    <!-- Add Paper Form (hidden by default) -->
                    <div id="add-paper-form" class="hidden bg-white rounded-lg border border-slate-200 p-5 mb-5">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-sm font-medium text-slate-900">New Paper</h3>
                            <button onclick="hideAddPaperForm()" class="text-slate-400 hover:text-slate-600">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>

                        <!-- Three Column Drop Zones -->
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-3 mb-4">
                            <!-- Manuscript Drop Zone -->
                            <div id="dropzone-manuscript"
                                 class="border border-dashed border-slate-300 rounded-lg p-4 text-center transition-all hover:border-slate-400 hover:bg-slate-50 cursor-pointer min-h-[140px] flex flex-col"
                                 ondragover="handleCategoryDragOver(event, 'manuscript')"
                                 ondragleave="handleCategoryDragLeave(event, 'manuscript')"
                                 ondrop="handleCategoryDrop(event, 'manuscript')"
                                 onclick="document.getElementById('file-input-manuscript').click()">
                                <input type="file" id="file-input-manuscript" class="hidden" multiple
                                       accept=".pdf,.docx,.doc,.txt,.md"
                                       onchange="handleCategoryFileSelect(event, 'manuscript')">
                                <div class="flex-1 flex flex-col items-center justify-center" id="dropzone-manuscript-empty">
                                    <i class="fas fa-file-alt text-slate-400 text-lg mb-2"></i>
                                    <p class="text-xs font-medium text-slate-600">Manuscript</p>
                                    <p class="text-xs text-slate-400">Drop PDF or DOCX</p>
                                </div>
                                <div id="files-manuscript" class="space-y-1 text-left"></div>
                            </div>

                            <!-- Reviews Drop Zone -->
                            <div id="dropzone-review"
                                 class="border border-dashed border-slate-300 rounded-lg p-4 text-center transition-all hover:border-slate-400 hover:bg-slate-50 cursor-pointer min-h-[140px] flex flex-col"
                                 ondragover="handleCategoryDragOver(event, 'review')"
                                 ondragleave="handleCategoryDragLeave(event, 'review')"
                                 ondrop="handleCategoryDrop(event, 'review')"
                                 onclick="document.getElementById('file-input-review').click()">
                                <input type="file" id="file-input-review" class="hidden" multiple
                                       accept=".pdf,.docx,.doc,.txt,.md"
                                       onchange="handleCategoryFileSelect(event, 'review')">
                                <div class="flex-1 flex flex-col items-center justify-center" id="dropzone-review-empty">
                                    <i class="fas fa-comments text-slate-400 text-lg mb-2"></i>
                                    <p class="text-xs font-medium text-slate-600">Reviews</p>
                                    <p class="text-xs text-slate-400">Reviewer comments</p>
                                </div>
                                <div id="files-review" class="space-y-1 text-left"></div>
                            </div>

                            <!-- Supplementary Drop Zone -->
                            <div id="dropzone-supplementary"
                                 class="border border-dashed border-slate-300 rounded-lg p-4 text-center transition-all hover:border-slate-400 hover:bg-slate-50 cursor-pointer min-h-[140px] flex flex-col"
                                 ondragover="handleCategoryDragOver(event, 'supplementary')"
                                 ondragleave="handleCategoryDragLeave(event, 'supplementary')"
                                 ondrop="handleCategoryDrop(event, 'supplementary')"
                                 onclick="document.getElementById('file-input-supplementary').click()">
                                <input type="file" id="file-input-supplementary" class="hidden" multiple
                                       accept=".pdf,.docx,.doc,.txt,.md,.csv,.xlsx,.xls"
                                       onchange="handleCategoryFileSelect(event, 'supplementary')">
                                <div class="flex-1 flex flex-col items-center justify-center" id="dropzone-supplementary-empty">
                                    <i class="fas fa-paperclip text-slate-400 text-lg mb-2"></i>
                                    <p class="text-xs font-medium text-slate-600">Supplementary</p>
                                    <p class="text-xs text-slate-400">Data, figures</p>
                                </div>
                                <div id="files-supplementary" class="space-y-1 text-left"></div>
                            </div>
                        </div>

                        <!-- Hidden inputs for metadata (populated after creation) -->
                        <input type="hidden" id="new-paper-title">
                        <input type="hidden" id="new-paper-authors">
                        <input type="hidden" id="new-paper-journal">
                        <input type="hidden" id="new-paper-field">

                        <!-- Files Ready Summary -->
                        <div id="extraction-summary" class="hidden mb-4">
                            <div class="bg-slate-50 border border-slate-200 rounded-lg p-3">
                                <div class="flex items-center gap-2">
                                    <i class="fas fa-check text-slate-500 text-sm"></i>
                                    <p class="text-xs text-slate-600" id="extraction-details">Files ready</p>
                                </div>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div class="flex justify-between items-center pt-3 border-t border-slate-100">
                            <button onclick="clearAllDropzones()" class="text-xs text-slate-400 hover:text-slate-600">
                                Clear all
                            </button>
                            <div class="flex gap-2">
                                <button onclick="hideAddPaperForm()" class="px-3 py-1.5 text-sm text-slate-600 hover:bg-slate-100 rounded">Cancel</button>
                                <button onclick="createNewPaperWithFiles()" id="create-paper-btn" class="px-3 py-1.5 text-sm bg-slate-900 text-white rounded hover:bg-slate-800 disabled:opacity-40 disabled:cursor-not-allowed" disabled>
                                    Create Paper
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Papers Grid -->
                    <div id="papers-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Papers will be loaded here -->
                    </div>

                    <!-- Empty State -->
                    <div id="papers-empty" class="hidden text-center py-12">
                        <div class="w-12 h-12 bg-slate-100 rounded-full flex items-center justify-center mx-auto mb-3">
                            <i class="fas fa-folder-open text-slate-400"></i>
                        </div>
                        <p class="text-sm text-slate-500 mb-1">No papers yet</p>
                        <p class="text-xs text-slate-400">Click "New Paper" above to get started</p>
                    </div>

                    <!-- Trash Section (hidden by default) -->
                    <div id="trash-section" class="hidden">
                        <div id="trash-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            <!-- Trashed papers will be loaded here -->
                        </div>
                        <div id="trash-empty" class="hidden text-center py-12">
                            <div class="w-12 h-12 bg-slate-100 rounded-full flex items-center justify-center mx-auto mb-3">
                                <i class="fas fa-trash-alt text-slate-400"></i>
                            </div>
                            <p class="text-sm text-slate-500">Trash is empty</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Global Progress Overlay -->
    <div id="progress-overlay" class="fixed inset-0 bg-black bg-opacity-60 z-[100] hidden flex items-center justify-center p-4">
        <div class="bg-white rounded-2xl max-w-md w-full shadow-2xl overflow-hidden">
            <!-- Header with animated gradient -->
            <div class="px-6 py-4 bg-gradient-to-r from-blue-600 via-purple-600 to-blue-600 bg-[length:200%_100%] animate-gradient text-white">
                <h3 class="text-lg font-semibold flex items-center gap-3" id="progress-title">
                    <div class="w-6 h-6 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                    <span>Processing...</span>
                </h3>
            </div>

            <!-- Progress content -->
            <div class="p-6">
                <!-- Current step -->
                <div class="mb-4">
                    <div class="text-sm font-medium text-gray-700 mb-1" id="progress-step">Initializing...</div>
                    <div class="text-xs text-gray-500" id="progress-detail"></div>
                </div>

                <!-- Progress bar -->
                <div class="mb-4">
                    <div class="w-full bg-gray-200 rounded-full h-2.5 overflow-hidden">
                        <div id="progress-bar-fill" class="bg-gradient-to-r from-blue-500 to-purple-500 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                    <div class="flex justify-between mt-1">
                        <span class="text-xs text-gray-500" id="progress-percent">0%</span>
                        <span class="text-xs text-gray-500" id="progress-count"></span>
                    </div>
                </div>

                <!-- Log/steps list -->
                <div id="progress-log" class="max-h-64 overflow-y-auto border rounded-lg bg-gray-50 p-3 text-xs font-mono space-y-1">
                </div>

                <!-- Cancel button (optional) -->
                <div class="mt-4 text-center hidden" id="progress-cancel-container">
                    <button onclick="cancelProgress()" class="px-4 py-2 text-sm text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-lg">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <style>
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .animate-gradient {
            animation: gradient 3s ease infinite;
        }
    </style>

    <!-- AI Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
        <div class="bg-white rounded-xl max-w-lg w-full overflow-hidden">
            <div class="p-6 border-b border-gray-200 flex items-center justify-between">
                <h3 class="text-lg font-semibold">
                    <i class="fas fa-cog text-blue-600 mr-2"></i>
                    AI Model Settings
                </h3>
                <button onclick="closeSettingsModal()" class="text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-6 space-y-6">
                <!-- Model Selection -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">
                        Model
                        <button onclick="refreshModels()" class="ml-2 text-xs text-blue-600 hover:text-blue-800">
                            <i class="fas fa-sync-alt"></i> Refresh
                        </button>
                    </label>
                    <select id="settings-model" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="">Loading models...</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1" id="models-status">Fetching available models from OpenCode...</p>
                </div>

                <!-- Agent Selection -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Agent</label>
                    <select id="settings-agent" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="plan">Plan (Planning mode)</option>
                        <option value="build">Build (Implementation mode)</option>
                        <option value="explore">Explore (Research/exploration)</option>
                        <option value="general">General (General purpose)</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1">Agent type determines how the model approaches tasks</p>
                </div>

                <!-- Variant Selection -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Reasoning Effort</label>
                    <select id="settings-variant" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="minimal">Minimal (Fastest, least reasoning)</option>
                        <option value="low">Low (Fast)</option>
                        <option value="medium">Medium (Balanced)</option>
                        <option value="high">High (More reasoning)</option>
                        <option value="xhigh">Extra High (Complex tasks)</option>
                        <option value="max">Maximum (Most reasoning)</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1">Higher variants use more reasoning for complex tasks</p>
                </div>

                <!-- Session Info -->
                <div class="bg-gray-50 rounded-lg p-4">
                    <h4 class="text-sm font-medium text-gray-700 mb-2">Session Info</h4>
                    <div class="text-xs text-gray-600 space-y-1">
                        <p><span class="font-medium">Session ID:</span> <span id="settings-session-id">None</span></p>
                        <p><span class="font-medium">Messages:</span> <span id="settings-message-count">0</span></p>
                    </div>
                    <button onclick="resetSession()" class="mt-3 text-xs text-red-600 hover:text-red-700">
                        <i class="fas fa-redo mr-1"></i>Reset Session (Start Fresh)
                    </button>
                </div>
            </div>
            <div class="p-4 border-t border-gray-200 flex justify-end gap-3">
                <button onclick="closeSettingsModal()" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50">Cancel</button>
                <button onclick="saveSettings()" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Floating Chat Window -->
    <div id="floating-chat" class="floating-chat minimized">
        <!-- Chat FAB (Floating Action Button) -->
        <button id="chat-fab" onclick="toggleChat()" class="chat-fab" title="Chat with OpenCode">
            <i class="fas fa-comments"></i>
        </button>

        <!-- Chat Window -->
        <div class="chat-window">
            <!-- Clear confirmation toast -->
            <div id="chat-clear-confirm" class="chat-confirm-toast">
                <span class="text-sm text-gray-700">Clear chat history?</span>
                <button onclick="confirmClearChat()" class="confirm-btn">Clear</button>
                <button onclick="cancelClearChat()" class="cancel-btn">Cancel</button>
            </div>

            <!-- Header -->
            <div class="chat-header" id="chat-header">
                <div class="flex items-center gap-3">
                    <div class="w-9 h-9 bg-white bg-opacity-20 rounded-xl flex items-center justify-center">
                        <i class="fas fa-robot text-lg"></i>
                    </div>
                    <div>
                        <div class="font-semibold text-sm font-display">Review Chat</div>
                        <div class="text-xs opacity-80 flex items-center gap-1" id="chat-model-indicator">
                            <span class="w-1.5 h-1.5 rounded-full bg-green-300"></span>
                            github-copilot/gpt-5.2
                        </div>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <span id="chat-context-badge" class="chat-context-indicator hidden">
                        <i class="fas fa-book-reader mr-1"></i>Context
                    </span>
                    <button onclick="showClearConfirm()" class="chat-header-btn danger" title="Clear chat history">
                        <i class="fas fa-trash text-sm"></i>
                    </button>
                    <button onclick="toggleChat()" class="chat-header-btn" title="Close (Esc)">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>

            <!-- Messages Area -->
            <div class="chat-messages" id="chat-messages">
                <div class="chat-message assistant">
                    <div class="message-bubble">
                        <p class="text-sm font-medium text-gray-800">Hi! I'm your OpenCode assistant.</p>
                        <p class="text-sm text-gray-600 mt-2">I can help you with:</p>
                        <ul class="text-sm mt-2 space-y-1.5 text-gray-600">
                            <li class="flex items-start gap-2">
                                <i class="fas fa-pen text-blue-500 mt-0.5 text-xs"></i>
                                Writing responses to reviewer comments
                            </li>
                            <li class="flex items-start gap-2">
                                <i class="fas fa-dna text-purple-500 mt-0.5 text-xs"></i>
                                Explaining DNA damage authentication
                            </li>
                            <li class="flex items-start gap-2">
                                <i class="fas fa-leaf text-green-500 mt-0.5 text-xs"></i>
                                Discussing microbial ecology findings
                            </li>
                            <li class="flex items-start gap-2">
                                <i class="fas fa-question-circle text-gray-400 mt-0.5 text-xs"></i>
                                Any questions about the manuscript
                            </li>
                        </ul>
                        <div class="mt-3 pt-3 border-t border-gray-100 flex items-center gap-2 text-xs text-amber-600">
                            <i class="fas fa-lightbulb"></i>
                            <span>Tip: Load context first for better responses!</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Input Area -->
            <div class="chat-input-area">
                <div class="chat-input-wrapper">
                    <textarea
                        id="chat-input"
                        class="chat-input"
                        placeholder="Ask anything about the manuscript..."
                        rows="1"
                        onkeydown="handleChatKeydown(event)"
                        oninput="autoResizeChatInput(this)"
                    ></textarea>
                    <button id="chat-send-btn" onclick="sendChatMessage()" class="chat-send-btn" title="Send message">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
                <div class="flex items-center justify-between mt-2 text-xs text-gray-400">
                    <span id="chat-status">
                        <kbd class="px-1.5 py-0.5 bg-gray-100 rounded text-gray-500 font-mono text-xs">Enter</kbd> to send
                    </span>
                    <button onclick="openContextModal()" class="text-emerald-600 hover:text-emerald-700 font-medium flex items-center gap-1">
                        <i class="fas fa-book-reader"></i>
                        <span id="context-link-text">Load Context</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Progress Widget -->
    <div id="progress-widget" class="progress-widget hidden">
        <!-- Minimized FAB -->
        <button class="progress-fab" onclick="toggleProgressWidget()" title="View progress">
            <i class="fas fa-sync-alt fa-spin"></i>
            <span class="progress-indicator" id="progress-fab-percent"></span>
        </button>

        <!-- Progress Panel -->
        <div class="progress-panel">
            <div class="progress-panel-header">
                <div class="flex items-center gap-2">
                    <i class="fas fa-cog fa-spin"></i>
                    <span class="font-semibold text-sm" id="progress-widget-title">Processing...</span>
                </div>
                <div class="flex items-center gap-1">
                    <button onclick="toggleProgressWidget()" class="header-btn" title="Minimize">
                        <i class="fas fa-minus"></i>
                    </button>
                    <button onclick="closeProgressWidget()" class="header-btn" title="Close" id="progress-close-widget-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            <div class="progress-panel-content">
                <!-- Current step indicator -->
                <div class="mb-3">
                    <div class="flex items-center justify-between mb-1">
                        <span class="text-sm font-medium text-gray-700" id="progress-current-step">Initializing...</span>
                        <span class="text-xs text-gray-500" id="progress-widget-percent">0%</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
                        <div id="progress-widget-bar" class="bg-gradient-to-r from-blue-500 to-purple-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                </div>
                <!-- Log entries -->
                <div id="progress-widget-log" class="space-y-1 text-gray-600">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Check for paper ID in URL - redirect to landing if not present
        (function() {
            const urlParams = new URLSearchParams(window.location.search);
            const paperId = urlParams.get('paper');
            if (!paperId) {
                window.location.href = 'landing.html';
                return;
            }
        })();

        // Global state
        let reviewData = null;
        let currentView = 'overview';
        let currentFilter = null;
        let editingComment = null;

        // Multi-paper state
        let papers = [];           // All available papers
        let currentPaperId = null; // Currently selected paper

        // OpenCode API connection
        let apiConnected = false;
        let currentRequestId = null;
        let pollInterval = null;

        // Chat state
        let chatHistory = [];
        let chatIsOpen = false;
        let chatIsTyping = false;

        // Comment relationship state
        let commentRelationships = {};  // Maps comment ID -> related comment IDs
        let commentChatContext = null;  // Current comment being discussed in chat

        // =====================================================
        // MULTI-PAPER MANAGEMENT
        // =====================================================

        // Load all available papers from the database
        async function loadPapers() {
            try {
                const response = await fetch(`${API_BASE}/papers`);
                if (response.ok) {
                    papers = await response.json();
                    updatePaperDropdown();

                    // Check URL for paper parameter
                    const urlParams = new URLSearchParams(window.location.search);
                    const urlPaperId = urlParams.get('paper');

                    if (urlPaperId && papers.find(p => p.id === urlPaperId)) {
                        currentPaperId = urlPaperId;
                    } else if (papers.length > 0) {
                        currentPaperId = papers[0].id;
                    }

                    if (currentPaperId) {
                        await loadPaperData(currentPaperId);
                    }
                }
            } catch (e) {
                console.log('Could not load papers from API, using local data');
                // Fall back to existing data loading
            }
        }

        // Update the paper dropdown in sidebar
        function updatePaperDropdown() {
            const dropdown = document.getElementById('paper-dropdown');
            if (!dropdown) return;

            dropdown.innerHTML = papers.length === 0
                ? '<option value="">No papers yet - add one!</option>'
                : papers.map(p => `<option value="${p.id}" ${p.id === currentPaperId ? 'selected' : ''}>${p.title}</option>`).join('');
        }

        // Switch to a different paper
        async function switchPaper(paperId) {
            if (!paperId || paperId === currentPaperId) return;

            currentPaperId = paperId;
            localStorage.setItem('rebuttr_last_paper', paperId);
            await loadPaperData(paperId);

            // Update URL without reload
            const url = new URL(window.location);
            url.searchParams.set('paper', paperId);
            window.history.pushState({}, '', url);
        }

        // Load data for a specific paper
        async function loadPaperData(paperId) {
            // Show skeleton loader while fetching
            if (currentView === 'overview') {
                showOverviewSkeleton();
            } else if (currentView === 'comments' || currentView === 'byreviewer') {
                showCommentsSkeleton();
            }

            try {
                const response = await fetch(`${API_BASE}/papers/${paperId}/data`);
                if (response.ok) {
                    reviewData = await response.json();
                    console.log('Loaded paper data:', {
                        title: reviewData?.manuscript?.title,
                        reviewers: reviewData?.reviewers?.length,
                        comments: reviewData?.reviewers?.reduce((sum, r) => sum + (r.comments?.length || 0), 0)
                    });
                    buildCommentRelationships();
                    setView(currentView);
                    document.getElementById('manuscript-title').textContent = reviewData?.manuscript?.title || 'Untitled';
                    updateSidebar(); // Update sidebar progress
                    console.log('Sidebar updated');
                    // Update context status to reflect loaded data
                    if (typeof updateContextFromLoadedData === 'function') {
                        updateContextFromLoadedData();
                    }
                } else {
                    console.error('Failed to load paper data:', response.status);
                    showNotification('Failed to load paper data', 'error');
                }
            } catch (e) {
                console.error('Could not load paper data from API:', e);
                showNotification('Could not connect to server', 'error');
            }
        }

        // Open paper manager modal
        function openPaperManager() {
            document.getElementById('project-manager-modal').classList.remove('hidden');
            // Show close button only if we have a paper selected
            const closeBtn = document.getElementById('project-manager-close');
            if (currentPaperId) {
                closeBtn.classList.remove('hidden');
            } else {
                closeBtn.classList.add('hidden');
            }
            renderProjectManager();
        }

        async function closeProjectManager() {
            if (currentPaperId) {
                // Save current work before closing
                await saveCommentsToDb();
                document.getElementById('project-manager-modal').classList.add('hidden');
                // Refresh the view
                refreshAllUI();
            }
        }

        function renderProjectManager() {
            // Update stats
            const totalPapers = papers.length;
            const totalComments = papers.reduce((sum, p) => sum + (p.total_comments || 0), 0);
            const completed = papers.filter(p => p.total_comments > 0 && p.completed === p.total_comments).length;
            const inProgress = papers.filter(p => p.total_comments > 0 && p.completed < p.total_comments).length;

            document.getElementById('pm-total-papers').textContent = totalPapers;
            document.getElementById('pm-in-progress').textContent = inProgress;
            document.getElementById('pm-completed').textContent = completed;
            document.getElementById('pm-total-comments').textContent = totalComments;

            // Render papers grid
            const grid = document.getElementById('papers-grid');
            const empty = document.getElementById('papers-empty');

            if (papers.length === 0) {
                grid.classList.add('hidden');
                empty.classList.remove('hidden');
                return;
            }

            grid.classList.remove('hidden');
            empty.classList.add('hidden');

            grid.innerHTML = papers.map(paper => {
                const total = paper.total_comments || 0;
                const done = paper.completed || 0;
                const pct = total > 0 ? Math.round((done / total) * 100) : 0;
                const isSelected = paper.id === currentPaperId;

                return `
                    <div class="bg-white rounded-lg border border-slate-200 hover:border-slate-300 transition-colors cursor-pointer group ${isSelected ? 'ring-2 ring-slate-900 ring-offset-1' : ''}" onclick="selectPaperFromManager('${paper.id}')">
                        <div class="p-4">
                            <div class="flex items-start justify-between mb-2">
                                <h3 class="text-sm font-medium text-slate-900 line-clamp-2 flex-1 pr-2">${paper.title}</h3>
                                <button onclick="event.stopPropagation(); deletePaperFromManager('${paper.id}')" class="opacity-0 group-hover:opacity-100 text-slate-400 hover:text-red-500 transition-opacity p-1" title="Move to trash">
                                    <i class="fas fa-trash-alt text-xs"></i>
                                </button>
                            </div>
                            ${paper.journal ? `<p class="text-xs text-slate-500 mb-1 truncate">${paper.journal}</p>` : ''}
                            ${paper.authors ? `<p class="text-xs text-slate-400 mb-3 truncate">${paper.authors}</p>` : '<div class="mb-3"></div>'}

                            <div class="flex items-center justify-between">
                                <div class="flex items-center gap-2">
                                    <div class="w-16 bg-slate-100 rounded-full h-1">
                                        <div class="h-1 rounded-full transition-all ${pct === 100 ? 'bg-emerald-500' : pct > 0 ? 'bg-slate-400' : 'bg-slate-200'}" style="width: ${pct}%"></div>
                                    </div>
                                    <span class="text-xs text-slate-400">${done}/${total}</span>
                                </div>
                                ${isSelected ? '<span class="text-xs text-slate-500">Open</span>' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function selectPaperFromManager(paperId) {
            if (paperId === currentPaperId) return;
            switchPaper(paperId);
            closeProjectManager();
        }

        async function deletePaperFromManager(paperId) {
            const paper = papers.find(p => p.id === paperId);
            if (!paper) return;

            if (!confirm(`Move "${paper.title}" to trash?\n\nYou can restore it later from the Trash tab.`)) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/papers/${paperId}`, { method: 'DELETE' });
                if (response.ok) {
                    await loadPapers();
                    await loadTrashedPapers();
                    if (currentPaperId === paperId) {
                        currentPaperId = null;
                        reviewData = { manuscript: {}, reviewers: [] };
                    }
                    renderProjectManager();
                    updateTrashBadge();
                } else {
                    alert('Failed to move paper to trash');
                }
            } catch (e) {
                alert('Error moving paper to trash: ' + e.message);
            }
        }

        // =====================================================
        // TRASH MANAGEMENT
        // =====================================================

        let trashedPapers = [];

        async function loadTrashedPapers() {
            try {
                const response = await fetch(`${API_BASE}/papers/trash`);
                if (response.ok) {
                    trashedPapers = await response.json();
                    updateTrashBadge();
                }
            } catch (e) {
                console.error('Error loading trashed papers:', e);
            }
        }

        function updateTrashBadge() {
            const badge = document.getElementById('trash-count-badge');
            if (trashedPapers.length > 0) {
                badge.textContent = trashedPapers.length;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
            // Also update papers count badge
            document.getElementById('papers-count-badge').textContent = papers.length;
        }

        function showPapersTab() {
            // Update tab styles
            document.getElementById('tab-papers').className = 'px-3 py-1.5 bg-white text-slate-700 rounded-md text-sm font-medium shadow-sm flex items-center gap-2';
            document.getElementById('tab-trash').className = 'px-3 py-1.5 text-slate-500 hover:text-slate-700 rounded-md text-sm font-medium flex items-center gap-2';

            // Show/hide sections
            document.getElementById('papers-grid').classList.remove('hidden');
            document.getElementById('papers-empty').classList.add('hidden');
            document.getElementById('trash-section').classList.add('hidden');
            document.getElementById('add-paper-btn').classList.remove('hidden');

            // Re-render to show correct state
            renderProjectManager();
        }

        function showTrashTab() {
            // Update tab styles
            document.getElementById('tab-papers').className = 'px-3 py-1.5 text-slate-500 hover:text-slate-700 rounded-md text-sm font-medium flex items-center gap-2';
            document.getElementById('tab-trash').className = 'px-3 py-1.5 bg-white text-slate-700 rounded-md text-sm font-medium shadow-sm flex items-center gap-2';

            // Hide papers, show trash
            document.getElementById('papers-grid').classList.add('hidden');
            document.getElementById('papers-empty').classList.add('hidden');
            document.getElementById('add-paper-form').classList.add('hidden');
            document.getElementById('trash-section').classList.remove('hidden');
            document.getElementById('add-paper-btn').classList.add('hidden');

            // Render trash
            renderTrash();
        }

        function renderTrash() {
            const grid = document.getElementById('trash-grid');
            const empty = document.getElementById('trash-empty');

            if (trashedPapers.length === 0) {
                grid.classList.add('hidden');
                empty.classList.remove('hidden');
                return;
            }

            grid.classList.remove('hidden');
            empty.classList.add('hidden');

            grid.innerHTML = trashedPapers.map(paper => {
                const deletedDate = paper.deleted_at ? new Date(paper.deleted_at).toLocaleDateString() : 'Unknown';
                return `
                    <div class="bg-white rounded-lg border border-slate-200 group">
                        <div class="p-4">
                            <div class="flex items-start justify-between mb-2">
                                <h3 class="text-sm font-medium text-slate-900 line-clamp-2 flex-1 pr-2">${paper.title}</h3>
                            </div>
                            ${paper.journal ? `<p class="text-xs text-slate-500 mb-1 truncate">${paper.journal}</p>` : ''}
                            <p class="text-xs text-slate-400 mb-3">Deleted ${deletedDate}</p>

                            <div class="flex gap-2">
                                <button onclick="restorePaper('${paper.id}')" class="flex-1 px-2.5 py-1.5 bg-slate-100 text-slate-700 hover:bg-slate-200 rounded text-xs font-medium">
                                    Restore
                                </button>
                                <button onclick="permanentlyDeletePaper('${paper.id}')" class="px-2.5 py-1.5 text-red-500 hover:bg-red-50 rounded text-xs" title="Delete permanently">
                                    <i class="fas fa-trash-alt"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function restorePaper(paperId) {
            try {
                const response = await fetch(`${API_BASE}/papers/${paperId}/restore`, { method: 'POST' });
                if (response.ok) {
                    await loadPapers();
                    await loadTrashedPapers();
                    renderTrash();
                    updateTrashBadge();
                } else {
                    const data = await response.json();
                    alert('Failed to restore paper: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error restoring paper: ' + e.message);
            }
        }

        async function permanentlyDeletePaper(paperId) {
            const paper = trashedPapers.find(p => p.id === paperId);
            if (!paper) return;

            if (!confirm(`Permanently delete "${paper.title}"?\n\nThis action cannot be undone and all data will be lost.`)) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/papers/${paperId}/permanent`, { method: 'DELETE' });
                if (response.ok) {
                    await loadTrashedPapers();
                    renderTrash();
                    updateTrashBadge();
                } else {
                    alert('Failed to permanently delete paper');
                }
            } catch (e) {
                alert('Error permanently deleting paper: ' + e.message);
            }
        }

        // =====================================================
        // DRAG-DROP FILE UPLOAD & AI INFERENCE
        // =====================================================

        // Category-based file storage
        let categoryFiles = {
            manuscript: [],
            review: [],
            supplementary: []
        };
        let inferredMetadata = null;

        function showAddPaperForm() {
            document.getElementById('add-paper-form').classList.remove('hidden');
            resetAddPaperForm();
        }

        function hideAddPaperForm() {
            document.getElementById('add-paper-form').classList.add('hidden');
            resetAddPaperForm();
        }

        function resetAddPaperForm() {
            categoryFiles = { manuscript: [], review: [], supplementary: [] };
            inferredMetadata = null;

            // Reset all dropzones
            ['manuscript', 'review', 'supplementary'].forEach(cat => {
                const filesDiv = document.getElementById(`files-${cat}`);
                const emptyDiv = document.getElementById(`dropzone-${cat}-empty`);
                if (filesDiv) filesDiv.innerHTML = '';
                if (emptyDiv) emptyDiv.classList.remove('hidden');
            });

            // Reset status displays
            const extractionSummary = document.getElementById('extraction-summary');
            if (extractionSummary) extractionSummary.classList.add('hidden');

            // Clear inputs
            ['new-paper-title', 'new-paper-authors', 'new-paper-journal', 'new-paper-field'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.value = '';
            });

            // Disable create button
            const createBtn = document.getElementById('create-paper-btn');
            if (createBtn) createBtn.disabled = true;
        }

        function handleCategoryDragOver(e, category) {
            e.preventDefault();
            e.stopPropagation();
            const dropzone = document.getElementById(`dropzone-${category}`);
            dropzone.classList.add('dropzone-active');
            dropzone.style.borderColor = '#1e293b';
            dropzone.style.backgroundColor = '#f8fafc';
        }

        function handleCategoryDragLeave(e, category) {
            e.preventDefault();
            e.stopPropagation();
            const dropzone = document.getElementById(`dropzone-${category}`);
            dropzone.classList.remove('dropzone-active');
            dropzone.style.borderColor = '';
            dropzone.style.backgroundColor = '';
        }

        async function handleCategoryDrop(e, category) {
            e.preventDefault();
            e.stopPropagation();
            const dropzone = document.getElementById(`dropzone-${category}`);
            dropzone.classList.remove('dropzone-active');
            dropzone.style.borderColor = '';
            dropzone.style.backgroundColor = '';

            const files = Array.from(e.dataTransfer.files);
            await addFilesToCategory(files, category);
        }

        async function handleCategoryFileSelect(e, category) {
            const files = Array.from(e.target.files);
            await addFilesToCategory(files, category);
            e.target.value = ''; // Reset input
        }

        async function addFilesToCategory(files, category) {
            if (files.length === 0) return;

            for (const file of files) {
                const content = await readFileContent(file);
                categoryFiles[category].push({
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    content: content,
                    file: file // Keep original file for upload
                });
            }

            updateCategoryFilesList(category);
            checkAndProcessFiles();
        }

        async function readFileContent(file) {
            const ext = file.name.split('.').pop().toLowerCase();

            // For plain text files, read directly
            if (ext === 'txt' || ext === 'md') {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }

            // For binary files (DOCX, XLSX, PDF), send to server for extraction
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const base64 = e.target.result.split(',')[1];
                        const response = await fetch(`${API_BASE}/extract-text`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ filename: file.name, data: base64 })
                        });

                        if (response.ok) {
                            const result = await response.json();
                            resolve(result.text || `[Could not extract: ${file.name}]`);
                        } else {
                            resolve(`[Error extracting: ${file.name}]`);
                        }
                    } catch (err) {
                        console.error('Text extraction error:', err);
                        resolve(`[Error: ${file.name}]`);
                    }
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function updateCategoryFilesList(category) {
            const filesDiv = document.getElementById(`files-${category}`);
            const emptyDiv = document.getElementById(`dropzone-${category}-empty`);

            if (categoryFiles[category].length === 0) {
                filesDiv.innerHTML = '';
                if (emptyDiv) emptyDiv.classList.remove('hidden');
                return;
            }

            if (emptyDiv) emptyDiv.classList.add('hidden');
            filesDiv.innerHTML = categoryFiles[category].map((f, idx) => `
                <div class="flex items-center justify-between p-2 rounded bg-slate-50 text-xs">
                    <div class="flex items-center gap-2 truncate flex-1 min-w-0">
                        <i class="fas fa-file text-slate-400"></i>
                        <span class="truncate text-slate-700">${f.name}</span>
                    </div>
                    <button onclick="event.stopPropagation(); removeCategoryFile('${category}', ${idx})" class="text-slate-400 hover:text-red-500 ml-2 flex-shrink-0">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `).join('');
        }

        function removeCategoryFile(category, index) {
            categoryFiles[category].splice(index, 1);
            updateCategoryFilesList(category);
            checkAndProcessFiles();
        }

        function clearAllDropzones() {
            categoryFiles = { manuscript: [], review: [], supplementary: [] };
            ['manuscript', 'review', 'supplementary'].forEach(cat => updateCategoryFilesList(cat));
            document.getElementById('extraction-summary').classList.add('hidden');
            document.getElementById('create-paper-btn').disabled = true;
            // Clear hidden inputs
            document.getElementById('new-paper-title').value = '';
            document.getElementById('new-paper-authors').value = '';
            document.getElementById('new-paper-journal').value = '';
            document.getElementById('new-paper-field').value = '';
        }

        async function checkAndProcessFiles() {
            const totalFiles = categoryFiles.manuscript.length + categoryFiles.review.length + categoryFiles.supplementary.length;

            if (totalFiles === 0) {
                document.getElementById('create-paper-btn').disabled = true;
                document.getElementById('extraction-summary').classList.add('hidden');
                return;
            }

            // Enable button if we have files
            document.getElementById('create-paper-btn').disabled = false;

            // Show extraction summary
            const summaryParts = [];
            if (categoryFiles.manuscript.length > 0) summaryParts.push(`${categoryFiles.manuscript.length} manuscript`);
            if (categoryFiles.review.length > 0) summaryParts.push(`${categoryFiles.review.length} review file(s)`);
            if (categoryFiles.supplementary.length > 0) summaryParts.push(`${categoryFiles.supplementary.length} supplementary`);

            document.getElementById('extraction-details').textContent = summaryParts.join(', ') + ' ready';
            document.getElementById('extraction-summary').classList.remove('hidden');
        }

        async function createNewPaperWithFiles() {
            // Generate temp title
            const timestamp = new Date().toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
            let title = `New Paper (${timestamp})`;

            const btn = document.getElementById('create-paper-btn');
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-circle-notch fa-spin mr-1"></i>Creating...';

            try {
                // IMPORTANT: Collect files FIRST before any UI changes that might clear categoryFiles
                // Step 1: Collect files with base64 data (do this before hideAddPaperForm which resets categoryFiles!)
                const filesToProcess = [];
                let fileErrors = [];

                console.log('Collecting files from categoryFiles:', {
                    manuscript: categoryFiles.manuscript.length,
                    review: categoryFiles.review.length,
                    supplementary: categoryFiles.supplementary.length
                });

                for (const category of ['manuscript', 'review', 'supplementary']) {
                    for (const fileData of categoryFiles[category]) {
                        try {
                            // Check if we have a valid File object
                            if (!fileData.file || !(fileData.file instanceof File)) {
                                console.warn(`File object missing for ${fileData.name}, using stored content`);
                                fileErrors.push(`${fileData.name}: File object not available`);
                                continue;
                            }

                            // Convert file to base64
                            const base64 = await fileToBase64(fileData.file);
                            if (!base64) {
                                fileErrors.push(`${fileData.name}: Failed to convert to base64`);
                                continue;
                            }

                            filesToProcess.push({
                                name: fileData.name,
                                category: category,
                                data: base64
                            });
                            console.log(`Added file: ${fileData.name} (${category}) - ${base64.length} chars base64`);
                        } catch (fileErr) {
                            console.error(`Error processing ${fileData.name}:`, fileErr);
                            fileErrors.push(`${fileData.name}: ${fileErr.message}`);
                        }
                    }
                }

                if (fileErrors.length > 0) {
                    console.warn('File processing errors:', fileErrors);
                }

                // Step 2: Create the paper entry
                const createResponse = await fetch(`${API_BASE}/papers`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title })
                });

                if (!createResponse.ok) {
                    throw new Error('Failed to create paper');
                }

                const { id: paperId } = await createResponse.json();

                // Now safe to switch paper and hide form (which resets categoryFiles)
                await switchPaper(paperId);
                hideAddPaperForm();
                closeProjectManager();

                // Check if we have files to process
                if (filesToProcess.length === 0) {
                    const errorMsg = fileErrors.length > 0
                        ? `No files could be processed. Errors: ${fileErrors.join(', ')}`
                        : 'Paper created (no files to process)';
                    showNotification(errorMsg, fileErrors.length > 0 ? 'error' : 'info');
                    await loadPapers();
                    refreshAllUI();
                    return;
                }

                // Step 3: Start background processing with the new progress widget
                showProgressWidget('Processing Documents');

                // Send files to start background processing
                const processResponse = await fetch(`${API_BASE}/papers/${paperId}/process`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ files: filesToProcess })
                });

                if (!processResponse.ok) {
                    const error = await processResponse.json();
                    throw new Error(error.error || 'Failed to start processing');
                }

                const { job_id } = await processResponse.json();

                // Start polling for progress
                startProgressPolling(job_id, paperId);

                // Note: Button is re-enabled immediately since processing runs in background
                btn.disabled = false;
                btn.innerHTML = 'Create Paper';

            } catch (e) {
                showNotification('Error: ' + e.message, 'error');
                closeProgressWidget();
                btn.disabled = false;
                btn.innerHTML = 'Create Paper';
            }
        }

        // Helper to convert File to base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                if (!file) {
                    reject(new Error('No file provided'));
                    return;
                }
                if (!(file instanceof File) && !(file instanceof Blob)) {
                    reject(new Error('Invalid file object'));
                    return;
                }
                const reader = new FileReader();
                reader.onload = () => {
                    try {
                        const result = reader.result;
                        if (!result || typeof result !== 'string') {
                            reject(new Error('FileReader returned invalid result'));
                            return;
                        }
                        const base64 = result.split(',')[1];
                        if (!base64) {
                            reject(new Error('Failed to extract base64 from data URL'));
                            return;
                        }
                        resolve(base64);
                    } catch (e) {
                        reject(e);
                    }
                };
                reader.onerror = () => reject(new Error('FileReader error: ' + (reader.error?.message || 'unknown')));
                reader.readAsDataURL(file);
            });
        }

        async function extractAndUpdatePaperMetadata(paperId, manuscriptFiles) {
            // Get content from manuscript files
            let content = manuscriptFiles.map(f => f.content).join('\n\n');
            content = content.substring(0, 8000);

            if (!content || content.includes('[Binary:')) {
                return; // Can't extract from binary
            }

            try {
                const prompt = `Analyze this academic document and extract metadata. Return ONLY a JSON object:

{
  "title": "Full paper title",
  "authors": "Author names (comma separated)",
  "journal": "Target journal name if mentioned",
  "field": "Research field/discipline"
}

If a field cannot be determined, use empty string.

DOCUMENT:
"""
${content}
"""

Return ONLY JSON:`;

                const response = await fetch(`${API_BASE}/ask`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        model: aiSettings?.model || 'openai/gpt-4o-mini',
                        stream: false
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    const aiResponse = result.response || '';
                    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);

                    if (jsonMatch) {
                        const metadata = JSON.parse(jsonMatch[0]);

                        // Update paper with extracted metadata
                        if (metadata.title || metadata.authors || metadata.journal || metadata.field) {
                            await fetch(`${API_BASE}/papers/${paperId}`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    title: metadata.title || undefined,
                                    authors: metadata.authors || undefined,
                                    journal: metadata.journal || undefined,
                                    field: metadata.field || undefined
                                })
                            });
                        }
                    }
                }
            } catch (e) {
                console.error('Error extracting metadata:', e);
            }
        }

        async function extractReviewsFromContent(content, filename) {
            try {
                const reviewers = await extractAllReviewersFromDocument(content);
                if (reviewers && reviewers.length > 0) {
                    // Add reviewers to reviewData
                    for (const reviewer of reviewers) {
                        const existing = reviewData.reviewers.find(r => r.id === reviewer.id);
                        if (existing) {
                            existing.comments = [...existing.comments, ...reviewer.comments];
                        } else {
                            reviewData.reviewers.push(reviewer);
                        }
                    }
                    await saveCommentsToDb();
                }
            } catch (e) {
                console.error('Error extracting from', filename, e);
            }
        }

        // Legacy function for backward compatibility
        async function createNewPaper() {
            await createNewPaperWithFiles();
        }

        // =====================================================
        // COMMENT RELATIONSHIP SYSTEM
        // =====================================================

        // Define thematic groups that link comments together
        const THEMATIC_GROUPS = {
            'dna_damage_authentication': {
                name: 'DNA Damage & Authentication',
                keywords: ['damage', 'deamination', 'authentication', 'cytosine', 'ancient', 'CT', 'terminal', 'mapDamage', 'pydamage'],
                categories: ['Authentication'],
                color: 'red'
            },
            'contamination_controls': {
                name: 'Contamination & Controls',
                keywords: ['contamination', 'control', 'blank', 'extraction', 'laboratory', 'modern', 'contaminant'],
                categories: [],
                color: 'orange'
            },
            'age_dating': {
                name: 'Age & Dating',
                keywords: ['age', 'dating', 'million', 'years', 'magnetostratigraphy', 'olduvai', 'geological', 'geochronology'],
                categories: [],
                color: 'purple'
            },
            'evolution_phylogeny': {
                name: 'Evolution & Phylogeny',
                keywords: ['evolution', 'phylogen', 'molecular clock', 'divergence', 'branch', 'tree', 'related', 'similarity'],
                categories: [],
                color: 'blue'
            },
            'methodology': {
                name: 'Methods & Analysis',
                keywords: ['method', 'pipeline', 'analysis', 'software', 'tool', 'parameter', 'threshold'],
                categories: ['Methods', 'Analysis', 'Validation'],
                color: 'cyan'
            },
            'terminology': {
                name: 'Terminology & Definitions',
                keywords: ['term', 'definition', 'biomarker', 'eDNA', 'sedaDNA', 'nomenclature'],
                categories: ['Terminology', 'Clarity'],
                color: 'yellow'
            },
            'ecology_interpretation': {
                name: 'Ecology & Interpretation',
                keywords: ['ecology', 'ecosystem', 'environment', 'habitat', 'community', 'methane', 'wetland', 'boreal'],
                categories: ['Interpretation', 'Discussion'],
                color: 'green'
            },
            'figures_tables': {
                name: 'Figures & Tables',
                keywords: ['figure', 'table', 'panel', 'legend', 'axis', 'label', 'visualization'],
                categories: ['Figure', 'Tables'],
                color: 'indigo'
            }
        };

        // Build relationships between comments
        function buildCommentRelationships() {
            if (!reviewData) return;

            const allComments = getAllComments();
            commentRelationships = {};

            // Initialize empty arrays for each comment
            allComments.forEach(c => {
                commentRelationships[c.id] = {
                    direct: [],      // Same category
                    thematic: [],    // Same thematic group
                    groups: []       // Which thematic groups this belongs to
                };
            });

            // Group comments by category
            const byCategory = {};
            allComments.forEach(c => {
                if (!byCategory[c.category]) byCategory[c.category] = [];
                byCategory[c.category].push(c.id);
            });

            // Add category-based relationships
            Object.values(byCategory).forEach(ids => {
                ids.forEach(id1 => {
                    ids.forEach(id2 => {
                        if (id1 !== id2 && !commentRelationships[id1].direct.includes(id2)) {
                            commentRelationships[id1].direct.push(id2);
                        }
                    });
                });
            });

            // Add thematic group relationships
            Object.entries(THEMATIC_GROUPS).forEach(([groupId, group]) => {
                const matchingComments = allComments.filter(c => {
                    // Check if category matches
                    if (group.categories.includes(c.category)) return true;

                    // Check if any keyword matches in the comment text
                    const text = (c.original_text + ' ' + (c.full_context || '')).toLowerCase();
                    return group.keywords.some(kw => text.includes(kw.toLowerCase()));
                });

                // Link all comments in this thematic group
                matchingComments.forEach(c1 => {
                    commentRelationships[c1.id].groups.push(groupId);
                    matchingComments.forEach(c2 => {
                        if (c1.id !== c2.id && !commentRelationships[c1.id].thematic.includes(c2.id)) {
                            commentRelationships[c1.id].thematic.push(c2.id);
                        }
                    });
                });
            });

            console.log('Built comment relationships:', Object.keys(commentRelationships).length, 'comments mapped');
        }

        // Get related comments for a given comment
        function getRelatedComments(commentId) {
            const rel = commentRelationships[commentId];
            if (!rel) return { direct: [], thematic: [], groups: [] };

            // Get unique related IDs
            const allRelated = [...new Set([...rel.direct, ...rel.thematic])];
            const comments = getAllComments();

            return {
                direct: rel.direct.map(id => comments.find(c => c.id === id)).filter(Boolean),
                thematic: rel.thematic.filter(id => !rel.direct.includes(id)).map(id => comments.find(c => c.id === id)).filter(Boolean),
                groups: rel.groups.map(g => THEMATIC_GROUPS[g]),
                allIds: allRelated
            };
        }

        // Show related comments panel
        function showRelatedComments(commentId) {
            const related = getRelatedComments(commentId);
            const comment = getAllComments().find(c => c.id === commentId);

            if (!comment) return;

            const modal = document.createElement('div');
            modal.id = 'related-comments-modal';
            modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50';
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };

            const groupBadges = related.groups.map(g =>
                `<span class="px-2 py-1 text-xs rounded bg-${g.color}-100 text-${g.color}-700">${g.name}</span>`
            ).join('');

            modal.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[80vh] overflow-hidden">
                    <div class="p-4 bg-gradient-to-r from-blue-600 to-purple-600 text-white">
                        <div class="flex items-center justify-between">
                            <div>
                                <h3 class="font-bold text-lg">Related Comments for ${commentId}</h3>
                                <p class="text-sm opacity-80">${comment.category} - ${comment.type}</p>
                            </div>
                            <button onclick="this.closest('#related-comments-modal').remove()" class="p-2 hover:bg-white/20 rounded">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="flex flex-wrap gap-2 mt-3">${groupBadges}</div>
                    </div>
                    <div class="p-4 overflow-y-auto max-h-[60vh]">
                        ${related.direct.length > 0 ? `
                            <div class="mb-4">
                                <h4 class="font-semibold text-gray-700 mb-2 flex items-center gap-2">
                                    <i class="fas fa-link text-blue-500"></i>
                                    Same Category (${related.direct.length})
                                </h4>
                                <div class="space-y-2">
                                    ${related.direct.map(c => renderRelatedCommentItem(c, commentId)).join('')}
                                </div>
                            </div>
                        ` : ''}
                        ${related.thematic.length > 0 ? `
                            <div>
                                <h4 class="font-semibold text-gray-700 mb-2 flex items-center gap-2">
                                    <i class="fas fa-project-diagram text-purple-500"></i>
                                    Thematically Related (${related.thematic.length})
                                </h4>
                                <div class="space-y-2">
                                    ${related.thematic.map(c => renderRelatedCommentItem(c, commentId)).join('')}
                                </div>
                            </div>
                        ` : ''}
                        ${related.direct.length === 0 && related.thematic.length === 0 ? `
                            <p class="text-gray-500 text-center py-8">No related comments found.</p>
                        ` : ''}
                    </div>
                    <div class="p-4 bg-gray-50 border-t flex justify-between">
                        <button onclick="discussCommentInChat('${commentId}')" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">
                            <i class="fas fa-comments mr-2"></i>Discuss in Chat
                        </button>
                        <button onclick="this.closest('#related-comments-modal').remove()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">
                            Close
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // Render a related comment item
        function renderRelatedCommentItem(comment, currentId) {
            const statusColors = {
                'pending': 'bg-yellow-100 text-yellow-700',
                'in_progress': 'bg-blue-100 text-blue-700',
                'completed': 'bg-green-100 text-green-700'
            };
            return `
                <div class="p-3 bg-gray-50 rounded-lg border hover:border-blue-300 cursor-pointer transition-all"
                     onclick="openCommentModal('${comment.reviewerId}', '${comment.id}'); document.getElementById('related-comments-modal')?.remove();">
                    <div class="flex items-center justify-between mb-1">
                        <span class="font-bold text-gray-800">${comment.id}</span>
                        <span class="px-2 py-0.5 text-xs rounded ${statusColors[comment.status] || 'bg-gray-100'}">${comment.status}</span>
                    </div>
                    <p class="text-sm text-gray-600 line-clamp-2">${comment.original_text.substring(0, 120)}...</p>
                    <div class="flex items-center gap-2 mt-2">
                        <span class="text-xs bg-gray-200 px-2 py-0.5 rounded">${comment.category}</span>
                        <span class="text-xs text-gray-500">${comment.reviewer}</span>
                    </div>
                </div>
            `;
        }

        // Discuss a comment in the floating chat
        function discussCommentInChat(commentId) {
            const comment = getAllComments().find(c => c.id === commentId);
            if (!comment) return;

            // Close related comments modal if open
            document.getElementById('related-comments-modal')?.remove();

            // Set chat context
            commentChatContext = {
                id: commentId,
                reviewer: comment.reviewer,
                category: comment.category,
                text: comment.original_text.substring(0, 500),
                currentResponse: comment.draft_response || null,
                status: comment.status,
                relatedIds: getRelatedComments(commentId).allIds
            };

            // Open chat
            if (!chatIsOpen) toggleChat();

            // Add context message
            const contextMsg = ` **Now discussing: ${commentId}**
**Reviewer:** ${comment.reviewer}
**Category:** ${comment.category}
**Status:** ${comment.status}
${commentChatContext.relatedIds.length > 0 ? `**Related:** ${commentChatContext.relatedIds.slice(0, 5).join(', ')}${commentChatContext.relatedIds.length > 5 ? '...' : ''}` : ''}

"${comment.original_text.substring(0, 200)}${comment.original_text.length > 200 ? '...' : ''}"

---
Ask me anything about this comment, or request a draft response.`;

            addChatMessage('assistant', contextMsg);
            updateChatContextBadge();
        }

        // Update chat context badge
        function updateChatContextBadge() {
            const badge = document.getElementById('chat-context-badge');
            if (badge) {
                if (commentChatContext) {
                    badge.innerHTML = `<i class="fas fa-comment-dots mr-1"></i>${commentChatContext.id}`;
                    badge.classList.remove('hidden');
                } else if (contextLoaded) {
                    badge.innerHTML = `<i class="fas fa-database mr-1"></i>Context`;
                    badge.classList.remove('hidden');
                } else {
                    badge.classList.add('hidden');
                }
            }
        }

        // Check API connection status
        async function checkApiConnection() {
            try {
                const response = await fetch(`${API_BASE}/config`);
                apiConnected = response.ok;
            } catch (e) {
                apiConnected = false;
            }
            updateApiStatus();
            return apiConnected;
        }

        function updateApiStatus() {
            const statusEl = document.getElementById('ws-status');
            if (statusEl) {
                statusEl.className = `text-xs px-2 py-1 rounded ${apiConnected ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`;
                statusEl.textContent = apiConnected ? ' OpenCode Ready' : ' API Offline';
            }
            // Also update modal status if it exists
            const modalStatus = document.getElementById('ws-status-modal');
            if (modalStatus) {
                modalStatus.className = `text-xs px-2 py-1 rounded ${apiConnected ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`;
                modalStatus.textContent = apiConnected ? ' OpenCode Ready' : ' Not Connected';
            }
        }

        // Submit request to OpenCode via file-based API
        async function submitToOpenCode(prompt, commentId) {
            const requestId = `req_${Date.now()}`;

            // Write request to claude_requests.json
            const request = {
                id: requestId,
                comment_id: commentId,
                prompt: prompt,
                status: 'pending',
                timestamp: new Date().toISOString()
            };

            try {
                // Read existing requests
                let requests = [];
                try {
                    const resp = await fetch('claude_requests.json');
                    if (resp.ok) requests = await resp.json();
                } catch (e) {}

                // Add new request
                requests.push(request);

                // Save requests file - this triggers the opencode-server.js
                await saveJsonFile('claude_requests.json', requests);

                return requestId;
            } catch (e) {
                console.error('Error submitting request:', e);
                return null;
            }
        }

        // Save JSON file via simple POST (for local development)
        async function saveJsonFile(filename, data) {
            // Try API endpoint first
            try {
                const response = await fetch(`${API_BASE}/request`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename, data })
                });
                if (response.ok) return true;
            } catch (e) {}

            // Fallback: write to localStorage for manual processing
            localStorage.setItem(filename, JSON.stringify(data));
            return true;
        }

        // Poll for response
        async function pollForResponse(requestId, commentId, maxAttempts = 60) {
            let attempts = 0;

            return new Promise((resolve, reject) => {
                pollInterval = setInterval(async () => {
                    attempts++;

                    try {
                        const resp = await fetch('claude_responses.json?t=' + Date.now());
                        if (resp.ok) {
                            const responses = await resp.json();
                            const response = responses.find(r => r.request_id === requestId);

                            if (response && response.status === 'completed') {
                                clearInterval(pollInterval);
                                resolve(response.response);
                                return;
                            }
                        }
                    } catch (e) {}

                    if (attempts >= maxAttempts) {
                        clearInterval(pollInterval);
                        reject(new Error('Response timeout'));
                    }
                }, 2000); // Poll every 2 seconds
            });
        }

        function handleOpenCodeResponse(data) {
            if (data.type === 'opencode_response') {
                // Check if this is an agent consultation response
                if (data.comment_id === 'agent-consultation' || currentAgentConsultation) {
                    handleAgentResponse(data.response);
                    return;
                }

                // Otherwise it's a comment response
                const loadingEl = document.getElementById('opencode-loading');
                if (loadingEl) loadingEl.classList.add('hidden');

                const responseEl = document.getElementById('edit-response');
                if (responseEl && data.response) {
                    responseEl.value = data.response;
                    // Trigger preview update
                    responseEl.dispatchEvent(new Event('input'));
                }

                // Update the comment data
                if (editingComment) {
                    const reviewer = reviewData.reviewers.find(r => r.id === editingComment.reviewerId);
                    const comment = reviewer?.comments.find(c => c.id === editingComment.commentId);
                    if (comment) {
                        comment.draft_response = data.response;
                    }
                }
            } else if (data.type === 'request_received') {
                console.log('Request received by OpenCode:', data.request_id);
            }
        }

        async function askOpenCodeForResponse() {
            if (!editingComment) return;

            const reviewer = reviewData.reviewers.find(r => r.id === editingComment.reviewerId);
            const comment = reviewer?.comments.find(c => c.id === editingComment.commentId);
            if (!comment) return;

            if (comment.actions_taken.length === 0) {
                alert('Please check at least one action you have taken before generating a response.');
                return;
            }

            const prompt = buildPrompt(comment, reviewer);
            const loadingEl = document.getElementById('opencode-loading');
            const btnEl = document.getElementById('ask-opencode-btn');

            // Show loading state
            if (loadingEl) loadingEl.classList.remove('hidden');
            if (btnEl) btnEl.disabled = true;

            try {
                // Submit request to OpenCode API
                const response = await fetch(`${API_BASE}/ask`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        comment_id: comment.id,
                        model: aiSettings.model,
                        agent: aiSettings.agent,
                        variant: aiSettings.variant
                    })
                });

                if (response.ok) {
                    const result = await response.json();

                    // Update the response textarea
                    const responseEl = document.getElementById('edit-response');
                    if (responseEl && result.response) {
                        // Track version history for AI-generated response
                        const oldResponse = comment.draft_response || '';
                        if (oldResponse !== result.response) {
                            await saveVersionHistoryEntry(
                                comment.id,
                                currentPaperId,
                                'draft_response',
                                oldResponse,
                                result.response,
                                'ai'
                            );
                        }

                        responseEl.value = result.response;
                        responseEl.dispatchEvent(new Event('input'));
                        comment.draft_response = result.response;
                        showNotification('Response generated successfully!', 'success');
                        scheduleAutoSave(); // Auto-save after AI response
                    }
                } else {
                    throw new Error('API request failed');
                }
            } catch (e) {
                console.error('OpenCode error:', e);
                // Fallback: copy prompt to clipboard
                navigator.clipboard.writeText(prompt).then(() => {
                    alert('OpenCode server not available.\n\nPrompt copied to clipboard!\nRun: node opencode-server.js\nOr paste the prompt in your AI tool.');
                });
            } finally {
                if (loadingEl) loadingEl.classList.add('hidden');
                if (btnEl) btnEl.disabled = false;
            }
        }

        async function pasteResponse() {
            try {
                const text = await navigator.clipboard.readText();
                const responseEl = document.getElementById('edit-response');
                if (responseEl && text) {
                    responseEl.value = text;
                    responseEl.dispatchEvent(new Event('input'));

                    // Update comment data
                    if (editingComment) {
                        const reviewer = reviewData.reviewers.find(r => r.id === editingComment.reviewerId);
                        const comment = reviewer?.comments.find(c => c.id === editingComment.commentId);
                        if (comment) {
                            comment.draft_response = text;
                        }
                    }
                }
            } catch (err) {
                alert('Could not read clipboard. Please paste manually into the response box.');
            }
        }

        // API Base URL - defined early for context checking and other functions
        const API_BASE = 'http://localhost:3001';

        // Context state
        let contextLoaded = false;
        let contextLoadedAt = null;
        let contextLoadedFiles = [];

        // Check if OpenCode already has context loaded (on page load)
        async function checkOpenCodeContextStatus() {
            try {
                const response = await fetch(`${API_BASE}/context-status`);
                if (response.ok) {
                    const status = await response.json();
                    console.log('OpenCode context status:', status);

                    if (status.contextLoaded) {
                        contextLoaded = true;
                        contextLoadedAt = status.loadedAt || new Date().toLocaleTimeString();
                        contextLoadedFiles = status.loadedFiles || [];

                        // If we don't have specific file names, show generic message
                        if (contextLoadedFiles.length === 0 && status.messageCount > 0) {
                            contextLoadedFiles = [`${status.messageCount} messages in session`];
                        }

                        updateContextStatusDisplay();
                        console.log('Context was already loaded in OpenCode session');
                        return true;
                    }
                }
            } catch (e) {
                console.log('Could not check OpenCode context status:', e.message);
            }

            // Keep contextLoaded = false (default)
            updateContextStatusDisplay();
            return false;
        }

        // Context files cache
        let contextFilesCache = null;

        // File type metadata
        const FILE_TYPE_META = {
            manuscript: { icon: 'fa-file-word', color: 'text-blue-500', label: 'Manuscript', checked: true },
            reviews: { icon: 'fa-comments', color: 'text-purple-500', label: 'Reviewer Comments', checked: true },
            damage_data: { icon: 'fa-dna', color: 'text-green-500', label: 'DNA Damage Data', checked: true },
            taxonomic_data: { icon: 'fa-bacteria', color: 'text-yellow-500', label: 'Taxonomic Data', checked: false },
            supplementary: { icon: 'fa-folder', color: 'text-orange-500', label: 'Supplementary Files', checked: false }
        };

        // Open context modal
        function openContextModal() {
            document.getElementById('context-modal').classList.remove('hidden');
            updateContextStatusDisplay();
            refreshContextFiles();
        }

        // Close context modal
        function closeContextModal() {
            document.getElementById('context-modal').classList.add('hidden');
        }

        // =====================================================
        // IMPORT REVIEWS WITH AI
        // =====================================================

        let importCurrentStep = 1;
        let extractedCommentsData = [];

        function openImportReviewsModal() {
            document.getElementById('import-reviews-modal').classList.remove('hidden');
            importCurrentStep = 1;
            updateImportStepUI();
        }

        function closeImportReviewsModal() {
            document.getElementById('import-reviews-modal').classList.add('hidden');
            importCurrentStep = 1;
            extractedCommentsData = [];
        }

        function updateImportStepUI() {
            // Update step indicators
            for (let i = 1; i <= 3; i++) {
                const stepEl = document.getElementById(`import-step-${i}`);
                const contentEl = document.getElementById(`import-step-content-${i}`);

                if (i < importCurrentStep) {
                    stepEl.classList.remove('opacity-50');
                    stepEl.querySelector('span:first-child').className = 'w-7 h-7 rounded-full bg-green-500 text-white flex items-center justify-center text-sm font-bold';
                } else if (i === importCurrentStep) {
                    stepEl.classList.remove('opacity-50');
                    stepEl.querySelector('span:first-child').className = 'w-7 h-7 rounded-full bg-purple-600 text-white flex items-center justify-center text-sm font-bold';
                } else {
                    stepEl.classList.add('opacity-50');
                    stepEl.querySelector('span:first-child').className = 'w-7 h-7 rounded-full bg-gray-300 text-gray-600 flex items-center justify-center text-sm font-bold';
                }

                contentEl.classList.toggle('hidden', i !== importCurrentStep);
            }

            // Update buttons
            const prevBtn = document.getElementById('import-prev-btn');
            const nextBtn = document.getElementById('import-next-btn');

            prevBtn.classList.toggle('hidden', importCurrentStep === 1);

            if (importCurrentStep === 1) {
                nextBtn.innerHTML = '<i class="fas fa-magic mr-1"></i>Extract Comments';
            } else if (importCurrentStep === 2) {
                nextBtn.innerHTML = '<i class="fas fa-brain mr-1"></i>Generate Expert Analysis';
            } else {
                nextBtn.innerHTML = '<i class="fas fa-check mr-1"></i>Import to Rebuttr';
            }
        }

        function prevImportStep() {
            if (importCurrentStep > 1) {
                importCurrentStep--;
                updateImportStepUI();
            }
        }

        async function nextImportStep() {
            if (importCurrentStep === 1) {
                await extractReviewComments();
            } else if (importCurrentStep === 2) {
                await generateExpertAnalysisForImported();
            } else {
                await finalizeImport();
            }
        }

        async function extractReviewComments() {
            const rawText = document.getElementById('raw-reviews-input').value.trim();
            const reviewerId = document.getElementById('reviewer-id-input').value.trim() || 'R1';
            const reviewerName = document.getElementById('reviewer-name-input').value.trim() || 'Referee #1';

            if (!rawText) {
                showNotification('Please paste reviewer comments first', 'error');
                return;
            }

            // Show processing
            document.getElementById('import-processing').classList.remove('hidden');
            document.getElementById('import-processing-status').textContent = 'Extracting and categorizing comments with AI...';

            const extractionPrompt = `Extract ALL individual comments from this peer review with MAXIMUM GRANULARITY.

## CRITICAL: SPLIT INTO SEPARATE COMMENTS
- Every LINE NUMBER reference = separate comment
- Every FIGURE reference = separate comment
- Every DISTINCT POINT = separate comment
- A reviewer's single paragraph may contain 3-5+ separate actionable items

REVIEWER: ${reviewerName} (ID: ${reviewerId})

RAW TEXT:
"""
${rawText}
"""

TASK: Extract EVERY SINGLE distinct point. A detailed review typically has 15-40+ points. If extracting <10 from a thorough review, you're merging too much.

Return JSON:
{
  "reviewer": {
    "id": "${reviewerId}",
    "name": "${reviewerName}",
    "expertise": "Infer from comments",
    "overall_assessment": "Brief summary of stance"
  },
  "comments": [
    {
      "id": "${reviewerId}-1",
      "type": "major|minor",
      "category": "Category",
      "location": "Line X | Lines X-Y | Figure X | General",
      "priority": "high|medium|low",
      "original_text": "Exact text for THIS SPECIFIC point only",
      "full_context": "Additional context if any",
      "requires_new_analysis": true|false,
      "analysis_type": ["type1", "type2"]
    }
  ]
}

CATEGORIES: Authentication, Methods, Analysis, Interpretation, Terminology, Clarity, Figure, Formatting, Novelty, Citation, Validation, Results, Discussion, Focus, Database, Accuracy
PRIORITY: high (core claims), medium (important), low (minor)
TYPE: major (significant revision) or minor (quick fix)

EXAMPLE - If reviewer says "Line 100 citation wrong. Lines 102-103 unclear. Figure 3 needs scale bar."
CORRECT: 3 separate comments for Line 100, Lines 102-103, and Figure 3
WRONG: 1 merged comment about multiple issues

Number sequentially: ${reviewerId}-1, ${reviewerId}-2, etc.`;

            try {
                const response = await fetch(`${API_BASE}/ask`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: extractionPrompt,
                        comment_id: 'extract-reviews',
                        model: aiSettings.model,
                        agent: aiSettings.agent,
                        variant: aiSettings.variant
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const result = await response.json();

                // Parse JSON from response
                const jsonMatch = result.response.match(/\{[\s\S]*\}/);
                if (!jsonMatch) throw new Error('No JSON in response');

                const extracted = JSON.parse(jsonMatch[0]);
                extractedCommentsData = extracted;

                // Show extracted comments
                renderExtractedComments(extracted);

                importCurrentStep = 2;
                updateImportStepUI();
                showNotification(`Extracted ${extracted.comments?.length || 0} comments`, 'success');

            } catch (e) {
                showNotification('Error extracting comments: ' + e.message, 'error');
                console.error('Extraction error:', e);
            } finally {
                document.getElementById('import-processing').classList.add('hidden');
            }
        }

        // =====================================================
        // CLEAN START / RE-EXTRACT FUNCTIONS
        // =====================================================

        // =====================================================
        // GLOBAL PROGRESS OVERLAY
        // =====================================================

        let progressCancelled = false;

        function showProgress(title, options = {}) {
            const overlay = document.getElementById('progress-overlay');
            const titleEl = document.getElementById('progress-title').querySelector('span');
            const stepEl = document.getElementById('progress-step');
            const detailEl = document.getElementById('progress-detail');
            const barEl = document.getElementById('progress-bar-fill');
            const percentEl = document.getElementById('progress-percent');
            const countEl = document.getElementById('progress-count');
            const logEl = document.getElementById('progress-log');
            const cancelContainer = document.getElementById('progress-cancel-container');

            titleEl.textContent = title;
            stepEl.textContent = options.step || 'Initializing...';
            detailEl.textContent = options.detail || '';
            barEl.style.width = '0%';
            percentEl.textContent = '0%';
            countEl.textContent = '';
            logEl.innerHTML = '';
            progressCancelled = false;

            if (options.cancellable) {
                cancelContainer.classList.remove('hidden');
            } else {
                cancelContainer.classList.add('hidden');
            }

            overlay.classList.remove('hidden');
        }

        function updateProgress(options) {
            const stepEl = document.getElementById('progress-step');
            const detailEl = document.getElementById('progress-detail');
            const barEl = document.getElementById('progress-bar-fill');
            const percentEl = document.getElementById('progress-percent');
            const countEl = document.getElementById('progress-count');

            if (options.step) stepEl.textContent = options.step;
            if (options.detail) detailEl.textContent = options.detail;

            if (options.percent !== undefined) {
                barEl.style.width = `${options.percent}%`;
                percentEl.textContent = `${Math.round(options.percent)}%`;
            }

            if (options.current !== undefined && options.total !== undefined) {
                const percent = (options.current / options.total) * 100;
                barEl.style.width = `${percent}%`;
                percentEl.textContent = `${Math.round(percent)}%`;
                countEl.textContent = `${options.current} / ${options.total}`;
            }
        }

        function addProgressLog(message, type = 'info') {
            const logEl = document.getElementById('progress-log');
            const icons = {
                info: '<i class="fas fa-info-circle text-blue-500"></i>',
                success: '<i class="fas fa-check-circle text-green-500"></i>',
                error: '<i class="fas fa-times-circle text-red-500"></i>',
                warning: '<i class="fas fa-exclamation-circle text-yellow-500"></i>'
            };

            const entry = document.createElement('div');
            entry.className = 'flex items-start gap-2';
            entry.innerHTML = `${icons[type] || icons.info} <span class="text-gray-700">${message}</span>`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function hideProgress() {
            document.getElementById('progress-overlay').classList.add('hidden');
            // Reset close button
            const closeBtn = document.getElementById('progress-close-btn');
            if (closeBtn) closeBtn.classList.add('hidden');
        }

        // =========================================
        // Minimizable Progress Widget System
        // =========================================
        let activeJobId = null;
        let activeJobPaperId = null;
        let progressPollInterval = null;
        let progressWidgetMinimized = false;

        function showProgressWidget(title = 'Processing...') {
            const widget = document.getElementById('progress-widget');
            widget.classList.remove('hidden');
            widget.classList.remove('minimized');
            document.getElementById('progress-widget-title').textContent = title;
            document.getElementById('progress-current-step').textContent = 'Initializing...';
            document.getElementById('progress-widget-percent').textContent = '0%';
            document.getElementById('progress-widget-bar').style.width = '0%';
            document.getElementById('progress-widget-log').innerHTML = '';
            document.getElementById('progress-fab-percent').textContent = '';
            progressWidgetMinimized = false;

            // Disable close button while processing
            document.getElementById('progress-close-widget-btn').classList.add('opacity-50', 'pointer-events-none');
        }

        function toggleProgressWidget() {
            const widget = document.getElementById('progress-widget');
            progressWidgetMinimized = !progressWidgetMinimized;

            if (progressWidgetMinimized) {
                widget.classList.add('minimized');
            } else {
                widget.classList.remove('minimized');
            }
        }

        function closeProgressWidget() {
            const widget = document.getElementById('progress-widget');
            widget.classList.add('hidden');

            // Stop polling
            if (progressPollInterval) {
                clearInterval(progressPollInterval);
                progressPollInterval = null;
            }

            // Clear stored job
            localStorage.removeItem('rebuttr_active_job');
            activeJobId = null;
            activeJobPaperId = null;
        }

        function updateProgressWidget(data) {
            const stepEl = document.getElementById('progress-current-step');
            const percentEl = document.getElementById('progress-widget-percent');
            const barEl = document.getElementById('progress-widget-bar');
            const fabPercentEl = document.getElementById('progress-fab-percent');
            const logEl = document.getElementById('progress-widget-log');
            const closeBtn = document.getElementById('progress-close-widget-btn');
            const headerIcon = document.querySelector('#progress-widget .progress-panel-header i');

            // Update step
            const stepNames = {
                'pending': 'Waiting to start...',
                'saving_files': 'Saving uploaded files...',
                'processing_manuscript': 'Processing manuscript...',
                'processing_supplementary': 'Processing supplementary files...',
                'processing_reviews': 'Processing review documents...',
                'summarizing': 'Summarizing content...',
                'parsing_comments': 'Extracting reviewer comments...',
                'saving_to_db': 'Saving to database...',
                'completed': 'Complete!',
                'failed': 'Failed'
            };

            stepEl.textContent = stepNames[data.current_step] || data.current_step || 'Processing...';

            // Update progress bar
            const percent = data.progress || 0;
            percentEl.textContent = `${percent}%`;
            barEl.style.width = `${percent}%`;
            fabPercentEl.textContent = `${percent}%`;

            // Update log entries from server logs
            if (data.logs && Array.isArray(data.logs)) {
                const existingCount = logEl.children.length;
                const newLogs = data.logs.slice(existingCount);

                for (const log of newLogs) {
                    addProgressWidgetLog(log.message, log.type || 'info');
                }
            }

            // Handle completion or failure
            if (data.status === 'completed' || data.status === 'failed') {
                // Stop spinning icon
                if (headerIcon) {
                    headerIcon.classList.remove('fa-spin');
                    headerIcon.classList.remove('fa-cog');
                    if (data.status === 'completed') {
                        headerIcon.classList.add('fa-check-circle');
                    } else {
                        headerIcon.classList.add('fa-times-circle');
                    }
                }

                // Update FAB icon
                const fabIcon = document.querySelector('#progress-widget .progress-fab i');
                if (fabIcon) {
                    fabIcon.classList.remove('fa-spin', 'fa-sync-alt');
                    fabIcon.classList.add(data.status === 'completed' ? 'fa-check' : 'fa-exclamation-triangle');
                }

                // Enable close button
                closeBtn.classList.remove('opacity-50', 'pointer-events-none');

                // Stop polling
                if (progressPollInterval) {
                    clearInterval(progressPollInterval);
                    progressPollInterval = null;
                }

                // Clear stored job
                localStorage.removeItem('rebuttr_active_job');

                // Update title
                document.getElementById('progress-widget-title').textContent =
                    data.status === 'completed' ? 'Processing Complete' : 'Processing Failed';

                // Reload data if completed successfully
                if (data.status === 'completed' && activeJobPaperId) {
                    loadPapers();
                    loadPaperData(activeJobPaperId);
                    refreshAllUI();
                    showNotification('Paper processed successfully!', 'success');
                } else if (data.status === 'failed') {
                    showNotification('Processing failed: ' + (data.error || 'Unknown error'), 'error');
                }
            }
        }

        function addProgressWidgetLog(message, type = 'info') {
            const logEl = document.getElementById('progress-widget-log');
            const icons = {
                info: 'fa-info-circle',
                success: 'fa-check-circle',
                error: 'fa-times-circle',
                warning: 'fa-exclamation-circle'
            };

            const entry = document.createElement('div');
            entry.className = `progress-log-entry ${type}`;
            entry.innerHTML = `<i class="fas ${icons[type] || icons.info}"></i><span>${message}</span>`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function startProgressPolling(jobId, paperId) {
            activeJobId = jobId;
            activeJobPaperId = paperId;

            // Store in localStorage for recovery
            localStorage.setItem('rebuttr_active_job', JSON.stringify({
                jobId,
                paperId,
                startedAt: Date.now()
            }));

            // Start polling
            progressPollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/papers/${paperId}/status`);
                    if (response.ok) {
                        const status = await response.json();
                        updateProgressWidget(status);
                    }
                } catch (e) {
                    console.error('Error polling progress:', e);
                }
            }, 1000); // Poll every second
        }

        async function recoverProgressOnLoad() {
            const stored = localStorage.getItem('rebuttr_active_job');
            if (!stored) return;

            try {
                const { jobId, paperId, startedAt } = JSON.parse(stored);

                // Check if job is still recent (within 30 minutes)
                if (Date.now() - startedAt > 30 * 60 * 1000) {
                    localStorage.removeItem('rebuttr_active_job');
                    return;
                }

                // Check current status
                const response = await fetch(`${API_BASE}/papers/${paperId}/status`);
                if (!response.ok) {
                    localStorage.removeItem('rebuttr_active_job');
                    return;
                }

                const status = await response.json();

                // If still processing, show widget and resume polling
                if (status.status === 'processing' || status.status === 'pending') {
                    showProgressWidget('Resuming Processing...');
                    updateProgressWidget(status);
                    startProgressPolling(jobId, paperId);
                } else if (status.status === 'completed' || status.status === 'failed') {
                    // Show completed/failed state briefly
                    showProgressWidget(status.status === 'completed' ? 'Processing Complete' : 'Processing Failed');
                    updateProgressWidget(status);
                }
            } catch (e) {
                console.error('Error recovering progress:', e);
                localStorage.removeItem('rebuttr_active_job');
            }
        }

        function openCleanStartModal() {
            document.getElementById('clean-start-modal').classList.remove('hidden');
            // Set up radio button listeners
            document.querySelectorAll('input[name="clean-option"]').forEach(radio => {
                radio.addEventListener('change', handleCleanOptionChange);
            });
            handleCleanOptionChange();
        }

        function closeCleanStartModal() {
            document.getElementById('clean-start-modal').classList.add('hidden');
        }

        function handleCleanOptionChange() {
            const selected = document.querySelector('input[name="clean-option"]:checked')?.value;
            const filesDiv = document.getElementById('clean-start-files');

            if (selected === 're-extract') {
                filesDiv.classList.remove('hidden');
                loadCleanStartFiles();
            } else {
                filesDiv.classList.add('hidden');
            }
        }

        async function loadCleanStartFiles() {
            const container = document.getElementById('clean-start-file-list');
            container.innerHTML = '<div class="text-sm text-gray-500 text-center"><i class="fas fa-spinner fa-spin mr-2"></i>Loading files...</div>';

            console.log('loadCleanStartFiles called, currentPaperId:', currentPaperId);

            try {
                // First try to get review files from the current paper
                let reviewFiles = [];

                if (currentPaperId) {
                    console.log('Fetching review files for paper:', currentPaperId);
                    const paperResponse = await fetch(`${API_BASE}/papers/${currentPaperId}/review-files`);
                    console.log('Response status:', paperResponse.status);
                    if (paperResponse.ok) {
                        const paperData = await paperResponse.json();
                        console.log('Paper data:', paperData);
                        reviewFiles = paperData.files || [];
                    }
                } else {
                    console.log('No currentPaperId set');
                }

                // Fallback to context-files if no paper-specific files
                if (reviewFiles.length === 0) {
                    const response = await fetch(`${API_BASE}/context-files`);
                    if (response.ok) {
                        const data = await response.json();
                        reviewFiles = data.files?.reviews?.files || [];
                    }
                }

                if (reviewFiles.length === 0) {
                    container.innerHTML = `
                        <div class="text-sm text-gray-500 text-center py-4">
                            <i class="fas fa-folder-open text-2xl text-gray-300 mb-2"></i>
                            <div>No review files found</div>
                            <div class="text-xs mt-1">Upload review files to the paper's reviews folder</div>
                        </div>`;
                    return;
                }

                container.innerHTML = reviewFiles.map(f => `
                    <label class="flex items-center gap-2 p-2 hover:bg-white rounded cursor-pointer">
                        <input type="checkbox" class="clean-start-file" value="${f.path}" checked>
                        <i class="fas fa-file-alt text-purple-400"></i>
                        <span class="text-sm flex-1 truncate">${f.name}</span>
                        <span class="text-xs text-gray-400">${f.sizeHuman}</span>
                    </label>
                `).join('');
            } catch (e) {
                console.error('Error loading clean start files:', e);
                container.innerHTML = '<div class="text-sm text-red-500 text-center">Error loading files: ' + e.message + '</div>';
            }
        }

        async function executeCleanStart() {
            const selected = document.querySelector('input[name="clean-option"]:checked')?.value;

            // IMPORTANT: Capture selected files BEFORE closing the modal
            const selectedFiles = Array.from(document.querySelectorAll('.clean-start-file:checked')).map(cb => cb.value);

            console.log('executeCleanStart called:', { selected, selectedFiles });

            // Validate selection
            if (!selected) {
                showNotification('Please select an option', 'error');
                return;
            }

            if (selected === 're-extract' && selectedFiles.length === 0) {
                showNotification('Please select at least one review file', 'error');
                return;
            }

            // Close the modal and show progress overlay
            closeCleanStartModal();

            const titles = {
                'clear-all': 'Clearing All Data',
                're-extract': 'Re-extracting Reviews',
                'clear-experts': 'Clearing Expert Analysis',
                'clear-responses': 'Clearing Draft Responses'
            };

            showProgress(titles[selected] || 'Processing...', {
                step: 'Starting...',
                cancellable: selected === 're-extract'
            });

            addProgressLog(`Selected operation: ${selected}`, 'info');
            if (selected === 're-extract') {
                addProgressLog(`Files to process: ${selectedFiles.length}`, 'info');
                selectedFiles.forEach(f => addProgressLog(`   ${f.split('/').pop()}`, 'info'));
            }

            try {
                switch (selected) {
                    case 'clear-all':
                        // Count what we're clearing
                        const reviewerCount = reviewData.reviewers?.length || 0;
                        const commentCount = reviewData.reviewers?.reduce((sum, r) => sum + (r.comments?.length || 0), 0) || 0;
                        const expertCount = Object.keys(expertDiscussions?.expert_discussions || {}).length;

                        addProgressLog(`Current data: ${reviewerCount} reviewers, ${commentCount} comments, ${expertCount} expert analyses`, 'info');

                        updateProgress({ step: 'Clearing reviewers...', percent: 20 });
                        addProgressLog('Clearing reviewers and comments...', 'info');
                        await new Promise(r => setTimeout(r, 200));

                        updateProgress({ step: 'Clearing expert discussions...', percent: 40 });
                        addProgressLog('Clearing expert discussions...', 'info');
                        await new Promise(r => setTimeout(r, 200));

                        updateProgress({ step: 'Clearing local storage...', percent: 60 });
                        addProgressLog('Clearing local storage...', 'info');
                        await new Promise(r => setTimeout(r, 200));

                        updateProgress({ step: 'Syncing with server...', percent: 80 });
                        addProgressLog('Syncing with server...', 'info');
                        await clearAllData();

                        updateProgress({ step: 'Complete', percent: 100 });
                        addProgressLog(`Cleared: ${reviewerCount} reviewers, ${commentCount} comments, ${expertCount} expert analyses`, 'success');
                        break;

                    case 're-extract':
                        await reExtractFromFiles(selectedFiles);
                        break;

                    case 'clear-experts':
                        const expertCountBefore = Object.keys(expertDiscussions?.expert_discussions || {}).length;
                        addProgressLog(`Found ${expertCountBefore} expert analyses to clear`, 'info');

                        updateProgress({ step: 'Removing expert analysis...', percent: 50 });
                        await clearExpertAnalysis();

                        updateProgress({ step: 'Complete', percent: 100 });
                        addProgressLog(`Cleared ${expertCountBefore} expert analyses`, 'success');
                        break;

                    case 'clear-responses':
                        const responseCount = reviewData.reviewers?.reduce((sum, r) =>
                            sum + (r.comments?.filter(c => c.draft_response)?.length || 0), 0) || 0;
                        addProgressLog(`Found ${responseCount} draft responses to clear`, 'info');

                        updateProgress({ step: 'Resetting responses...', percent: 50 });
                        await clearDraftResponses();

                        updateProgress({ step: 'Complete', percent: 100 });
                        addProgressLog(`Cleared ${responseCount} draft responses`, 'success');
                        break;
                }

                // Show completion
                addProgressLog('', 'info');
                addProgressLog('Done!', 'success');
                showProgressCloseButton();
                updateSidebar();
                setView('overview');

            } catch (e) {
                console.error('executeCleanStart error:', e);
                addProgressLog(`Error: ${e.message}`, 'error');
                addProgressLog('Stack: ' + (e.stack || 'N/A').split('\n')[1], 'error');
                showProgressCloseButton();
            }
        }

        async function clearAllData() {
            // Clear from database first
            if (currentPaperId) {
                try {
                    const response = await fetch(`${API_BASE}/papers/${currentPaperId}/clear`, {
                        method: 'POST'
                    });
                    if (response.ok) {
                        const result = await response.json();
                        console.log('Database cleared:', result);
                    }
                } catch (e) {
                    console.error('Error clearing database:', e);
                }
            }

            // Clear in-memory data
            reviewData = {
                manuscript: reviewData.manuscript || { title: 'New Manuscript', authors: '', submission_date: '', review_date: '' },
                reviewers: []
            };
            expertDiscussions = { expert_discussions: {} };
            contextLoaded = false;
            contextLoadedFiles = [];

            // Clear localStorage
            localStorage.removeItem('expertDiscussions');
            localStorage.removeItem('reviewData');

            // Refresh all UI components
            refreshAllUI();
        }

        // Refresh all UI components after data changes
        function refreshAllUI() {
            updateContextStatusDisplay();
            updateSidebar();
            // Re-render current view if it's an overview/comments view
            const currentView = document.querySelector('.tab-active')?.dataset?.view || 'overview';
            if (typeof setView === 'function') {
                setView(currentView);
            }
        }

        // Extract ALL reviewers and their comments from a review document using AI
        async function extractAllReviewersFromDocument(content) {
            const extractionPrompt = `You are an expert scientific reviewer analyst extracting ACTIONABLE reviewer comments from a peer review document.

## DOCUMENT TO ANALYZE:
"""
${content}
"""

## YOUR GOAL:
Extract comments that REQUIRE A RESPONSE from the authors. Focus on quality over quantity.

## WHAT TO EXTRACT (ACTIONABLE ITEMS):
- Specific criticisms or concerns requiring response
- Requests for clarification or additional explanation
- Suggested analyses, experiments, or revisions
- Questions about methods, results, or interpretation
- Issues with figures, tables, or data presentation
- Requests for citations or references
- Technical corrections (typos, formatting) - group nearby ones together

## WHAT TO SKIP (NON-ACTIONABLE):
- Praise or positive summary statements ("well written", "interesting study")
- Descriptive summaries of what the paper does
- General background or context the reviewer provides
- Statements that are observations without requiring action

## GROUPING RULES:
- Merge a PROBLEM + its SUGGESTED SOLUTION into ONE comment
- Group multiple small formatting fixes for the same section together
- Group related line references if they're about the same issue
- Keep conceptually distinct concerns as separate comments
- NEVER create duplicate comments - if a point appears twice, extract it only once

## EXPECTED OUTPUT:
A thorough reviewer typically has 10-25 actionable comments.
- Referee #1 (detailed): expect 15-25 comments
- Referee #3 (moderate): expect 8-15 comments
- Referee #4 (moderate): expect 10-20 comments

## OUTPUT FORMAT (JSON):
Return ONLY valid JSON:
{
  "reviewers": [
    {
      "id": "R1",
      "name": "Referee #1",
      "expertise": "Inferred expertise from comments",
      "overall_assessment": "Critical/Supportive/Mixed - brief summary",
      "comments": [
        {
          "id": "R1-1",
          "type": "major",
          "category": "Authentication",
          "location": "General/Lines 50-60",
          "priority": "high",
          "original_text": "The full actionable comment text. If the reviewer states a problem AND suggests a solution, include both here as one comment.",
          "requires_new_analysis": true,
          "analysis_type": ["phylogenetics"]
        },
        {
          "id": "R1-2",
          "type": "minor",
          "category": "Formatting",
          "location": "Lines 37, 45, 52",
          "priority": "low",
          "original_text": "Several typos/formatting issues: Line 37 remove extra period; Line 45 fix capitalization; Line 52 missing reference.",
          "requires_new_analysis": false,
          "analysis_type": []
        }
      ]
    }
  ]
}

## CATEGORIES:
Authentication, Methods, Analysis, Interpretation, Terminology, Clarity, Figure, Formatting, Citation, Data, Discussion, Reproducibility

## TYPE:
- major: Requires significant revision, new analysis, or substantial rewriting
- minor: Quick fixes, clarifications, small edits

## PRIORITY:
- high: Fundamental concern that could block publication
- medium: Important issue requiring attention
- low: Minor improvement, nice to have

## CRITICAL RULES:
1. Only extract comments that REQUIRE AUTHOR ACTION
2. Merge problem + solution into single comment
3. NO DUPLICATES - each point extracted only once
4. Group nearby minor fixes together
5. Skip praise and non-actionable observations
6. Number comments sequentially: R1-1, R1-2... R3-1, R3-2...
7. Return ONLY valid JSON, no other text`;

            const response = await fetch(`${API_BASE}/ask`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt: extractionPrompt,
                    comment_id: 'extract-all-reviewers',
                    model: aiSettings.model,
                    agent: aiSettings.agent,
                    variant: aiSettings.variant
                })
            });

            if (!response.ok) throw new Error('API request failed: ' + response.statusText);

            const result = await response.json();

            if (!result.success || !result.response) {
                throw new Error('Invalid API response');
            }

            // Extract JSON from response
            const jsonMatch = result.response.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                console.error('No JSON found in response:', result.response.substring(0, 500));
                throw new Error('No JSON found in AI response');
            }

            const extracted = JSON.parse(jsonMatch[0]);

            if (!extracted.reviewers || !Array.isArray(extracted.reviewers)) {
                throw new Error('Invalid response format - missing reviewers array');
            }

            return extracted.reviewers;
        }

        async function reExtractFromFiles(selectedFiles) {
            if (!selectedFiles || selectedFiles.length === 0) {
                throw new Error('No files selected');
            }

            const totalFiles = selectedFiles.length;
            let processedFiles = 0;

            addProgressLog(`Found ${totalFiles} review file(s) to process`, 'info');

            // Clear existing data first
            updateProgress({ step: 'Clearing existing data...', detail: 'Preparing for fresh extraction' });
            addProgressLog('Clearing existing data...', 'info');
            await clearAllData();
            addProgressLog('Data cleared', 'success');

            // Read each file and extract
            for (const filePath of selectedFiles) {
                if (isProgressCancelled()) {
                    addProgressLog('Cancelled by user', 'warning');
                    break;
                }

                const filename = filePath.split('/').pop();
                const fileExt = filename.split('.').pop().toLowerCase();
                processedFiles++;

                addProgressLog('', 'info'); // Empty line for readability
                addProgressLog(` File ${processedFiles}/${totalFiles}: ${filename} `, 'info');

                updateProgress({
                    step: `Reading file ${processedFiles}/${totalFiles}`,
                    detail: filename,
                    current: processedFiles - 0.7,
                    total: totalFiles
                });

                try {
                    // Read file content via server
                    addProgressLog(`Reading ${fileExt.toUpperCase()} file...`, 'info');
                    const response = await fetch(`${API_BASE}/read-file`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ path: filePath })
                    });

                    if (!response.ok) {
                        addProgressLog(`Failed to read file: ${response.statusText}`, 'error');
                        continue;
                    }

                    const { content } = await response.json();
                    const fileSizeKB = (content.length / 1024).toFixed(1);
                    addProgressLog(`File loaded: ${fileSizeKB} KB of text content`, 'success');

                    // Send entire document to AI for extraction
                    updateProgress({
                        step: `AI Extraction: ${filename}`,
                        detail: 'Sending to AI for comprehensive extraction...',
                        current: processedFiles - 0.5,
                        total: totalFiles
                    });

                    addProgressLog('Sending document to AI for extraction...', 'info');
                    addProgressLog('AI will extract ACTIONABLE comments only (skipping praise/summaries)', 'info');
                    addProgressLog('(This may take 1-2 minutes for large documents)', 'info');

                    try {
                        const extractedReviewers = await extractAllReviewersFromDocument(content);

                        addProgressLog(` AI identified ${extractedReviewers.length} reviewer(s)`, 'success');

                        // Add each reviewer to reviewData
                        for (const reviewer of extractedReviewers) {
                            const commentCount = reviewer.comments?.length || 0;
                            const majorCount = reviewer.comments?.filter(c => c.type === 'major').length || 0;

                            addProgressLog(`   ${reviewer.name}: ${commentCount} comments (${majorCount} major)`, 'info');

                            // Add default fields to comments
                            reviewer.comments = (reviewer.comments || []).map(c => ({
                                ...c,
                                status: 'pending',
                                draft_response: '',
                                actions_taken: []
                            }));

                            // Check if reviewer already exists
                            const existingIndex = reviewData.reviewers.findIndex(r => r.id === reviewer.id);
                            if (existingIndex >= 0) {
                                reviewData.reviewers[existingIndex] = reviewer;
                            } else {
                                reviewData.reviewers.push(reviewer);
                            }
                        }

                    } catch (extractErr) {
                        addProgressLog(` Extraction error: ${extractErr.message}`, 'error');
                        console.error('Extraction error:', extractErr);
                    }

                    updateProgress({
                        step: `Completed: ${filename}`,
                        current: processedFiles,
                        total: totalFiles
                    });

                } catch (e) {
                    console.error('Error processing file:', filePath, e);
                    addProgressLog(`Error: ${e.message}`, 'error');
                }
            }

            // Save final data
            updateProgress({ step: 'Finalizing...', detail: 'Writing to database', percent: 95 });
            addProgressLog('Saving extracted data to database...', 'info');
            await saveProgress();
            addProgressLog('Data saved successfully', 'success');
            updateProgress({ percent: 100 });

            // Detailed Summary
            const totalComments = reviewData.reviewers.reduce((sum, r) => sum + (r.comments?.length || 0), 0);
            const totalMajor = reviewData.reviewers.reduce((sum, r) => sum + (r.comments?.filter(c => c.type === 'major').length || 0), 0);
            const totalMinor = totalComments - totalMajor;
            const highPriority = reviewData.reviewers.reduce((sum, r) => sum + (r.comments?.filter(c => c.priority === 'high').length || 0), 0);

            addProgressLog(''.repeat(40), 'info');
            addProgressLog('EXTRACTION COMPLETE', 'success');
            addProgressLog(`Total reviewers: ${reviewData.reviewers.length}`, 'info');
            addProgressLog(`Total comments: ${totalComments}`, 'info');
            addProgressLog(`   Major: ${totalMajor}`, 'info');
            addProgressLog(`   Minor: ${totalMinor}`, 'info');
            addProgressLog(`   High priority: ${highPriority}`, 'info');
            addProgressLog(''.repeat(40), 'info');

            // Per-reviewer summary
            reviewData.reviewers.forEach(r => {
                const major = r.comments?.filter(c => c.type === 'major').length || 0;
                const minor = (r.comments?.length || 0) - major;
                addProgressLog(`${r.name}: ${r.comments?.length || 0} comments (${major} major, ${minor} minor)`, 'info');
            });
        }

        async function extractReviewsWithScientistSkill(content, reviewerId, reviewerName) {
            const scientistPrompt = `You are an expert scientific reviewer analyst tasked with extracting ALL individual comments from peer review text with MAXIMUM GRANULARITY.

## CRITICAL EXTRACTION RULES - READ CAREFULLY

1. **ONE POINT = ONE COMMENT**: If a reviewer mentions multiple issues in one paragraph or sentence, SPLIT them into separate comments.

2. **LINE REFERENCES ARE SEPARATORS**: Every specific line number, line range, or figure reference becomes its OWN comment.
   - "Line 100: X. Line 105: Y"  TWO separate comments
   - "Lines 100-110 need work and Figure 3 is unclear"  TWO separate comments
   - A paragraph mentioning Lines 54-57, Lines 140-154, and Figure 3  THREE separate comments minimum

3. **NUMBERED REVIEWER ITEMS OFTEN CONTAIN MULTIPLES**: A single numbered point (like "1." or "a)") from the reviewer may contain 3-5+ distinct actionable items. Extract EACH as its own comment.

4. **MINOR POINTS ARE STILL SEPARATE**: Typos, citation fixes, clarification requests - each is its own comment.

5. **QUESTIONS ARE COMMENTS**: Each question the reviewer asks is a separate actionable comment.

## EXPECTED OUTPUT VOLUME
A thorough reviewer typically raises 15-40+ individual points. If you extract fewer than 10 comments from a detailed review, you are almost certainly merging things that should be separate. When in doubt, SPLIT.

## REVIEWER: ${reviewerName} (ID: ${reviewerId})

## REVIEW TEXT:
"""
${content}
"""

## OUTPUT FORMAT
Return a JSON object:
{
  "reviewer": {
    "id": "${reviewerId}",
    "name": "${reviewerName}",
    "expertise": "Infer from their comments",
    "overall_assessment": "Supportive/Critical/Mixed",
    "key_concerns": ["Top concern 1", "Top concern 2"]
  },
  "comments": [
    {
      "id": "${reviewerId}-1",
      "type": "major|minor",
      "category": "Category from list below",
      "location": "Line X | Lines X-Y | Figure X | Table X | General | Methods | Discussion",
      "priority": "high|medium|low",
      "original_text": "The EXACT text for THIS SPECIFIC point only - not the whole paragraph",
      "full_context": "Surrounding context if helpful",
      "requires_new_analysis": true|false,
      "analysis_type": ["phylogenetics", "statistics", etc.]
    }
  ]
}

## CATEGORIES
- Authentication (DNA damage, age verification, contamination concerns)
- Methods (protocols, parameters, pipelines, software)
- Analysis (statistics, data analysis approaches)
- Interpretation (conclusions, claims, how results are interpreted)
- Terminology (word choices, definitions, jargon)
- Clarity (unclear writing, confusing explanations)
- Figure (figures, tables, visualizations, legends)
- Formatting (typos, formatting, minor edits)
- Novelty (significance, what's new)
- Citation (references, missing citations, incorrect citations)
- Validation (additional validation requests)
- Results (specific findings questions)
- Discussion (discussion section concerns)
- Focus (scope, manuscript direction)
- Database (database choices, reference selection)
- Accuracy (factual corrections, dates, names)

## PRIORITY
- high: Core claims challenged, could block publication
- medium: Important, significantly improves paper
- low: Nice to have, minor improvements

## TYPE
- major: Requires significant revision, new analysis, major rewriting
- minor: Quick fixes, clarifications, small additions

## EXAMPLE OF CORRECT GRANULAR EXTRACTION

If reviewer writes: "The methods need work. Line 100 citation is wrong. Lines 102-103 threshold unclear. Figure 3 needs scale bar."

CORRECT extraction (4 comments):
- ${reviewerId}-1: "Line 100 citation is wrong" (Citation, low, Line 100)
- ${reviewerId}-2: "Lines 102-103 threshold unclear" (Clarity, medium, Lines 102-103)
- ${reviewerId}-3: "Figure 3 needs scale bar" (Figure, low, Figure 3)
- ${reviewerId}-4: "The methods need work" (Methods, medium, General) - only if this is a separate overarching concern

WRONG extraction (1 comment):
- ${reviewerId}-1: "The methods need work including citation issues, unclear thresholds, and figure problems"

## FINAL CHECK
Before responding, verify you have:
 Split every line reference into its own comment
 Split every figure/table mention into its own comment
 Split multi-part paragraphs appropriately
 Captured all questions as separate comments
 Included all minor points (typos, formatting)
 Numbered sequentially: ${reviewerId}-1, ${reviewerId}-2, etc.`;

            const response = await fetch(`${API_BASE}/ask`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt: scientistPrompt,
                    comment_id: `extract-${reviewerId}`,
                    model: aiSettings.model,
                    agent: aiSettings.agent,
                    variant: aiSettings.variant
                })
            });

            if (!response.ok) throw new Error('API request failed');

            const result = await response.json();
            const jsonMatch = result.response.match(/\{[\s\S]*\}/);
            if (!jsonMatch) throw new Error('No JSON in response');

            const extracted = JSON.parse(jsonMatch[0]);

            // Add to reviewData
            const reviewer = {
                id: extracted.reviewer?.id || reviewerId,
                name: extracted.reviewer?.name || reviewerName,
                expertise: extracted.reviewer?.expertise || 'Unknown',
                overall_assessment: extracted.reviewer?.overall_assessment || '',
                comments: (extracted.comments || []).map(c => ({
                    ...c,
                    status: 'pending',
                    draft_response: '',
                    actions_taken: []
                }))
            };

            // Check if reviewer already exists
            const existingIndex = reviewData.reviewers.findIndex(r => r.id === reviewer.id);
            if (existingIndex >= 0) {
                reviewData.reviewers[existingIndex] = reviewer;
            } else {
                reviewData.reviewers.push(reviewer);
            }
        }

        async function clearExpertAnalysis() {
            expertDiscussions = { expert_discussions: {} };
            localStorage.removeItem('expertDiscussions');
            await saveExpertDiscussions();
        }

        async function clearDraftResponses() {
            for (const reviewer of reviewData.reviewers) {
                for (const comment of reviewer.comments) {
                    comment.draft_response = '';
                    comment.status = 'pending';
                    comment.actions_taken = [];
                }
            }
            await saveProgress();
        }

        function renderExtractedComments(data) {
            const container = document.getElementById('extracted-comments-list');
            const comments = data.comments || [];

            document.getElementById('extracted-count').textContent = `${comments.length} comments found`;

            if (comments.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-500 py-4">No comments extracted</div>';
                return;
            }

            container.innerHTML = comments.map(c => `
                <div class="bg-white border rounded p-3 text-sm">
                    <div class="flex items-center gap-2 mb-2">
                        <span class="font-mono text-xs bg-gray-100 px-1.5 py-0.5 rounded">${c.id}</span>
                        <span class="px-2 py-0.5 rounded text-xs ${c.type === 'major' ? 'bg-red-100 text-red-700' : 'bg-gray-100 text-gray-700'}">${c.type}</span>
                        <span class="px-2 py-0.5 rounded text-xs bg-blue-100 text-blue-700">${c.category}</span>
                        <span class="px-2 py-0.5 rounded text-xs ${c.priority === 'high' ? 'bg-red-50 text-red-600' : c.priority === 'medium' ? 'bg-yellow-50 text-yellow-600' : 'bg-green-50 text-green-600'}">${c.priority}</span>
                        ${c.location && c.location !== 'General' ? `<span class="text-xs text-gray-400">${c.location}</span>` : ''}
                    </div>
                    <p class="text-gray-700 text-xs line-clamp-3">${c.original_text}</p>
                </div>
            `).join('');
        }

        async function generateExpertAnalysisForImported() {
            if (!extractedCommentsData || !extractedCommentsData.comments?.length) {
                showNotification('No comments to analyze', 'error');
                return;
            }

            const comments = extractedCommentsData.comments;
            const progressEl = document.getElementById('expert-generation-progress');
            const progressBar = document.getElementById('expert-progress-bar');
            const progressText = document.getElementById('expert-progress-text');

            importCurrentStep = 3;
            updateImportStepUI();

            progressEl.classList.remove('hidden');
            document.getElementById('import-processing').classList.remove('hidden');

            // Initialize expert discussions if needed
            if (!expertDiscussions) {
                expertDiscussions = { expert_discussions: {} };
            }

            let completed = 0;
            const total = comments.length;

            for (const comment of comments) {
                progressBar.style.width = `${(completed / total) * 100}%`;
                progressText.textContent = `Processing ${comment.id} (${completed + 1}/${total})...`;
                document.getElementById('import-processing-status').textContent = `Analyzing ${comment.id} with expert panel...`;

                try {
                    await regenerateExpertForCommentSilent(comment);
                    completed++;
                } catch (e) {
                    console.error(`Failed to generate expert analysis for ${comment.id}:`, e);
                }

                // Small delay between requests
                await new Promise(r => setTimeout(r, 500));
            }

            progressBar.style.width = '100%';
            progressText.textContent = `Complete! ${completed}/${total} analyzed`;
            document.getElementById('import-processing').classList.add('hidden');

            showNotification(`Generated expert analysis for ${completed} comments`, 'success');
        }

        async function finalizeImport() {
            if (!extractedCommentsData || !extractedCommentsData.comments?.length) {
                showNotification('No data to import', 'error');
                return;
            }

            // Add reviewer to reviewData
            const reviewer = {
                id: extractedCommentsData.reviewer?.id || 'R1',
                name: extractedCommentsData.reviewer?.name || 'Referee #1',
                expertise: extractedCommentsData.reviewer?.expertise || 'Unknown',
                overall_assessment: extractedCommentsData.reviewer?.overall_assessment || '',
                comments: extractedCommentsData.comments.map(c => ({
                    ...c,
                    status: 'pending',
                    draft_response: '',
                    actions_taken: []
                }))
            };

            // Check if reviewer already exists
            const existingIndex = reviewData.reviewers.findIndex(r => r.id === reviewer.id);
            if (existingIndex >= 0) {
                if (confirm(`Reviewer ${reviewer.id} already exists. Replace?`)) {
                    reviewData.reviewers[existingIndex] = reviewer;
                } else {
                    // Append with new ID
                    const newId = `R${reviewData.reviewers.length + 1}`;
                    reviewer.id = newId;
                    reviewer.comments.forEach((c, i) => c.id = `${newId}-${i + 1}`);
                    reviewData.reviewers.push(reviewer);
                }
            } else {
                reviewData.reviewers.push(reviewer);
            }

            // Save to database
            await saveProgress();
            await saveExpertDiscussions();

            // Update UI
            updateSidebar();
            setView('overview');

            closeImportReviewsModal();
            showNotification(`Imported ${reviewer.comments.length} comments from ${reviewer.name}`, 'success');
        }

        // Refresh context files from server
        async function refreshContextFiles() {
            const container = document.getElementById('context-files-checkboxes');
            container.innerHTML = `
                <div class="text-sm text-gray-500 p-4 text-center">
                    <i class="fas fa-spinner fa-spin mr-2"></i>Loading available files...
                </div>
            `;

            try {
                // Use paper-specific endpoint if we have a current paper
                const endpoint = currentPaperId
                    ? `${API_BASE}/papers/${currentPaperId}/context-files`
                    : `${API_BASE}/context-files`;
                const response = await fetch(endpoint);
                if (!response.ok) throw new Error('Failed to fetch files');

                const data = await response.json();
                contextFilesCache = data.files;
                renderContextFiles(data.files);
            } catch (e) {
                console.error('Error fetching context files:', e);
                container.innerHTML = `
                    <div class="text-sm text-red-500 p-4 text-center">
                        <i class="fas fa-exclamation-triangle mr-2"></i>
                        Could not load file list. Server may be offline.
                        <button onclick="refreshContextFiles()" class="block mx-auto mt-2 text-blue-600 hover:underline">
                            Try Again
                        </button>
                    </div>
                `;
            }
        }

        // Render context files checkboxes - compact collapsible design
        function renderContextFiles(files) {
            const container = document.getElementById('context-files-checkboxes');
            let html = '';

            for (const [fileType, meta] of Object.entries(FILE_TYPE_META)) {
                const fileInfo = files[fileType];
                const available = fileInfo && fileInfo.available;
                const fileList = fileInfo?.files || [];
                const isExpanded = fileType === 'manuscript' || fileType === 'reviews'; // Auto-expand these

                // Category header - collapsible
                html += `
                    <div class="border rounded-lg overflow-hidden mb-2 ${available ? '' : 'opacity-50'}">
                        <div class="flex items-center justify-between p-2 bg-gray-50 cursor-pointer hover:bg-gray-100"
                             onclick="toggleCategoryExpand('${fileType}')">
                            <div class="flex items-center gap-2">
                                <i class="fas fa-chevron-right text-gray-400 text-xs transition-transform category-chevron-${fileType} ${isExpanded ? 'rotate-90' : ''}"></i>
                                <i class="fas ${meta.icon} ${meta.color} text-sm"></i>
                                <span class="text-sm font-medium text-gray-700">${meta.label}</span>
                                <span class="text-xs bg-gray-200 text-gray-600 px-1.5 py-0.5 rounded">${fileList.length}</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="text-xs text-gray-400 category-selected-${fileType}">0 selected</span>
                                ${available && fileList.length > 0 ? `
                                    <button type="button" onclick="event.stopPropagation(); toggleCategoryFiles('${fileType}')"
                                            class="text-xs text-blue-600 hover:text-blue-800 px-2 py-0.5 rounded hover:bg-blue-50">
                                        Toggle
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                `;

                if (available && fileList.length > 0) {
                    html += `<div class="category-content-${fileType} ${isExpanded ? '' : 'hidden'} border-t">`;
                    html += `<div class="grid grid-cols-1 sm:grid-cols-2 gap-1 p-2 max-h-48 overflow-y-auto bg-white">`;
                    for (const file of fileList) {
                        // Default: check important files
                        const shouldCheck = meta.checked ||
                            file.name.includes('reviewer_comments') ||
                            file.name.includes('revised-tracked') ||
                            file.name.includes('expert_discussions');
                        const checkedAttr = shouldCheck ? 'checked' : '';

                        // File icon based on extension
                        const ext = file.name.split('.').pop().toLowerCase();
                        let fileIcon = 'fa-file';
                        let iconColor = 'text-gray-400';
                        if (ext === 'docx' || ext === 'doc') { fileIcon = 'fa-file-word'; iconColor = 'text-blue-400'; }
                        else if (ext === 'pdf') { fileIcon = 'fa-file-pdf'; iconColor = 'text-red-400'; }
                        else if (ext === 'json') { fileIcon = 'fa-file-code'; iconColor = 'text-green-400'; }
                        else if (ext === 'xlsx' || ext === 'xls') { fileIcon = 'fa-file-excel'; iconColor = 'text-green-500'; }
                        else if (ext === 'tsv' || ext === 'csv') { fileIcon = 'fa-file-csv'; iconColor = 'text-green-400'; }
                        else if (ext === 'md') { fileIcon = 'fa-file-alt'; iconColor = 'text-gray-500'; }
                        else if (ext === 'png' || ext === 'jpg') { fileIcon = 'fa-file-image'; iconColor = 'text-purple-400'; }

                        // Truncate long filenames
                        const shortName = file.name.length > 28 ? file.name.substring(0, 25) + '...' : file.name;

                        html += `
                            <label class="flex items-center gap-1.5 p-1.5 rounded border hover:bg-blue-50 cursor-pointer text-xs">
                                <input type="checkbox" class="context-file-checkbox flex-shrink-0"
                                    data-category="${fileType}"
                                    data-size="${file.size}"
                                    value="${file.path}"
                                    ${checkedAttr}>
                                <i class="fas ${fileIcon} ${iconColor} flex-shrink-0"></i>
                                <span class="truncate flex-1" title="${file.name}">${shortName}</span>
                                <span class="text-gray-400 flex-shrink-0">${file.sizeHuman}</span>
                            </label>
                        `;
                    }
                    html += `</div></div>`;
                }

                html += `</div>`;
            }

            container.innerHTML = html;

            // Add event listeners to update selected info
            container.querySelectorAll('.context-file-checkbox').forEach(cb => {
                cb.addEventListener('change', updateSelectedFilesInfo);
            });
            updateSelectedFilesInfo();
        }

        // Toggle all files in a category
        function toggleCategoryFiles(category) {
            const checkboxes = document.querySelectorAll(`.context-file-checkbox[data-category="${category}"]`);
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !allChecked);
            updateSelectedFilesInfo();
        }

        // Update selected files count and size
        function updateSelectedFilesInfo() {
            const allCheckboxes = document.querySelectorAll('.context-file-checkbox');
            const checkedCheckboxes = document.querySelectorAll('.context-file-checkbox:checked');
            let totalSize = 0;
            let fileCount = checkedCheckboxes.length;

            // Count per category
            const categoryCounts = {};

            checkedCheckboxes.forEach(cb => {
                const category = cb.dataset.category;
                const size = parseInt(cb.dataset.size) || 0;
                totalSize += size;

                categoryCounts[category] = (categoryCounts[category] || 0) + 1;
            });

            // Update main info display
            const infoEl = document.getElementById('selected-files-info');
            if (infoEl) {
                const sizeStr = formatBytesJS(totalSize);
                infoEl.textContent = `${fileCount} file${fileCount !== 1 ? 's' : ''} (${sizeStr})`;

                // Warn if size is very large
                if (totalSize > 50 * 1024 * 1024) {
                    infoEl.className = 'text-sm text-orange-600 font-medium';
                } else {
                    infoEl.className = 'text-sm text-gray-700 font-medium';
                }
            }

            // Update per-category counts
            for (const category of Object.keys(FILE_TYPE_META)) {
                const countEl = document.querySelector(`.category-selected-${category}`);
                if (countEl) {
                    const count = categoryCounts[category] || 0;
                    countEl.textContent = `${count} selected`;
                    countEl.className = count > 0
                        ? `text-xs text-blue-600 category-selected-${category}`
                        : `text-xs text-gray-400 category-selected-${category}`;
                }
            }
        }

        // Format bytes in JS
        function formatBytesJS(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // Toggle category expand/collapse
        function toggleCategoryExpand(category) {
            const content = document.querySelector(`.category-content-${category}`);
            const chevron = document.querySelector(`.category-chevron-${category}`);
            if (content) {
                content.classList.toggle('hidden');
                if (chevron) {
                    chevron.classList.toggle('rotate-90');
                }
            }
        }

        // Select all files
        function selectAllFiles() {
            document.querySelectorAll('.context-file-checkbox').forEach(cb => cb.checked = true);
            updateSelectedFilesInfo();
        }

        // Select no files
        function selectNoneFiles() {
            document.querySelectorAll('.context-file-checkbox').forEach(cb => cb.checked = false);
            updateSelectedFilesInfo();
        }

        // Select a specific category
        function selectCategory(category) {
            // First uncheck all
            document.querySelectorAll('.context-file-checkbox').forEach(cb => cb.checked = false);
            // Then check only the specified category
            document.querySelectorAll(`.context-file-checkbox[data-category="${category}"]`).forEach(cb => cb.checked = true);
            // Expand that category
            const content = document.querySelector(`.category-content-${category}`);
            const chevron = document.querySelector(`.category-chevron-${category}`);
            if (content && content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                if (chevron) chevron.classList.add('rotate-90');
            }
            updateSelectedFilesInfo();
        }

        // Update context status displays
        function updateContextStatusDisplay() {
            const badge = document.getElementById('context-status-badge');
            const text = document.getElementById('context-status-text');
            const detailStatus = document.getElementById('context-detail-status');
            const indicator = document.getElementById('context-status-indicator');
            const container = document.getElementById('ai-knowledge-container');
            const icon = document.getElementById('ai-knowledge-icon');
            const btnText = document.getElementById('context-btn-text');

            if (contextLoaded) {
                const fileCountText = contextLoadedFiles.length > 0
                    ? `${contextLoadedFiles.length} files`
                    : '';
                if (badge) {
                    badge.textContent = fileCountText || 'Loaded';
                    badge.className = 'text-xs bg-white bg-opacity-30 px-2 py-0.5 rounded font-semibold';
                }
                if (text) text.textContent = `Loaded at ${contextLoadedAt}`;
                if (detailStatus) {
                    const fileList = contextLoadedFiles.slice(0, 3).join(', ');
                    const more = contextLoadedFiles.length > 3 ? ` +${contextLoadedFiles.length - 3} more` : '';
                    detailStatus.textContent = `${fileList}${more}`;
                    detailStatus.title = contextLoadedFiles.join('\n');
                }
                if (indicator) indicator.className = 'w-2 h-2 rounded-full bg-green-500';
                // Update container to loaded state (green, no pulse)
                if (container) container.className = 'ai-knowledge-loaded rounded-lg p-3 text-white';
                if (icon) icon.className = 'fas fa-check-circle';
                if (btnText) btnText.textContent = 'Update Context';
            } else {
                if (badge) {
                    badge.textContent = 'Not Loaded';
                    badge.className = 'text-xs bg-white bg-opacity-30 px-2 py-0.5 rounded font-semibold';
                }
                if (text) text.textContent = 'Load manuscript & reviews for better AI responses';
                if (detailStatus) detailStatus.textContent = 'No context loaded';
                if (indicator) indicator.className = 'w-2 h-2 rounded-full bg-gray-400';
                // Update container to not-loaded state (amber, pulsing)
                if (container) container.className = 'ai-knowledge-not-loaded rounded-lg p-3 text-white';
                if (icon) icon.className = 'fas fa-exclamation-triangle ai-knowledge-warning-icon';
                if (btnText) btnText.textContent = 'Load Context';
            }

            // Also update chat window context badge
            updateChatContextBadge();
        }

        // Build context-aware prompt for each file type
        function buildFileContextPrompt(fileName, filePath) {
            const lowerName = fileName.toLowerCase();
            const lowerPath = filePath.toLowerCase();

            // Base context about the project (generic)
            const projectContext = `This is a manuscript review project. We are responding to reviewer comments.`;

            let fileContext = '';
            let instructions = '';

            // Manuscript files
            if (lowerName.includes('manuscript') || lowerName.includes('paper') || lowerName.includes('submission')) {
                if (lowerName.includes('tracked')) {
                    fileContext = `This is the REVISED MANUSCRIPT with tracked changes showing our edits in response to reviewer comments.`;
                    instructions = `Understand the structure, main findings, and specifically note WHERE changes have been made.`;
                } else if (lowerName.includes('revised')) {
                    fileContext = `This is the CLEAN REVISED MANUSCRIPT (without track changes).`;
                    instructions = `Understand the overall argument, methodology, and conclusions. Note the paper's structure for referencing specific sections when drafting responses.`;
                } else {
                    fileContext = `This is the ORIGINAL SUBMISSION manuscript before revisions.`;
                    instructions = `Note the original text so you can understand what reviewers were commenting on and what has been changed.`;
                }
            }
            // Review files
            else if (lowerName.includes('review') || lowerName.includes('comment') || lowerPath.includes('reviewer')) {
                fileContext = `This contains REVIEWER COMMENTS that we need to respond to.`;
                instructions = `Understand each reviewer's concerns, their expertise area, and the tone of their comments. Identify key themes and recurring issues.`;
            }
            // Data files
            else if (lowerName.includes('data') || lowerName.includes('results')) {
                fileContext = `This is DATA or RESULTS supporting the manuscript.`;
                instructions = `Understand the key statistics and findings that can be referenced when responding to reviewer concerns.`;
            }
            // Expert discussions
            else if (lowerName.includes('expert') || lowerName.includes('discussion')) {
                fileContext = `This contains EXPERT DISCUSSIONS providing specialized knowledge for responding to technical reviewer concerns.`;
                instructions = `Use this information when drafting responses that require deep domain expertise.`;
            }
            // Supplementary files
            else if (lowerPath.includes('supplement') || lowerPath.includes('si_') || lowerPath.includes('figure') || lowerPath.includes('table')) {
                if (lowerName.endsWith('.xlsx') || lowerName.endsWith('.csv')) {
                    fileContext = `This is a SUPPLEMENTARY DATA TABLE containing detailed analytical results.`;
                    instructions = `Note column headers and data types. This may be referenced when reviewers ask for specific numbers or statistics.`;
                } else if (lowerName.endsWith('.pdf') || lowerName.endsWith('.png') || lowerName.endsWith('.jpg')) {
                    fileContext = `This is a SUPPLEMENTARY FIGURE showing visual data supporting the manuscript.`;
                    instructions = `Understand what this figure illustrates so you can reference it when responding to relevant reviewer comments.`;
                } else {
                    fileContext = `This is SUPPLEMENTARY MATERIAL supporting the main manuscript findings.`;
                    instructions = `Note the key information that could help address reviewer concerns.`;
                }
            }
            // JSON data files
            else if (lowerName.endsWith('.json')) {
                fileContext = `This is a JSON DATA FILE containing structured information for the review platform.`;
                instructions = `Understand the data structure and key fields for use in generating reviewer responses.`;
            }
            // Default for other files
            else {
                fileContext = `This is a supporting file for the manuscript review project.`;
                instructions = `Note any relevant information that could help address reviewer concerns.`;
            }

            return `${projectContext}

FILE: @${filePath}
CONTEXT: ${fileContext}

INSTRUCTIONS: ${instructions}

After reading this file, confirm you understood it by stating:
1. What type of content this file contains (1 sentence)
2. Key information relevant to responding to reviewer comments (1-2 bullet points)`;
        }

        // Load webapp schema into OpenCode's context
        async function loadWebappSchemaContext() {
            try {
                // Fetch the webapp schema
                const schemaResponse = await fetch(`${API_BASE}/webapp-schema`);
                if (!schemaResponse.ok) {
                    console.warn('Could not load webapp schema');
                    return;
                }

                const { schema } = await schemaResponse.json();

                // Build a context prompt for the webapp
                const webappContextPrompt = `You are now connected to the Manuscript Review Platform webapp. Here is the current system state:

PROJECT: ${schema.name}
PURPOSE: ${schema.purpose}

MANUSCRIPT CONTEXT:
- ${schema.project_context.manuscript}
- Key topics: ${schema.project_context.key_topics.join(', ')}
- Dating method: ${schema.project_context.dating_method}

KEY STATISTICS (loaded from manuscript):
${schema.project_context?.key_stats ? Object.entries(schema.project_context.key_stats).map(([k, v]) => `- ${k}: ${v}`).join('\n') : '- No statistics loaded yet'}

CURRENT REVIEW STATUS:
- Total comments: ${schema.current_state.total}
- Pending: ${schema.current_state.byStatus?.pending || 0}
- In progress: ${schema.current_state.byStatus?.in_progress || 0}
- Completed: ${schema.current_state.byStatus?.completed || 0}
- Major comments: ${schema.current_state.byType?.major || 0}
- High priority: ${schema.current_state.highPriority || 0}

THEMATIC GROUPS (use to find related comments):
${Object.entries(schema.thematic_groups).map(([k, v]) => `- ${k}: ${v.join(', ')}`).join('\n')}

INSTRUCTIONS:
${schema.instructions}

Confirm you understand the webapp context and are ready to help respond to reviewer comments.`;

                // Send to OpenCode
                const response = await fetch(`${API_BASE}/ask`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: webappContextPrompt,
                        comment_id: 'webapp-context',
                        model: aiSettings.model,
                        agent: aiSettings.agent,
                        variant: aiSettings.variant
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log(' Webapp schema loaded:', result.response?.substring(0, 100));
                }
            } catch (e) {
                console.warn('Error loading webapp schema:', e.message);
            }
        }

        // Load context - one file at a time with confirmation
        async function loadContext() {
            const progressEl = document.getElementById('context-loading-progress');
            const statusEl = document.getElementById('context-loading-status');
            const loadBtn = document.getElementById('load-context-main-btn');

            // Get selected file paths
            const selectedFiles = Array.from(document.querySelectorAll('.context-file-checkbox:checked'))
                .map(cb => cb.value);

            if (selectedFiles.length === 0) {
                showNotification('Please select at least one file to load', 'error');
                return;
            }

            const fileCount = selectedFiles.length;
            const loadedFiles = [];
            const failedFiles = [];

            // Show loading
            if (progressEl) progressEl.classList.remove('hidden');
            if (loadBtn) loadBtn.disabled = true;

            try {
                // Step 1: Reset session
                if (statusEl) statusEl.textContent = 'Resetting AI session...';
                await fetch(`${API_BASE}/session/reset`, { method: 'POST' });

                // Step 2: Load webapp schema first
                if (statusEl) statusEl.textContent = 'Loading webapp context...';
                await loadWebappSchemaContext();

                // Step 3: Load files one by one
                for (let i = 0; i < selectedFiles.length; i++) {
                    const filePath = selectedFiles[i];
                    const fileName = filePath.split('/').pop();

                    if (statusEl) {
                        statusEl.innerHTML = `
                            <div class="flex items-center gap-2">
                                <span>Loading file ${i + 1}/${fileCount}:</span>
                                <span class="font-medium">${fileName}</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-1.5 mt-2">
                                <div class="bg-blue-600 h-1.5 rounded-full transition-all" style="width: ${((i + 1) / fileCount * 100).toFixed(0)}%"></div>
                            </div>
                        `;
                    }

                    try {
                        // Build a context-aware prompt for this file
                        const contextPrompt = buildFileContextPrompt(fileName, filePath);

                        const response = await fetch(`${API_BASE}/ask`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                prompt: contextPrompt,
                                comment_id: `context-load-${i}`,
                                model: aiSettings.model,
                                agent: aiSettings.agent,
                                variant: aiSettings.variant,
                                file_paths: [filePath]
                            })
                        });

                        if (response.ok) {
                            const result = await response.json();
                            // Check if OpenCode actually read the file
                            const aiResponse = result.response || '';
                            if (aiResponse && aiResponse.length > 10) {
                                loadedFiles.push({ name: fileName, summary: aiResponse.substring(0, 100) });
                                console.log(` Loaded: ${fileName} - ${aiResponse.substring(0, 50)}...`);
                            } else {
                                failedFiles.push({ name: fileName, error: 'Empty response' });
                            }
                        } else {
                            failedFiles.push({ name: fileName, error: 'Request failed' });
                        }
                    } catch (e) {
                        failedFiles.push({ name: fileName, error: e.message });
                    }
                }

                // Update state
                if (loadedFiles.length > 0) {
                    contextLoaded = true;
                    contextLoadedAt = new Date().toLocaleTimeString();
                    contextLoadedFiles = loadedFiles.map(f => f.name);
                    updateContextStatusDisplay();

                    // Show summary
                    let message = `Loaded ${loadedFiles.length}/${fileCount} files successfully!`;
                    if (failedFiles.length > 0) {
                        message += ` (${failedFiles.length} failed)`;
                        showNotification(message, 'warning');
                    } else {
                        showNotification(message, 'success');
                    }

                    // Log loaded files to console
                    console.log('=== Context Files Loaded ===');
                    loadedFiles.forEach(f => console.log(` ${f.name}: ${f.summary}`));
                    if (failedFiles.length > 0) {
                        console.log('=== Failed Files ===');
                        failedFiles.forEach(f => console.log(` ${f.name}: ${f.error}`));
                    }

                    closeContextModal();
                } else {
                    throw new Error('No files could be loaded');
                }

            } catch (e) {
                console.error('Context loading error:', e);
                showNotification('Error loading context: ' + e.message, 'error');
            } finally {
                if (progressEl) progressEl.classList.add('hidden');
                if (loadBtn) loadBtn.disabled = false;
            }
        }

        // Clear context
        async function clearContext() {
            if (!confirm('This will clear the AI\'s memory. You\'ll need to reload context for best responses. Continue?')) {
                return;
            }

            try {
                await fetch(`${API_BASE}/session/reset`, { method: 'POST' });
                contextLoaded = false;
                contextLoadedAt = null;
                updateContextStatusDisplay();
                showNotification('Context cleared. AI memory reset.', 'success');
            } catch (e) {
                showNotification('Error clearing context', 'error');
            }
        }

        // Build context prompt based on selected files
        function buildContextPrompt(selectedFiles) {
            let prompt = `Please read and remember the following to understand the full context of this manuscript review:\n\n`;

            if (selectedFiles.includes('manuscript')) {
                prompt += `MANUSCRIPT:\nRead and understand the main manuscript file.\n\n`;
            }

            if (selectedFiles.includes('reviews')) {
                prompt += `REVIEWER COMMENTS:\nUnderstand all reviewer comments and their key concerns.\n\n`;
            }

            if (selectedFiles.includes('data')) {
                prompt += `DATA:\nReview the supporting data and statistics.\n\n`;
            }

            if (selectedFiles.includes('supplementary')) {
                prompt += `SUPPLEMENTARY DATA:\nAdditional figures, tables, and analyses supporting the main findings.\n\n`;
            }

            prompt += `Confirm you understand the manuscript and are ready to help respond to reviewer comments.`;

            return prompt;
        }

        // =====================================================
        // FLOATING CHAT FUNCTIONS
        // =====================================================

        // Toggle chat window open/closed
        function toggleChat() {
            const chatEl = document.getElementById('floating-chat');
            const fabEl = document.getElementById('chat-fab');
            chatIsOpen = !chatIsOpen;

            if (chatIsOpen) {
                chatEl.classList.remove('minimized');
                fabEl.style.display = 'none';
                // Small delay to let animation start before focusing
                setTimeout(() => {
                    document.getElementById('chat-input')?.focus();
                }, 100);
                updateChatContextBadge();
                updateChatModelIndicator();
                updateChatContextLink();
            } else {
                chatEl.classList.add('minimized');
                fabEl.style.display = 'flex';
                // Hide clear confirm if open
                cancelClearChat();
            }
        }

        // Update model indicator in chat header
        function updateChatModelIndicator() {
            const el = document.getElementById('chat-model-indicator');
            if (el && aiSettings.model) {
                // Keep the status dot and update text
                el.innerHTML = `<span class="w-1.5 h-1.5 rounded-full bg-green-300"></span>${aiSettings.model}`;
            }
        }

        // Update context link text based on context status
        function updateChatContextLink() {
            const linkText = document.getElementById('context-link-text');
            if (linkText) {
                linkText.textContent = contextLoaded ? 'Update Context' : 'Load Context';
            }
        }

        // Update context badge visibility
        function updateChatContextBadge() {
            const badge = document.getElementById('chat-context-badge');
            if (badge) {
                if (contextLoaded) {
                    badge.classList.remove('hidden');
                } else {
                    badge.classList.add('hidden');
                }
            }
        }

        // Handle keyboard input in chat
        function handleChatKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
            // Escape to close chat
            if (event.key === 'Escape') {
                toggleChat();
            }
        }

        // Global keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            // Don't trigger shortcuts when typing in input fields
            const activeElement = document.activeElement;
            const isTyping = activeElement.tagName === 'INPUT' ||
                            activeElement.tagName === 'TEXTAREA' ||
                            activeElement.isContentEditable;

            // Escape - close modals/chat
            if (event.key === 'Escape') {
                // Close chat if open
                if (chatIsOpen) {
                    toggleChat();
                    return;
                }
                // Close comment modal if open
                const commentModal = document.getElementById('comment-modal');
                if (commentModal && !commentModal.classList.contains('hidden')) {
                    closeModal();
                    return;
                }
                // Close agent modal if open
                const agentModal = document.getElementById('agent-modal');
                if (agentModal && !agentModal.classList.contains('hidden')) {
                    closeAgentModal();
                    return;
                }
                // Close context modal if open
                const contextModal = document.getElementById('context-modal');
                if (contextModal && !contextModal.classList.contains('hidden')) {
                    closeContextModal();
                    return;
                }
                // Close settings modal if open
                const settingsModal = document.getElementById('settings-modal');
                if (settingsModal && !settingsModal.classList.contains('hidden')) {
                    closeSettingsModal();
                    return;
                }
            }

            // Skip other shortcuts if typing
            if (isTyping) return;

            // Cmd/Ctrl + K - Open chat
            if ((event.metaKey || event.ctrlKey) && event.key === 'k') {
                event.preventDefault();
                if (!chatIsOpen) toggleChat();
                return;
            }

            // Cmd/Ctrl + S - Save progress
            if ((event.metaKey || event.ctrlKey) && event.key === 's') {
                event.preventDefault();
                saveProgress();
                return;
            }

            // Cmd/Ctrl + L - Load context
            if ((event.metaKey || event.ctrlKey) && event.key === 'l') {
                event.preventDefault();
                openContextModal();
                return;
            }

            // Number keys 1-6 for navigation (when not in input)
            if (event.key === '1') { setView('overview'); return; }
            if (event.key === '2') { setView('comments'); return; }
            if (event.key === '3') { setView('byreviewer'); return; }
            if (event.key === '4') { setView('agents'); return; }
            if (event.key === '5') { setView('experts'); return; }
            if (event.key === '6') { setView('export'); return; }

            // ? - Show keyboard shortcuts help
            if (event.key === '?') {
                showKeyboardShortcutsHelp();
                return;
            }
        });

        // Show keyboard shortcuts help modal
        function showKeyboardShortcutsHelp() {
            const shortcuts = [
                { key: '1-6', desc: 'Navigate between views' },
                { key: 'Esc', desc: 'Close modals/chat' },
                { key: '/Ctrl + K', desc: 'Open AI chat' },
                { key: '/Ctrl + S', desc: 'Save progress' },
                { key: '/Ctrl + L', desc: 'Load AI context' },
                { key: '?', desc: 'Show this help' }
            ];

            const html = `
                <div class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4" id="shortcuts-modal" onclick="if(event.target.id==='shortcuts-modal')this.remove()">
                    <div class="bg-white rounded-2xl max-w-md w-full shadow-2xl overflow-hidden">
                        <div class="px-6 py-4 bg-gradient-to-r from-gray-700 to-gray-900 text-white">
                            <h3 class="text-lg font-semibold flex items-center gap-2">
                                <i class="fas fa-keyboard"></i>
                                Keyboard Shortcuts
                            </h3>
                        </div>
                        <div class="p-6">
                            <div class="space-y-3">
                                ${shortcuts.map(s => `
                                    <div class="flex items-center justify-between">
                                        <span class="text-gray-600">${s.desc}</span>
                                        <kbd class="px-2 py-1 bg-gray-100 rounded text-gray-700 font-mono text-sm">${s.key}</kbd>
                                    </div>
                                `).join('')}
                            </div>
                            <div class="mt-6 pt-4 border-t border-gray-200 text-center">
                                <button onclick="this.closest('#shortcuts-modal').remove()" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm font-medium">
                                    Close
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', html);
        }

        // Auto-resize textarea as user types
        function autoResizeChatInput(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 100) + 'px';
        }

        // Send message to OpenCode
        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();

            if (!message || chatIsTyping) return;

            // Clear input
            input.value = '';
            input.style.height = 'auto';

            // Add user message to UI
            addChatMessage('user', message);

            // Add to history
            chatHistory.push({ role: 'user', content: message });

            // Show typing indicator
            showTypingIndicator();

            try {
                // Build prompt with comment context if available
                let fullPrompt = message;
                let commentId = 'chat';

                if (commentChatContext) {
                    commentId = commentChatContext.id;
                    fullPrompt = `[CONTEXT: You are discussing reviewer comment ${commentChatContext.id}]
[Reviewer: ${commentChatContext.reviewer}]
[Category: ${commentChatContext.category}]
[Status: ${commentChatContext.status}]
[Comment: "${commentChatContext.text}"]
${commentChatContext.currentResponse ? `[Current draft response: "${commentChatContext.currentResponse.substring(0, 300)}..."]` : '[No response drafted yet]'}
${commentChatContext.relatedIds.length > 0 ? `[Related comments: ${commentChatContext.relatedIds.join(', ')}]` : ''}

User question: ${message}`;
                }

                // Send to OpenCode API
                const response = await fetch(`${API_BASE}/ask`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: fullPrompt,
                        comment_id: commentId,
                        model: aiSettings.model,
                        agent: aiSettings.agent,
                        variant: aiSettings.variant
                    })
                });

                hideTypingIndicator();

                if (response.ok) {
                    const result = await response.json();
                    const assistantMessage = result.response || 'No response received';

                    // Add assistant message to UI
                    addChatMessage('assistant', assistantMessage);

                    // Add to history
                    chatHistory.push({ role: 'assistant', content: assistantMessage });
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    addChatMessage('assistant', `Error: ${errorData.error || 'Failed to get response'}`);
                }
            } catch (e) {
                hideTypingIndicator();
                addChatMessage('assistant', `Error: Could not connect to OpenCode. Make sure the server is running on port 3001.`);
            }
        }

        // Add message to chat UI
        function addChatMessage(role, content) {
            const messagesEl = document.getElementById('chat-messages');

            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}`;

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = 'message-bubble';

            // Render markdown for assistant messages
            if (role === 'assistant') {
                bubbleDiv.innerHTML = `<div class="text-sm prose prose-sm max-w-none">${marked.parse(content)}</div>`;
            } else {
                bubbleDiv.innerHTML = `<p class="text-sm">${escapeHtml(content)}</p>`;
            }

            messageDiv.appendChild(bubbleDiv);
            messagesEl.appendChild(messageDiv);

            // Scroll to bottom
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Show typing indicator
        function showTypingIndicator() {
            chatIsTyping = true;
            const messagesEl = document.getElementById('chat-messages');
            const sendBtn = document.getElementById('chat-send-btn');
            const statusEl = document.getElementById('chat-status');

            sendBtn.disabled = true;
            statusEl.textContent = 'OpenCode is thinking...';

            const typingDiv = document.createElement('div');
            typingDiv.id = 'chat-typing-indicator';
            typingDiv.className = 'chat-message assistant';
            typingDiv.innerHTML = `
                <div class="message-bubble">
                    <div class="chat-typing">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            `;
            messagesEl.appendChild(typingDiv);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        // Hide typing indicator
        function hideTypingIndicator() {
            chatIsTyping = false;
            const typingEl = document.getElementById('chat-typing-indicator');
            const sendBtn = document.getElementById('chat-send-btn');
            const statusEl = document.getElementById('chat-status');

            if (typingEl) typingEl.remove();
            sendBtn.disabled = false;
            statusEl.innerHTML = '<kbd class="px-1.5 py-0.5 bg-gray-100 rounded text-gray-500 font-mono text-xs">Enter</kbd> to send';
        }

        // Show clear confirmation toast
        function showClearConfirm() {
            const toast = document.getElementById('chat-clear-confirm');
            if (toast) toast.classList.add('show');
        }

        // Cancel clear and hide toast
        function cancelClearChat() {
            const toast = document.getElementById('chat-clear-confirm');
            if (toast) toast.classList.remove('show');
        }

        // Confirm clear chat history
        function confirmClearChat() {
            cancelClearChat();
            chatHistory = [];
            const messagesEl = document.getElementById('chat-messages');
            messagesEl.innerHTML = `
                <div class="chat-message assistant">
                    <div class="message-bubble">
                        <div class="flex items-center gap-2 text-sm text-gray-600">
                            <i class="fas fa-check-circle text-green-500"></i>
                            Chat cleared. How can I help you?
                        </div>
                    </div>
                </div>
            `;
        }

        // Legacy function for backwards compatibility
        function clearChatHistory() {
            showClearConfirm();
        }

        // =====================================================
        // END FLOATING CHAT FUNCTIONS
        // =====================================================


        // Get selected skills from checkboxes
        function getSelectedSkills() {
            const checkboxes = document.querySelectorAll('.skill-checkbox:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }

        // Auto-select skills based on comment content (called when opening modal)
        function autoSelectSkills(comment) {
            // Reset all to unchecked except manuscript-reviewer
            document.querySelectorAll('.skill-checkbox').forEach(cb => {
                cb.checked = cb.value === 'manuscript-reviewer';
            });

            const category = comment.category?.toLowerCase() || '';
            const text = comment.original_text?.toLowerCase() || '';

            // Auto-check based on content
            if (category.includes('authentication') || category.includes('validation') ||
                text.includes('damage') || text.includes('contamination') || text.includes('authentic')) {
                const el = document.getElementById('skill-dna');
                if (el) el.checked = true;
            }

            if (category.includes('interpretation') || category.includes('ecology') ||
                text.includes('methano') || text.includes('community') || text.includes('wetland')) {
                const el = document.getElementById('skill-ecology');
                if (el) el.checked = true;
            }

            if (text.includes('evolution') || text.includes('phylogen') ||
                text.includes('similar') || text.includes('divergen')) {
                const el = document.getElementById('skill-phylo');
                if (el) el.checked = true;
            }

            if (text.includes('virus') || text.includes('viral') || text.includes('phage')) {
                const el = document.getElementById('skill-virome');
                if (el) el.checked = true;
            }

            if (category.includes('methods') || text.includes('pipeline') ||
                text.includes('parameter') || text.includes('bioinformatic')) {
                const el = document.getElementById('skill-methods');
                if (el) el.checked = true;
            }
        }

        function buildPrompt(comment, reviewer) {
            // Get skills from UI checkboxes
            const selectedSkills = getSelectedSkills();
            const skillsText = selectedSkills.length > 0
                ? `Use the skills: ${selectedSkills.join(', ')}`
                : '';

            return `${skillsText}

TASK: Write a response to reviewer comment ${comment.id}

REVIEWER: ${reviewer.name}
COMMENT: "${comment.original_text}"

ACTIONS TAKEN:
${comment.actions_taken.map(a => '- ' + a).join('\n')}

Write a professional response in PAST TENSE. Be concise, use specific data from the skills, and thank the reviewer.`;
        }

        // Expert insights are now loaded dynamically from the database
        // This function fetches insights generated by OpenCode during setup
        async function getExpertInsightsForComment(commentId) {
            try {
                const response = await fetch(`${API_BASE}/db/expert/${commentId}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.insights) {
                        return data.insights;
                    }
                }
            } catch (e) {
                console.log('Could not load expert insights for', commentId);
            }

            // Default: no pre-generated insights
            return `
No expert insights pre-generated for this comment.
Use the "Generate Expert Analysis" button to create insights using OpenCode.
`;
        }

        // NOTE: API_BASE is defined earlier in the file (near context state)

        // =====================================================
        // DATABASE PERSISTENCE LAYER (defined early for init)
        // =====================================================

        // Database status indicator
        let dbStatus = { sqlite_available: false, storage: 'localStorage' };

        // Check database status
        async function checkDbStatus() {
            try {
                const response = await fetch(`${API_BASE}/db/status`);
                if (response.ok) {
                    dbStatus = await response.json();
                    console.log('Database status:', dbStatus);
                    updateDbStatusIndicator();
                    return dbStatus;
                }
            } catch (e) {
                console.log('Database API not available, using localStorage');
            }
            return { sqlite_available: false, storage: 'localStorage' };
        }

        // Update the UI to show storage type
        function updateDbStatusIndicator() {
            // Add a small indicator to the header showing storage type
            let indicator = document.getElementById('db-status-indicator');
            if (!indicator) {
                const header = document.querySelector('header .flex.items-center');
                if (header) {
                    indicator = document.createElement('span');
                    indicator.id = 'db-status-indicator';
                    indicator.className = 'text-xs px-2 py-1 rounded ml-2';
                    header.appendChild(indicator);
                }
            }
            if (indicator) {
                if (dbStatus.sqlite_available) {
                    indicator.className = 'text-xs px-2 py-1 rounded ml-2 bg-green-100 text-green-700';
                    indicator.innerHTML = '<i class="fas fa-database mr-1"></i>SQLite';
                    indicator.title = 'Data persisted in SQLite database';
                } else if (dbStatus.storage === 'json') {
                    indicator.className = 'text-xs px-2 py-1 rounded ml-2 bg-blue-100 text-blue-700';
                    indicator.innerHTML = '<i class="fas fa-file-code mr-1"></i>JSON';
                    indicator.title = 'Data persisted in JSON files';
                } else {
                    indicator.className = 'text-xs px-2 py-1 rounded ml-2 bg-yellow-100 text-yellow-700';
                    indicator.innerHTML = '<i class="fas fa-browser mr-1"></i>Browser';
                    indicator.title = 'Data stored in browser (may be lost - start server for persistence)';
                }
            }
        }

        // Save comments to database (paper-specific if paper ID is set)
        async function saveCommentsToDb() {
            try {
                // Use paper-specific endpoint if we have a paper ID
                const endpoint = currentPaperId
                    ? `${API_BASE}/papers/${currentPaperId}/comments`
                    : `${API_BASE}/db/comments`;

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(reviewData)
                });
                if (response.ok) {
                    const result = await response.json();
                    dbStatus.storage = result.storage;
                    updateDbStatusIndicator();
                    console.log(`Comments saved to ${result.storage}${result.paper_id ? ` for paper ${result.paper_id}` : ''}`);
                    return true;
                }
            } catch (e) {
                console.log('Database API not available, using localStorage');
            }
            // Fallback to localStorage
            localStorage.setItem('reviewData', JSON.stringify(reviewData));
            dbStatus.storage = 'localStorage';
            updateDbStatusIndicator();
            return false;
        }

        // Load comments from database (paper-specific if paper ID is set)
        async function loadCommentsFromDb() {
            try {
                // Use paper-specific endpoint if we have a paper ID
                const endpoint = currentPaperId
                    ? `${API_BASE}/papers/${currentPaperId}/comments`
                    : `${API_BASE}/db/comments`;

                const response = await fetch(endpoint);
                if (response.ok) {
                    const result = await response.json();
                    if (result.data && result.data.reviewers && result.data.reviewers.length > 0) {
                        dbStatus.storage = result.storage;
                        updateDbStatusIndicator();
                        console.log(`Comments loaded from ${result.storage}${result.paper_id ? ` for paper ${result.paper_id}` : ''}`);
                        return result.data;
                    }
                }
            } catch (e) {
                console.log('Database API not available');
            }
            return null;
        }

        // Auto-save on significant changes
        let autoSaveTimer = null;
        function scheduleAutoSave() {
            if (autoSaveTimer) clearTimeout(autoSaveTimer);
            // Show "Saving..." indicator
            const indicator = document.getElementById('autosave-indicator');
            if (indicator) {
                indicator.classList.remove('hidden');
                indicator.innerHTML = '<i class="fas fa-spinner fa-spin text-blue-500"></i><span>Saving...</span>';
            }

            autoSaveTimer = setTimeout(async () => {
                await saveCommentsToDb();
                console.log('Auto-saved to database');

                // Show "Saved" indicator
                if (indicator) {
                    indicator.innerHTML = '<i class="fas fa-check-circle text-green-500"></i><span>Saved</span>';
                    // Hide after 3 seconds
                    setTimeout(() => {
                        indicator.classList.add('hidden');
                    }, 3000);
                }
            }, 2000); // Auto-save 2 seconds after last change (faster feedback)
        }

        // =====================================================
        // END DATABASE PERSISTENCE LAYER
        // =====================================================

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await checkDbStatus();  // Check database status first
            await loadPapers();     // Load available papers
            await loadTrashedPapers(); // Load trashed papers for trash badge
            await loadAISettings();
            checkApiConnection();

            // Check for any active processing jobs to recover
            await recoverProgressOnLoad();

            // Check for last opened paper in localStorage
            const lastPaperId = localStorage.getItem('rebuttr_last_paper');

            if (lastPaperId && papers.find(p => p.id === lastPaperId)) {
                // Resume last paper
                await switchPaper(lastPaperId);
            } else {
                // Show Project Manager
                openPaperManager();
                updateTrashBadge();

                // If no papers exist, show the add paper form directly
                if (papers.length === 0) {
                    showAddPaperForm();
                }
            }
        });

        // Update context status based on loaded reviewData
        function updateContextFromLoadedData() {
            const hasData = reviewData?.manuscript?.title || reviewData?.reviewers?.length > 0;
            if (hasData && !contextLoaded) {
                contextLoaded = true;
                contextLoadedAt = 'From manuscript data';

                // Build a list of what we have loaded
                const loadedItems = [];
                if (reviewData?.manuscript?.title) {
                    loadedItems.push('Manuscript');
                }
                if (reviewData?.reviewers?.length > 0) {
                    loadedItems.push(`${reviewData.reviewers.length} Reviewers`);
                }
                const commentCount = reviewData?.reviewers?.reduce((sum, r) => sum + (r.comments?.length || 0), 0) || 0;
                if (commentCount > 0) {
                    loadedItems.push(`${commentCount} Comments`);
                }
                if (reviewData?.manuscript_data?.categories?.length > 0) {
                    loadedItems.push('Categories');
                }

                contextLoadedFiles = loadedItems;
                updateContextStatusDisplay();
                console.log('Context marked as loaded from reviewData:', loadedItems);
            }
        }

        // Load review data - embedded directly to avoid CORS issues with local files
        const DATA_VERSION = '2026-01-15-v2-60comments'; // Version for cache invalidation

        async function loadReviewData() {
            // Check if cached data is from older version - if so, clear it
            const cachedVersion = localStorage.getItem('reviewDataVersion');
            if (cachedVersion !== DATA_VERSION) {
                localStorage.removeItem('reviewData');
                localStorage.setItem('reviewDataVersion', DATA_VERSION);
            }

            // PRIORITY 1: Try to load from database (SQLite or JSON files)
            const dbData = await loadCommentsFromDb();
            if (dbData && dbData.reviewers && dbData.reviewers.length > 0) {
                reviewData = dbData;
                updateSidebar();
                console.log('Loaded review data from database');
                return;
            }

            // PRIORITY 2: Try to load from localStorage (browser storage)
            const savedData = localStorage.getItem('reviewData');
            if (savedData) {
                reviewData = JSON.parse(savedData);
                updateSidebar();
                // Try to sync to database for persistence
                saveCommentsToDb();
                return;
            }

            // PRIORITY 3: Try to fetch from file (works when served via HTTP)
            try {
                const response = await fetch('data/reviewer_comments.json');
                if (response.ok) {
                    reviewData = await response.json();
                    updateSidebar();
                    // Try to sync to database for persistence
                    saveCommentsToDb();
                    return;
                }
            } catch (error) {
                console.log('Fetch failed, using embedded data');
            }

            // PRIORITY 4: Fall back to embedded data for file:// protocol
            reviewData = getEmbeddedReviewData();
            updateSidebar();
            // Try to sync to database for persistence
            saveCommentsToDb();
        }

        // Embedded review data (auto-generated - works with file:// protocol)
        function getEmbeddedReviewData() {
            // Empty placeholder - will be populated dynamically after setup
            return {
                "manuscript": {
                    "title": "Your Manuscript Title",
                    "authors": "Author(s)",
                    "submission_date": "",
                    "review_date": ""
                },
                "reviewers": [],
                "note": "Run setup.js to parse your review file and populate this data"
            };
        }

        function createEmptyData() {
            return {
                manuscript: { title: "New Manuscript", authors: "", submission_date: "", review_date: "" },
                reviewers: []
            };
        }

        // Update sidebar
        function updateSidebar() {
            if (!reviewData) return;

            // Build comment relationships when data is available
            buildCommentRelationships();

            document.getElementById('manuscript-title').textContent = reviewData.manuscript.title;

            const allComments = getAllComments();
            const completed = allComments.filter(c => c.status === 'completed').length;
            const inProgress = allComments.filter(c => c.status === 'in_progress').length;
            const pending = allComments.filter(c => c.status === 'pending').length;
            const total = allComments.length;

            document.getElementById('completed-count').textContent = completed;
            document.getElementById('inprogress-count').textContent = inProgress;
            document.getElementById('pending-count').textContent = pending;

            const progress = total > 0 ? Math.round((completed / total) * 100) : 0;
            document.getElementById('progress-bar').style.width = `${progress}%`;
            document.getElementById('progress-text').textContent = `${progress}% Complete (${completed}/${total})`;
        }

        function getAllComments() {
            if (!reviewData || !reviewData.reviewers) return [];
            return reviewData.reviewers.flatMap(r => r.comments.map(c => ({...c, reviewer: r.name, reviewerId: r.id})));
        }

        // =====================================================
        // SKELETON LOADERS AND LOADING STATES
        // =====================================================

        // Show skeleton loading state for overview
        function showOverviewSkeleton() {
            const content = document.getElementById('content-area');
            content.innerHTML = `
                <div class="mb-6 skeleton-card">
                    <div class="skeleton skeleton-text" style="height: 24px; width: 200px; margin-bottom: 16px;"></div>
                    <div class="grid grid-cols-6 gap-3">
                        ${Array(6).fill('<div class="skeleton" style="height: 60px; border-radius: 8px;"></div>').join('')}
                    </div>
                </div>
                <div class="grid grid-cols-4 gap-4 mb-6">
                    ${Array(4).fill(`
                        <div class="skeleton-card flex items-center gap-3">
                            <div class="skeleton skeleton-circle" style="width: 40px; height: 40px;"></div>
                            <div class="flex-1">
                                <div class="skeleton skeleton-text" style="width: 50px; height: 24px;"></div>
                                <div class="skeleton skeleton-text" style="width: 80px; height: 12px;"></div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <div class="skeleton-card mb-6">
                    <div class="skeleton skeleton-text" style="height: 20px; width: 180px; margin-bottom: 16px;"></div>
                    <div class="grid grid-cols-3 gap-4">
                        ${Array(3).fill(`
                            <div class="skeleton" style="height: 100px; border-radius: 8px;"></div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Show skeleton loading state for comments list
        function showCommentsSkeleton() {
            const content = document.getElementById('content-area');
            content.innerHTML = `
                <div class="space-y-4">
                    ${Array(5).fill(`
                        <div class="skeleton-card">
                            <div class="flex items-start gap-4">
                                <div class="skeleton skeleton-circle" style="width: 36px; height: 36px;"></div>
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-2">
                                        <div class="skeleton skeleton-badge"></div>
                                        <div class="skeleton skeleton-badge" style="width: 80px;"></div>
                                        <div class="skeleton skeleton-badge" style="width: 50px;"></div>
                                    </div>
                                    <div class="skeleton skeleton-text" style="width: 100%;"></div>
                                    <div class="skeleton skeleton-text" style="width: 90%;"></div>
                                    <div class="skeleton skeleton-text" style="width: 70%;"></div>
                                    <div class="flex gap-2 mt-3">
                                        <div class="skeleton" style="height: 32px; width: 100px; border-radius: 6px;"></div>
                                        <div class="skeleton" style="height: 32px; width: 80px; border-radius: 6px;"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Show skeleton for sidebar progress
        function showSidebarSkeleton() {
            const progressContainer = document.querySelector('.sidebar .p-4.border-b');
            if (progressContainer) {
                progressContainer.innerHTML = `
                    <div class="skeleton skeleton-text" style="height: 16px; width: 120px; margin-bottom: 12px;"></div>
                    <div class="space-y-3">
                        <div class="flex items-center justify-between">
                            <div class="skeleton skeleton-text" style="width: 60px; height: 14px;"></div>
                            <div class="skeleton skeleton-text" style="width: 20px; height: 14px;"></div>
                        </div>
                        <div class="flex items-center justify-between">
                            <div class="skeleton skeleton-text" style="width: 70px; height: 14px;"></div>
                            <div class="skeleton skeleton-text" style="width: 20px; height: 14px;"></div>
                        </div>
                        <div class="skeleton" style="height: 8px; width: 100%; border-radius: 4px; margin-top: 8px;"></div>
                    </div>
                `;
            }
        }

        // Show loading overlay on a specific element
        function showLoadingOverlay(elementId, message = 'Loading...') {
            const element = document.getElementById(elementId);
            if (!element) return;
            element.style.position = 'relative';
            const overlay = document.createElement('div');
            overlay.id = `${elementId}-loading-overlay`;
            overlay.className = 'loading-overlay';
            overlay.innerHTML = `
                <div class="loading-spinner">
                    <i class="fas fa-spinner fa-spin"></i>
                    <span>${message}</span>
                </div>
            `;
            element.appendChild(overlay);
        }

        // Hide loading overlay
        function hideLoadingOverlay(elementId) {
            const overlay = document.getElementById(`${elementId}-loading-overlay`);
            if (overlay) overlay.remove();
        }

        // =====================================================
        // VIEW MANAGEMENT
        // =====================================================

        // View management
        function setView(view) {
            currentView = view;
            currentFilter = null;
            document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('bg-blue-50', 'text-blue-600'));

            const views = {
                'overview': { title: 'Overview', subtitle: 'Manuscript review summary and statistics', render: renderOverview },
                'taskqueue': { title: 'Task Queue', subtitle: 'AI-optimized task order - drag to reorder', render: renderTaskQueue },
                'comments': { title: 'All Comments', subtitle: 'Browse and manage all reviewer comments', render: renderAllComments },
                'byreviewer': { title: 'By Reviewer', subtitle: 'View comments organized by reviewer', render: renderByReviewer },
                'agents': { title: 'AI Agents', subtitle: 'Specialized agents for response assistance', render: renderAgents },
                'experts': { title: 'Expert Insights', subtitle: 'Multi-expert analysis of supplementary data', render: renderExperts },
                'export': { title: 'Export', subtitle: 'Export responses and generate documents', render: renderExport }
            };

            const viewConfig = views[view] || views['overview'];
            document.getElementById('view-title').textContent = viewConfig.title;
            document.getElementById('view-subtitle').textContent = viewConfig.subtitle;
            viewConfig.render();
        }

        // Render Overview - Comprehensive dashboard with key data and quick navigation
        function renderOverview() {
            const allComments = getAllComments();
            const byPriority = { high: 0, medium: 0, low: 0 };
            const byType = { major: 0, minor: 0 };
            const byCategory = {};
            const needsAnalysis = allComments.filter(c => c.requires_new_analysis).length;
            const completed = allComments.filter(c => c.status === 'completed').length;

            allComments.forEach(c => {
                byPriority[c.priority] = (byPriority[c.priority] || 0) + 1;
                byType[c.type] = (byType[c.type] || 0) + 1;
                byCategory[c.category] = (byCategory[c.category] || 0) + 1;
            });

            // Get expert discussions data
            const dataStats = expertDiscussions?.data_sources || {};

            // Check if we have actual manuscript data loaded
            const hasManuscript = reviewData?.manuscript?.title || reviewData?.reviewers?.length > 0;
            const manuscriptTitle = reviewData?.manuscript?.title || 'Untitled Manuscript';
            const manuscriptField = reviewData?.manuscript?.field || '';
            const categories = reviewData?.manuscript_data?.categories || [];

            const html = `
                <!-- Manuscript Info Banner -->
                ${hasManuscript ? `
                <div class="mb-6 bg-gradient-to-r from-emerald-600 to-teal-600 rounded-xl p-5 text-white shadow-lg">
                    <div class="flex items-start justify-between">
                        <div class="flex-1">
                            <h3 class="text-lg font-bold mb-1 flex items-center gap-2">
                                <i class="fas fa-file-alt"></i> ${manuscriptTitle}
                            </h3>
                            ${manuscriptField ? `<p class="text-sm opacity-80 mb-3">${manuscriptField}</p>` : ''}
                        </div>
                        <div class="text-right">
                            <div class="text-2xl font-bold">${reviewData?.reviewers?.length || 0}</div>
                            <div class="text-xs opacity-80">Reviewers</div>
                        </div>
                    </div>
                    ${categories.length > 0 ? `
                    <div class="mt-3 pt-3 border-t border-white border-opacity-20">
                        <div class="text-xs opacity-80 mb-2">Review Categories:</div>
                        <div class="flex flex-wrap gap-1">
                            ${categories.slice(0, 6).map(cat => `<span class="bg-white bg-opacity-20 px-2 py-0.5 rounded text-xs">${cat}</span>`).join('')}
                            ${categories.length > 6 ? `<span class="bg-white bg-opacity-20 px-2 py-0.5 rounded text-xs">+${categories.length - 6} more</span>` : ''}
                        </div>
                    </div>
                    ` : ''}
                </div>
                ` : `
                <div class="mb-6 bg-gradient-to-r from-gray-500 to-gray-600 rounded-xl p-5 text-white shadow-lg">
                    <h3 class="text-lg font-bold mb-3 flex items-center gap-2">
                        <i class="fas fa-info-circle"></i> No Paper Selected
                    </h3>
                    <p class="text-sm opacity-90">Select a paper from the dropdown above or use the CLI to add papers.</p>
                </div>
                `}

                <!-- Quick Stats Row -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                    <div class="bg-white rounded-xl p-4 shadow-sm border border-gray-100 cursor-pointer hover:shadow-md" onclick="setView('comments')">
                        <div class="flex items-center gap-3">
                            <div class="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center">
                                <i class="fas fa-comments text-blue-600"></i>
                            </div>
                            <div>
                                <p class="text-2xl font-bold text-gray-800">${allComments.length}</p>
                                <p class="text-xs text-gray-500">Total Comments</p>
                            </div>
                        </div>
                    </div>
                    <div class="bg-white rounded-xl p-4 shadow-sm border border-gray-100 cursor-pointer hover:shadow-md" onclick="filterByType('major'); setView('comments')">
                        <div class="flex items-center gap-3">
                            <div class="w-10 h-10 bg-red-100 rounded-full flex items-center justify-center">
                                <i class="fas fa-exclamation-circle text-red-600"></i>
                            </div>
                            <div>
                                <p class="text-2xl font-bold text-red-600">${byType.major || 0}</p>
                                <p class="text-xs text-gray-500">Major Issues</p>
                            </div>
                        </div>
                    </div>
                    <div class="bg-white rounded-xl p-4 shadow-sm border border-gray-100 cursor-pointer hover:shadow-md" onclick="filterByPriority('high'); setView('comments')">
                        <div class="flex items-center gap-3">
                            <div class="w-10 h-10 bg-orange-100 rounded-full flex items-center justify-center">
                                <i class="fas fa-fire text-orange-600"></i>
                            </div>
                            <div>
                                <p class="text-2xl font-bold text-orange-600">${byPriority.high || 0}</p>
                                <p class="text-xs text-gray-500">High Priority</p>
                            </div>
                        </div>
                    </div>
                    <div class="bg-white rounded-xl p-4 shadow-sm border border-gray-100">
                        <div class="flex items-center gap-3">
                            <div class="w-10 h-10 bg-green-100 rounded-full flex items-center justify-center">
                                <i class="fas fa-check-circle text-green-600"></i>
                            </div>
                            <div>
                                <p class="text-2xl font-bold text-green-600">${completed}</p>
                                <p class="text-xs text-gray-500">Completed</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Reviewers Quick Access -->
                <div class="bg-white rounded-xl p-5 shadow-sm border border-gray-100 mb-6">
                    <h3 class="font-semibold text-gray-800 mb-4 flex items-center gap-2">
                        <i class="fas fa-users text-purple-500"></i> Reviewers - Click to Jump
                    </h3>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        ${reviewData.reviewers.map(r => {
                            const majorCount = r.comments.filter(c => c.type === 'major').length;
                            const highCount = r.comments.filter(c => c.priority === 'high').length;
                            const completedCount = r.comments.filter(c => c.status === 'completed').length;
                            return `
                                <div class="p-4 rounded-lg border-2 border-gray-200 hover:border-blue-400 cursor-pointer transition-colors"
                                     onclick="jumpToReviewer('${r.id}')">
                                    <div class="flex items-center justify-between mb-2">
                                        <span class="font-bold text-gray-800">${r.name}</span>
                                        <span class="text-sm text-gray-500">${r.comments.length} comments</span>
                                    </div>
                                    <p class="text-xs text-gray-500 mb-3">${r.expertise}</p>
                                    <div class="flex gap-2 flex-wrap">
                                        <span class="px-2 py-1 text-xs bg-red-100 text-red-700 rounded">${majorCount} major</span>
                                        <span class="px-2 py-1 text-xs bg-orange-100 text-orange-700 rounded">${highCount} high</span>
                                        <span class="px-2 py-1 text-xs bg-green-100 text-green-700 rounded">${completedCount} done</span>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>

                <!-- All Comments Quick Index - Separated by Major/Minor -->
                <div class="bg-white rounded-xl p-5 shadow-sm border border-gray-100 mb-6">
                    <h3 class="font-semibold text-gray-800 mb-4 flex items-center gap-2">
                        <i class="fas fa-list text-blue-500"></i> All Comments - Click Any to Open
                    </h3>

                    <!-- Major Comments -->
                    <div class="mb-4">
                        <div class="flex items-center gap-2 mb-2">
                            <span class="w-3 h-3 bg-red-500 rounded"></span>
                            <span class="text-sm font-bold text-red-700">Major (${byType.major || 0})</span>
                            <span class="text-xs text-gray-500">- Substantive issues</span>
                        </div>
                        <div class="flex flex-wrap gap-1.5">
                            ${allComments.filter(c => c.type === 'major').map(c => {
                                const statusDot = c.status === 'completed' ? ' ' : c.status === 'in_progress' ? ' ' : '';
                                const priorityBorder = c.priority === 'high' ? 'border-red-500 border-2' : 'border-red-300';
                                return `
                                    <button onclick="openCommentModal('${c.reviewerId}', '${c.id}')"
                                            class="px-2.5 py-1 text-sm font-medium rounded bg-red-100 text-red-800 hover:bg-red-200 border ${priorityBorder} transition-colors">
                                        ${c.id}${statusDot}
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <!-- Minor Comments -->
                    <div>
                        <div class="flex items-center gap-2 mb-2">
                            <span class="w-3 h-3 bg-blue-500 rounded"></span>
                            <span class="text-sm font-bold text-blue-700">Minor (${byType.minor || 0})</span>
                            <span class="text-xs text-gray-500">- Quick fixes</span>
                        </div>
                        <div class="flex flex-wrap gap-1.5">
                            ${allComments.filter(c => c.type === 'minor').map(c => {
                                const statusDot = c.status === 'completed' ? ' ' : c.status === 'in_progress' ? ' ' : '';
                                return `
                                    <button onclick="openCommentModal('${c.reviewerId}', '${c.id}')"
                                            class="px-2.5 py-1 text-sm font-medium rounded bg-blue-50 text-blue-700 hover:bg-blue-100 border border-blue-200 transition-colors">
                                        ${c.id}${statusDot}
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    </div>
                </div>

                <!-- Priority Distribution & Categories -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-white rounded-xl p-5 shadow-sm border border-gray-100">
                        <h3 class="font-semibold text-gray-800 mb-4">Priority Distribution</h3>
                        <div class="space-y-3">
                            <div class="cursor-pointer hover:bg-red-50 p-2 rounded" onclick="filterByPriority('high'); setView('comments')">
                                <div class="flex justify-between text-sm mb-1">
                                    <span class="text-gray-600 flex items-center gap-2"><span class="w-3 h-3 bg-red-500 rounded-full"></span>High</span>
                                    <span class="font-bold text-red-600">${byPriority.high || 0}</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-2">
                                    <div class="bg-red-500 h-2 rounded-full" style="width: ${(byPriority.high / allComments.length) * 100}%"></div>
                                </div>
                            </div>
                            <div class="cursor-pointer hover:bg-yellow-50 p-2 rounded" onclick="filterByPriority('medium'); setView('comments')">
                                <div class="flex justify-between text-sm mb-1">
                                    <span class="text-gray-600 flex items-center gap-2"><span class="w-3 h-3 bg-yellow-500 rounded-full"></span>Medium</span>
                                    <span class="font-bold text-yellow-600">${byPriority.medium || 0}</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-2">
                                    <div class="bg-yellow-500 h-2 rounded-full" style="width: ${(byPriority.medium / allComments.length) * 100}%"></div>
                                </div>
                            </div>
                            <div class="cursor-pointer hover:bg-green-50 p-2 rounded" onclick="filterByPriority('low'); setView('comments')">
                                <div class="flex justify-between text-sm mb-1">
                                    <span class="text-gray-600 flex items-center gap-2"><span class="w-3 h-3 bg-green-500 rounded-full"></span>Low</span>
                                    <span class="font-bold text-green-600">${byPriority.low || 0}</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-2">
                                    <div class="bg-green-500 h-2 rounded-full" style="width: ${(byPriority.low / allComments.length) * 100}%"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="bg-white rounded-xl p-5 shadow-sm border border-gray-100">
                        <h3 class="font-semibold text-gray-800 mb-4">Categories - Click to Filter</h3>
                        <div class="flex flex-wrap gap-2">
                            ${Object.entries(byCategory).sort((a,b) => b[1] - a[1]).map(([cat, count]) => `
                                <button onclick="filterByCategory('${cat}'); setView('comments')"
                                        class="px-3 py-2 bg-gray-100 rounded-lg text-sm hover:bg-blue-100 transition-colors">
                                    ${cat} <span class="font-bold">(${count})</span>
                                </button>
                            `).join('')}
                        </div>
                    </div>
                </div>

                <!-- High Priority Items - Using same card format as All Comments -->
                <div class="bg-white rounded-xl p-5 shadow-sm border border-red-200 border-l-4 border-l-red-500">
                    <h3 class="font-semibold text-gray-800 mb-4 flex items-center gap-2">
                        <i class="fas fa-fire text-red-500"></i> High Priority Items Requiring Attention
                        <span class="text-sm font-normal text-gray-500">(${allComments.filter(c => c.priority === 'high' && c.status !== 'completed').length} remaining)</span>
                    </h3>
                    <div class="space-y-3">
                        ${allComments.filter(c => c.priority === 'high' && c.status !== 'completed').slice(0, 8).map(c => renderCommentCard(c)).join('') || '<p class="text-green-600 text-sm font-medium">All high priority items completed!</p>'}
                    </div>
                </div>
            `;
            document.getElementById('content-area').innerHTML = html;
        }

        // Jump to specific reviewer
        function jumpToReviewer(reviewerId) {
            expandedReviewers[reviewerId] = true;
            setView('byreviewer');
            setTimeout(() => {
                const el = document.querySelector(`[data-reviewer="${reviewerId}"]`);
                if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
        }

        // Render All Comments - Shows both major and minor with clear sections
        function renderAllComments() {
            let allComments = getAllComments();
            let comments = [...allComments];

            if (currentFilter) {
                if (currentFilter.type === 'priority') {
                    comments = comments.filter(c => c.priority === currentFilter.value);
                } else if (currentFilter.type === 'type') {
                    comments = comments.filter(c => c.type === currentFilter.value);
                } else if (currentFilter.type === 'category') {
                    comments = comments.filter(c => c.category === currentFilter.value);
                } else if (currentFilter.type === 'analysis') {
                    comments = comments.filter(c => c.requires_new_analysis === currentFilter.value);
                }
            }

            // Separate major and minor
            const majorComments = comments.filter(c => c.type === 'major');
            const minorComments = comments.filter(c => c.type === 'minor');

            // Count totals
            const totalMajor = allComments.filter(c => c.type === 'major').length;
            const totalMinor = allComments.filter(c => c.type === 'minor').length;

            const html = `
                <!-- Summary Banner -->
                <div class="mb-6 bg-white rounded-xl p-4 shadow-sm border flex items-center justify-between flex-wrap gap-4">
                    <div class="flex items-center gap-4">
                        <div class="flex items-center gap-2">
                            <span class="w-4 h-4 bg-red-500 rounded"></span>
                            <span class="font-bold text-red-700">${totalMajor} Major</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="w-4 h-4 bg-blue-500 rounded"></span>
                            <span class="font-bold text-blue-700">${totalMinor} Minor</span>
                        </div>
                        <span class="text-gray-400">|</span>
                        <span class="text-gray-600">${allComments.length} Total Comments</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <button onclick="filterByType('major'); renderAllComments()"
                                class="px-3 py-1 text-sm rounded ${currentFilter?.value === 'major' ? 'bg-red-600 text-white' : 'bg-red-100 text-red-700 hover:bg-red-200'}">
                            Show Major Only
                        </button>
                        <button onclick="filterByType('minor'); renderAllComments()"
                                class="px-3 py-1 text-sm rounded ${currentFilter?.value === 'minor' ? 'bg-blue-600 text-white' : 'bg-blue-100 text-blue-700 hover:bg-blue-200'}">
                            Show Minor Only
                        </button>
                        <button onclick="clearFilter(); renderAllComments()"
                                class="px-3 py-1 text-sm rounded ${!currentFilter ? 'bg-gray-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}">
                            Show All
                        </button>
                    </div>
                </div>

                <!-- Filter & Sort Controls -->
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center gap-4">
                        <select onchange="sortComments(this.value)" class="px-3 py-2 border border-gray-300 rounded-lg text-sm">
                            <option value="id">Sort by ID</option>
                            <option value="priority">Sort by Priority</option>
                            <option value="status">Sort by Status</option>
                            <option value="reviewer">Sort by Reviewer</option>
                            <option value="type">Sort by Type</option>
                        </select>
                        ${currentFilter ? `
                            <span class="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm flex items-center gap-2">
                                Filter: ${currentFilter.type} = ${currentFilter.value}
                                <button onclick="clearFilter(); renderAllComments()" class="text-blue-600 hover:text-blue-800 font-bold">&times;</button>
                            </span>
                        ` : ''}
                    </div>
                    <span class="text-sm text-gray-500">Showing ${comments.length} of ${allComments.length}</span>
                </div>

                <!-- Comments grouped by type if showing all -->
                ${!currentFilter || currentFilter.type !== 'type' ? `
                    <!-- Major Comments Section -->
                    ${majorComments.length > 0 ? `
                        <div class="mb-6">
                            <h3 class="text-lg font-bold text-red-700 mb-3 flex items-center gap-2 sticky top-0 bg-gray-100 py-2 z-10">
                                <span class="w-4 h-4 bg-red-500 rounded"></span>
                                Major Comments (${majorComments.length})
                                <span class="text-xs font-normal text-gray-500">- Require substantive response</span>
                            </h3>
                            <div class="space-y-3">
                                ${majorComments.map(c => renderCommentCard(c)).join('')}
                            </div>
                        </div>
                    ` : ''}

                    <!-- Minor Comments Section -->
                    ${minorComments.length > 0 ? `
                        <div class="mb-6">
                            <h3 class="text-lg font-bold text-blue-700 mb-3 flex items-center gap-2 sticky top-0 bg-gray-100 py-2 z-10">
                                <span class="w-4 h-4 bg-blue-500 rounded"></span>
                                Minor Comments (${minorComments.length})
                                <span class="text-xs font-normal text-gray-500">- Quick fixes and clarifications</span>
                            </h3>
                            <div class="space-y-3">
                                ${minorComments.map(c => renderCommentCard(c)).join('')}
                            </div>
                        </div>
                    ` : ''}
                ` : `
                    <!-- Filtered view - single list -->
                    <div class="space-y-3">
                        ${comments.map(c => renderCommentCard(c)).join('')}
                    </div>
                `}
            `;
            document.getElementById('content-area').innerHTML = html;
        }

        // Icon and color maps for unified display
        const iconMap = {
            'dna': 'fa-dna', 'shield-virus': 'fa-shield-virus', 'leaf': 'fa-leaf',
            'cogs': 'fa-cogs', 'tree': 'fa-tree', 'mountain': 'fa-mountain',
            'code-branch': 'fa-code-branch', 'pen': 'fa-pen', 'database': 'fa-database',
            'code': 'fa-code', 'globe': 'fa-globe'
        };
        const colorMap = {
            'blue': { bg: 'from-blue-500 to-blue-600', light: 'bg-blue-50 border-blue-200 text-blue-800' },
            'red': { bg: 'from-red-500 to-red-600', light: 'bg-red-50 border-red-200 text-red-800' },
            'green': { bg: 'from-green-500 to-green-600', light: 'bg-green-50 border-green-200 text-green-800' },
            'purple': { bg: 'from-purple-500 to-purple-600', light: 'bg-purple-50 border-purple-200 text-purple-800' },
            'orange': { bg: 'from-orange-500 to-orange-600', light: 'bg-orange-50 border-orange-200 text-orange-800' },
            'cyan': { bg: 'from-cyan-500 to-cyan-600', light: 'bg-cyan-50 border-cyan-200 text-cyan-800' },
            'brown': { bg: 'from-amber-600 to-amber-700', light: 'bg-amber-50 border-amber-200 text-amber-800' },
            'gray': { bg: 'from-gray-500 to-gray-600', light: 'bg-gray-50 border-gray-200 text-gray-800' }
        };

        function renderCommentCard(comment) {
            const priorityClass = `priority-${comment.priority}`;

            // Get expert data from embedded discussions
            const expertData = expertDiscussions?.expert_discussions?.[comment.id];
            const experts = expertData?.experts || comment.experts || [];
            const recommendedResponse = expertData?.recommended_response || comment.recommended_response || '';
            const adviceToAuthor = expertData?.advice_to_author || comment.advice_to_author || '';
            const fullContext = expertData?.full_context || comment.full_context || '';

            // Build compact expert summary (just names and key points)
            let expertSummary = '';
            if (experts.length > 0) {
                expertSummary = `
                    <div class="flex items-center gap-2 flex-wrap mt-2">
                        <span class="text-xs text-purple-600 font-medium"><i class="fas fa-users mr-1"></i>${experts.length} expert${experts.length > 1 ? 's' : ''}:</span>
                        ${experts.map(e => {
                            const icon = iconMap[e.icon] || 'fa-user';
                            return `<span class="text-xs text-gray-600"><i class="fas ${icon} text-gray-400"></i> ${e.name.split(' ')[0]}</span>`;
                        }).join('')}
                    </div>
                `;
            }

            // Build detailed expert panels HTML (in collapsible)
            let expertsDetailHtml = '';
            if (experts.length > 0) {
                expertsDetailHtml = `
                    <div class="grid grid-cols-1 gap-2 mt-3">
                        ${experts.map(expert => {
                            const colors = colorMap[expert.color] || colorMap.blue;
                            const icon = iconMap[expert.icon] || 'fa-user';
                            return `
                                <div class="bg-white rounded-lg shadow-sm border overflow-hidden">
                                    <div class="bg-gradient-to-r ${colors.bg} p-2 text-white">
                                        <div class="flex items-center gap-2">
                                            <i class="fas ${icon} text-sm"></i>
                                            <span class="font-medium text-sm">${expert.name}</span>
                                        </div>
                                    </div>
                                    <div class="p-2">
                                        <div class="p-2 ${colors.light} rounded text-xs border mb-2">
                                            <strong>Verdict:</strong> ${expert.verdict}
                                        </div>
                                        ${expert.data_analysis && expert.data_analysis.length > 0 ? `
                                            <details class="text-xs text-gray-600 mb-2">
                                                <summary class="cursor-pointer font-medium">Data Analysis (${expert.data_analysis.length} points)</summary>
                                                <ul class="list-disc list-inside mt-1 space-y-1 ml-2">
                                                    ${expert.data_analysis.map(d => `<li>${d}</li>`).join('')}
                                                </ul>
                                            </details>
                                        ` : ''}
                                        <div class="text-xs text-gray-700">
                                            <strong>Rec:</strong> ${expert.recommendation}
                                        </div>
                                        ${expert.key_data_points && expert.key_data_points.length > 0 ? `
                                            <div class="mt-1 flex flex-wrap gap-1">
                                                ${expert.key_data_points.map(p => `<span class="px-1.5 py-0.5 bg-gray-100 text-gray-600 text-xs rounded">${p}</span>`).join('')}
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }

            // Build recommended response HTML
            let responseHtml = '';
            if (recommendedResponse) {
                responseHtml = `
                    <div class="p-3 bg-gradient-to-r from-emerald-50 to-teal-50 border border-emerald-200 rounded-lg mt-3">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-semibold text-emerald-800"><i class="fas fa-check-circle mr-1"></i>Recommended Response</span>
                            <button onclick="useExpertResponse('${comment.id}')" class="text-xs px-3 py-1 bg-emerald-600 text-white rounded hover:bg-emerald-700">
                                <i class="fas fa-copy mr-1"></i>Use This Response
                            </button>
                        </div>
                        <div class="text-sm text-emerald-900 whitespace-pre-wrap bg-white/50 p-2 rounded border border-emerald-100">${recommendedResponse}</div>
                    </div>
                `;
            }

            // Build advice HTML
            let adviceHtml = '';
            if (adviceToAuthor) {
                adviceHtml = `
                    <div class="p-2 bg-amber-50 border border-amber-200 rounded-lg mt-2">
                        <span class="text-xs font-semibold text-amber-800"><i class="fas fa-lightbulb mr-1"></i>Tip:</span>
                        <span class="text-xs text-amber-900">${adviceToAuthor}</span>
                    </div>
                `;
            }

            return `
                <div class="comment-card bg-white rounded-xl shadow-sm border border-gray-100 ${priorityClass} overflow-hidden">
                    <!-- Compact Header -->
                    <div class="p-3 bg-gray-50 border-b flex items-center justify-between gap-2 flex-wrap">
                        <div class="flex items-center gap-2 flex-wrap">
                            <span class="px-2 py-1 bg-gray-800 text-white text-sm font-bold rounded">${comment.id}</span>
                            <span class="px-2 py-0.5 text-xs font-medium rounded ${getTypeClass(comment.type)}">${comment.type}</span>
                            <span class="px-2 py-0.5 text-xs rounded bg-gray-200">${comment.category}</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="px-2 py-0.5 text-xs rounded ${getStatusClass(comment.status)}">${comment.status}</span>
                            <button onclick="openCommentModal('${comment.reviewerId}', '${comment.id}')"
                                    class="px-2 py-0.5 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200">
                                <i class="fas fa-expand-alt"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Reviewer Comment -->
                    <div class="p-3">
                        <p class="text-sm text-gray-800">"${comment.original_text.substring(0, 250)}${comment.original_text.length > 250 ? '...' : ''}"</p>
                        ${expertSummary}
                    </div>

                    <!-- Collapsible Details -->
                    <details class="border-t">
                        <summary class="p-2 bg-gray-50 cursor-pointer text-sm font-medium text-gray-600 hover:bg-gray-100">
                            <i class="fas fa-chevron-down mr-1 text-xs"></i> Show Full Comment & Expert Analysis
                        </summary>
                        <div class="p-3 bg-white">
                            <!-- Full Reviewer Comment -->
                            <div class="mb-4 p-3 bg-slate-50 border-l-4 border-slate-400 rounded-r">
                                <p class="text-xs font-semibold text-slate-600 mb-2"><i class="fas fa-quote-left mr-1"></i>Full Reviewer Comment:</p>
                                <p class="text-sm text-gray-800 whitespace-pre-wrap">${comment.original_text}</p>
                            </div>
                            ${fullContext ? `
                                <div class="mb-3 p-2 bg-purple-50 border border-purple-200 rounded">
                                    <p class="text-xs font-semibold text-purple-700 mb-1"><i class="fas fa-info-circle mr-1"></i>Additional Context:</p>
                                    <p class="text-xs text-purple-900">${fullContext}</p>
                                </div>
                            ` : ''}

                            ${comment.draft_response ? `
                                <div class="bg-green-50 rounded-lg p-3 mb-3 border border-green-200">
                                    <p class="text-sm font-medium text-green-700 mb-2"><i class="fas fa-pen mr-1"></i>Your Current Draft Response:</p>
                                    <p class="text-sm text-gray-700 whitespace-pre-wrap">${comment.draft_response}</p>
                                </div>
                            ` : ''}

                            ${expertsDetailHtml}
                            ${responseHtml}
                            ${adviceHtml}
                        </div>
                    </details>

                    <!-- Quick Actions -->
                    <div class="p-2 bg-gray-50 border-t flex items-center justify-between gap-2">
                        <div class="flex items-center gap-1">
                            <button onclick="setCommentStatus('${comment.reviewerId}', '${comment.id}', 'completed')"
                                    class="px-2 py-1 text-xs rounded ${comment.status === 'completed' ? 'bg-green-600 text-white' : 'bg-white border hover:bg-green-50'}"
                                    title="Mark completed">
                                <i class="fas fa-check"></i>
                            </button>
                            <button onclick="setCommentStatus('${comment.reviewerId}', '${comment.id}', 'in_progress')"
                                    class="px-2 py-1 text-xs rounded ${comment.status === 'in_progress' ? 'bg-blue-600 text-white' : 'bg-white border hover:bg-blue-50'}"
                                    title="Mark in progress">
                                <i class="fas fa-spinner"></i>
                            </button>
                            <button onclick="showRelatedComments('${comment.id}')"
                                    class="px-2 py-1 text-xs bg-purple-100 text-purple-700 rounded hover:bg-purple-200"
                                    title="Show related comments">
                                <i class="fas fa-project-diagram"></i>
                            </button>
                            <button onclick="discussCommentInChat('${comment.id}')"
                                    class="px-2 py-1 text-xs bg-green-100 text-green-700 rounded hover:bg-green-200"
                                    title="Discuss in chat">
                                <i class="fas fa-comments"></i>
                            </button>
                            <button onclick="regenerateExpertForComment('${comment.id}')"
                                    class="px-2 py-1 text-xs bg-amber-100 text-amber-700 rounded hover:bg-amber-200"
                                    title="Regenerate expert analysis for this comment">
                                <i class="fas fa-wand-magic-sparkles"></i>
                            </button>
                        </div>
                        <div class="flex items-center gap-1">
                            ${recommendedResponse ? `
                                <button onclick="useExpertResponse('${comment.id}')"
                                        class="px-2 py-1 text-xs bg-emerald-100 text-emerald-700 rounded hover:bg-emerald-200">
                                    <i class="fas fa-magic mr-1"></i>Use Response
                                </button>
                            ` : ''}
                            <button onclick="openCommentModal('${comment.reviewerId}', '${comment.id}')"
                                    class="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200">
                                <i class="fas fa-edit mr-1"></i>Edit
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        // Track expanded reviewers
        let expandedReviewers = {};

        // Render By Reviewer - Unified format with expert panels
        function renderByReviewer() {
            const html = `
                <div class="space-y-6">
                    ${reviewData.reviewers.map(reviewer => {
                        const isExpanded = expandedReviewers[reviewer.id];
                        const commentsToShow = isExpanded ? reviewer.comments : reviewer.comments.slice(0, 3);
                        const majorCount = reviewer.comments.filter(c => c.type === 'major').length;
                        const highPriorityCount = reviewer.comments.filter(c => c.priority === 'high').length;

                        return `
                        <div class="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden" data-reviewer="${reviewer.id}">
                            <div class="p-5 border-b border-gray-100 bg-gradient-to-r from-gray-50 to-gray-100">
                                <div class="flex items-center justify-between flex-wrap gap-3">
                                    <div>
                                        <h3 class="font-bold text-gray-800 text-lg">${reviewer.name}</h3>
                                        <p class="text-sm text-gray-500">${reviewer.expertise}</p>
                                        <p class="text-xs text-gray-400 mt-1">${reviewer.overall_assessment}</p>
                                    </div>
                                    <div class="flex items-center gap-3 flex-wrap">
                                        <span class="px-3 py-1 bg-gray-200 text-gray-700 rounded-full text-sm font-medium">
                                            ${reviewer.comments.length} comments
                                        </span>
                                        <span class="px-3 py-1 bg-red-100 text-red-700 rounded-full text-sm font-medium">
                                            ${majorCount} major
                                        </span>
                                        <span class="px-3 py-1 bg-orange-100 text-orange-700 rounded-full text-sm font-medium">
                                            ${highPriorityCount} high priority
                                        </span>
                                        <span class="px-3 py-1 bg-green-100 text-green-700 rounded-full text-sm font-medium">
                                            ${reviewer.comments.filter(c => c.status === 'completed').length} completed
                                        </span>
                                    </div>
                                </div>
                            </div>
                            <div class="p-5 space-y-4">
                                ${commentsToShow.map(c => renderCommentCard({...c, reviewer: reviewer.name, reviewerId: reviewer.id})).join('')}
                                ${reviewer.comments.length > 3 ? `
                                    <button onclick="toggleReviewerExpand('${reviewer.id}')"
                                            class="w-full text-center py-3 bg-gray-50 hover:bg-gray-100 rounded-lg text-sm font-medium text-blue-600 border border-gray-200">
                                        <i class="fas ${isExpanded ? 'fa-chevron-up' : 'fa-chevron-down'} mr-2"></i>
                                        ${isExpanded ? 'Show less' : `Show all ${reviewer.comments.length} comments`}
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                    `;}).join('')}
                </div>
            `;
            document.getElementById('content-area').innerHTML = html;
        }

        function toggleReviewerExpand(reviewerId) {
            expandedReviewers[reviewerId] = !expandedReviewers[reviewerId];
            renderByReviewer();
        }

        // Render Agents - generic experts loaded from config or defaults
        function renderAgents() {
            const agents = [
                {
                    id: 'methodology',
                    name: 'Methodology Expert',
                    description: 'Specializes in experimental design, controls, sample size, and reproducibility concerns.',
                    icon: 'fa-flask',
                    color: 'from-red-500 to-pink-500',
                    skills: ['Experimental design', 'Controls validation', 'Sample size justification', 'Reproducibility']
                },
                {
                    id: 'statistics',
                    name: 'Statistical Analysis Expert',
                    description: 'Handles statistical test selection, assumptions, effect sizes, and multiple comparisons.',
                    icon: 'fa-chart-bar',
                    color: 'from-blue-500 to-cyan-500',
                    skills: ['Test selection', 'Assumption checking', 'Effect sizes', 'Multiple comparisons']
                },
                {
                    id: 'writing',
                    name: 'Writing & Presentation Expert',
                    description: 'Expert in scientific writing clarity, structure, figures, and journal-specific formatting.',
                    icon: 'fa-pen',
                    color: 'from-green-500 to-emerald-500',
                    skills: ['Clarity improvement', 'Figure presentation', 'Structure', 'Accessibility']
                },
                {
                    id: 'literature',
                    name: 'Literature & Citations Expert',
                    description: 'Specializes in literature coverage, citation accuracy, and contextualizing findings.',
                    icon: 'fa-book',
                    color: 'from-purple-500 to-violet-500',
                    skills: ['Citation review', 'Literature gaps', 'Context', 'Comparison with prior work']
                },
                {
                    id: 'domain',
                    name: 'Domain Expert',
                    description: 'Field-specific expertise loaded from your manuscript context and skills.',
                    icon: 'fa-graduation-cap',
                    color: 'from-yellow-500 to-orange-500',
                    skills: ['Domain knowledge', 'Technical accuracy', 'Field standards', 'Terminology']
                }
            ];

            const html = `
                <div class="mb-6 bg-blue-50 border border-blue-200 rounded-xl p-5">
                    <div class="flex items-start gap-4">
                        <div class="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center flex-shrink-0">
                            <i class="fas fa-robot text-blue-600"></i>
                        </div>
                        <div>
                            <h3 class="font-semibold text-blue-900">Just Ask Me Directly!</h3>
                            <p class="text-sm text-blue-700 mt-1">I have all your review data and these domain skills built-in. Simply ask me in the chat:</p>
                            <div class="mt-3 space-y-2">
                                <code class="block bg-white px-3 py-2 rounded text-sm text-blue-800">"Help me respond to R1-4 using the phylogenetics skill"</code>
                                <code class="block bg-white px-3 py-2 rounded text-sm text-blue-800">"What does the DNA damage expert say about authentication?"</code>
                            </div>
                        </div>
                    </div>
                </div>

                <h3 class="font-semibold text-gray-800 mb-4">Available Domain Experts</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    ${agents.map(agent => `
                        <div class="bg-gradient-to-br ${agent.color} rounded-xl p-6 text-white cursor-pointer transform hover:scale-105 transition-transform"
                             onclick="startAgentConsultation('${agent.id}')">
                            <div class="flex items-center gap-4 mb-4">
                                <div class="w-12 h-12 bg-white bg-opacity-20 rounded-full flex items-center justify-center">
                                    <i class="fas ${agent.icon} text-xl"></i>
                                </div>
                                <h3 class="font-semibold">${agent.name}</h3>
                            </div>
                            <p class="text-sm text-white text-opacity-90 mb-4">${agent.description}</p>
                            <div class="flex flex-wrap gap-2">
                                ${agent.skills.map(skill => `
                                    <span class="px-2 py-1 text-xs bg-white bg-opacity-20 rounded">${skill}</span>
                                `).join('')}
                            </div>
                        </div>
                    `).join('')}
                </div>

                <div class="mt-8 bg-white rounded-xl p-6 shadow-sm border border-gray-100">
                    <h3 class="font-semibold text-gray-800 mb-4">Quick Prompts</h3>
                    <p class="text-sm text-gray-600 mb-4">Click to copy, then paste in the chat:</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                        <button onclick="copyPrompt('Show me all high priority comments that need the phylogenetics skill')"
                                class="text-left px-4 py-3 bg-gray-50 hover:bg-gray-100 rounded-lg text-sm">
                            <i class="fas fa-copy text-gray-400 mr-2"></i>Show high priority + phylogenetics
                        </button>
                        <button onclick="copyPrompt('Help me draft responses for all authentication concerns from R1')"
                                class="text-left px-4 py-3 bg-gray-50 hover:bg-gray-100 rounded-lg text-sm">
                            <i class="fas fa-copy text-gray-400 mr-2"></i>Draft authentication responses
                        </button>
                        <button onclick="copyPrompt('Use the microbial ecology skill to improve my response to R3-2')"
                                class="text-left px-4 py-3 bg-gray-50 hover:bg-gray-100 rounded-lg text-sm">
                            <i class="fas fa-copy text-gray-400 mr-2"></i>Improve ecology response
                        </button>
                        <button onclick="copyPrompt('What new analyses are needed and which skills should I use for each?')"
                                class="text-left px-4 py-3 bg-gray-50 hover:bg-gray-100 rounded-lg text-sm">
                            <i class="fas fa-copy text-gray-400 mr-2"></i>List analyses needed
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('content-area').innerHTML = html;
        }

        // Expert discussions data - loaded dynamically from database or file
        // No hardcoded data - generated by OpenCode after setup
        // This empty structure will be populated by setup.js when parsing reviews
        const EXPERT_DISCUSSIONS_DATA = {
            "generated": "dynamic",
            "note": "Run setup.js to parse reviews and populate this data",
            "data_sources": {},
            "reviewers_summary": {},
            "expert_discussions": {}
        };
        // NOTE: Remaining expert discussions data removed - will be populated dynamically by setup.js
        let expertDiscussions = EXPERT_DISCUSSIONS_DATA;


        async function loadExpertDiscussions() {
            // Priority 1: Try localStorage (has user-generated analysis)
            if (loadExpertDiscussionsFromStorage()) {
                console.log('Expert discussions loaded from localStorage');
                return;
            }

            // Priority 2: Try fetching from server
            try {
                const response = await fetch(`${API_BASE}/expert-discussions`);
                if (response.ok) {
                    const data = await response.json();
                    if (data && data.expert_discussions && Object.keys(data.expert_discussions).length > 0) {
                        expertDiscussions = data;
                        console.log('Expert discussions loaded from server');
                        return;
                    }
                }
            } catch (e) {
                console.log('Could not load from server:', e.message);
            }

            // Priority 3: Try fetching from JSON file
            try {
                const response = await fetch('expert_discussions.json');
                if (response.ok) {
                    expertDiscussions = await response.json();
                    console.log('Expert discussions loaded from JSON file');
                    return;
                }
            } catch (e) {
                console.log('Could not load from JSON file');
            }

            // Priority 4: Use embedded data (empty by default)
            expertDiscussions = EXPERT_DISCUSSIONS_DATA;
            console.log('Using default empty expert discussions');
        }

        // Current filter state for expert view
        let expertFilter = 'all'; // 'all', 'major', 'minor', 'R1', 'R3', 'R4'

        // Render Expert Insights - EXTENSIVE VERSION (uses global iconMap and colorMap)
        async function renderExperts() {
            if (!expertDiscussions) {
                await loadExpertDiscussions();
            }

            // Filter and organize comments
            let allCommentIds = [];
            if (expertDiscussions && expertDiscussions.expert_discussions) {
                allCommentIds = Object.keys(expertDiscussions.expert_discussions);
            }

            // Apply filter
            let filteredIds = allCommentIds;
            if (expertFilter === 'major') {
                filteredIds = allCommentIds.filter(k => expertDiscussions.expert_discussions[k].type === 'major');
            } else if (expertFilter === 'minor') {
                filteredIds = allCommentIds.filter(k => expertDiscussions.expert_discussions[k].type === 'minor');
            } else if (expertFilter.startsWith('R')) {
                filteredIds = allCommentIds.filter(k => k.startsWith(expertFilter));
            }

            // Sort by comment ID
            filteredIds.sort((a, b) => {
                const ra = a.match(/R(\d+)-(\d+)/);
                const rb = b.match(/R(\d+)-(\d+)/);
                if (ra && rb) {
                    if (ra[1] !== rb[1]) return parseInt(ra[1]) - parseInt(rb[1]);
                    return parseInt(ra[2]) - parseInt(rb[2]);
                }
                return a.localeCompare(b);
            });

            // Count stats
            const majorCount = allCommentIds.filter(k => expertDiscussions?.expert_discussions?.[k]?.type === 'major').length;
            const minorCount = allCommentIds.filter(k => expertDiscussions?.expert_discussions?.[k]?.type === 'minor').length;
            const r1Count = allCommentIds.filter(k => k.startsWith('R1')).length;
            const r3Count = allCommentIds.filter(k => k.startsWith('R3')).length;
            const r4Count = allCommentIds.filter(k => k.startsWith('R4')).length;

            // Build discussion cards
            let discussionCards = '';
            for (const commentId of filteredIds) {
                const disc = expertDiscussions.expert_discussions[commentId];
                if (!disc) continue;

                const borderColor = disc.priority === 'high' ? 'border-red-400' :
                                   disc.priority === 'medium' ? 'border-yellow-400' : 'border-green-400';
                const priorityBadge = disc.priority === 'high'
                    ? '<span class="px-2 py-0.5 bg-red-100 text-red-700 text-xs rounded-full">HIGH</span>'
                    : disc.priority === 'medium'
                    ? '<span class="px-2 py-0.5 bg-yellow-100 text-yellow-700 text-xs rounded-full">MEDIUM</span>'
                    : '<span class="px-2 py-0.5 bg-green-100 text-green-700 text-xs rounded-full">LOW</span>';
                const typeBadge = disc.type === 'major'
                    ? '<span class="px-2 py-0.5 bg-red-500 text-white text-xs rounded-full">MAJOR</span>'
                    : '<span class="px-2 py-0.5 bg-gray-200 text-gray-700 text-xs rounded-full">MINOR</span>';

                let expertsHtml = '';
                if (disc.experts && disc.experts.length > 0) {
                    for (const expert of disc.experts) {
                        const colors = colorMap[expert.color] || colorMap.blue;
                        const icon = iconMap[expert.icon] || 'fa-user';

                        expertsHtml += `
                            <div class="bg-white rounded-lg shadow-sm border overflow-hidden mb-3">
                                <div class="bg-gradient-to-r ${colors.bg} p-3 text-white">
                                    <div class="flex items-center gap-2">
                                        <i class="fas ${icon}"></i>
                                        <span class="font-semibold text-sm">${expert.name}</span>
                                    </div>
                                </div>
                                <div class="p-3">
                                    <div class="mb-2 p-2 ${colors.light} rounded text-xs border">
                                        <strong>Verdict:</strong> ${expert.verdict}
                                    </div>
                                    ${expert.data_analysis && expert.data_analysis.length > 0 ? `
                                        <div class="text-xs text-gray-600 mb-2">
                                            <strong>Data Analysis:</strong>
                                            <ul class="list-disc list-inside mt-1 space-y-1">
                                                ${expert.data_analysis.map(d => `<li>${d}</li>`).join('')}
                                            </ul>
                                        </div>
                                    ` : ''}
                                    <div class="text-xs text-gray-700">
                                        <strong>Recommendation:</strong> ${expert.recommendation}
                                    </div>
                                    ${expert.key_data_points && expert.key_data_points.length > 0 ? `
                                        <div class="mt-2 flex flex-wrap gap-1">
                                            ${expert.key_data_points.map(p => `<span class="px-2 py-0.5 bg-gray-100 text-gray-600 text-xs rounded">${p}</span>`).join('')}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        `;
                    }
                } else {
                    expertsHtml = '<p class="text-sm text-gray-500 italic">No detailed expert analysis needed for this minor comment.</p>';
                }

                discussionCards += `
                    <div class="bg-white rounded-xl shadow-sm border ${borderColor} border-l-4 overflow-hidden mb-6" id="expert-${commentId}">
                        <div class="p-4 border-b bg-gray-50">
                            <div class="flex items-start justify-between flex-wrap gap-2">
                                <div class="flex items-center gap-2 flex-wrap">
                                    <span class="px-3 py-1 bg-gray-800 text-white text-sm font-bold rounded">${commentId}</span>
                                    ${typeBadge}
                                    ${priorityBadge}
                                    <span class="px-2 py-0.5 bg-purple-100 text-purple-700 text-xs rounded">${disc.category || 'General'}</span>
                                </div>
                                <div class="flex gap-2">
                                    <button onclick="copyResponse('${commentId}')" class="text-xs px-3 py-1 bg-purple-100 text-purple-700 rounded hover:bg-purple-200">
                                        <i class="fas fa-copy mr-1"></i>Copy Response
                                    </button>
                                    <button onclick="useExpertResponse('${commentId}')" class="text-xs px-3 py-1 bg-green-100 text-green-700 rounded hover:bg-green-200">
                                        <i class="fas fa-check mr-1"></i>Use This
                                    </button>
                                </div>
                            </div>
                            <p class="mt-3 text-sm text-gray-700">"${disc.reviewer_comment}"</p>
                            ${disc.full_context ? `<p class="mt-2 text-xs text-gray-500 italic">${disc.full_context}</p>` : ''}
                        </div>
                        <div class="p-4">
                            ${disc.experts && disc.experts.length > 0 ? `
                                <h4 class="text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
                                    <i class="fas fa-users text-purple-500"></i>
                                    Expert Panel Discussion (${disc.experts.length} expert${disc.experts.length > 1 ? 's' : ''})
                                </h4>
                            ` : ''}
                            ${expertsHtml}
                            <div class="mt-4 p-3 bg-gradient-to-r from-emerald-50 to-teal-50 border border-emerald-200 rounded-lg">
                                <h5 class="text-sm font-semibold text-emerald-800 mb-2 flex items-center gap-2">
                                    <i class="fas fa-check-circle"></i>
                                    Recommended Response
                                </h5>
                                <p class="text-xs text-emerald-900 whitespace-pre-line" id="response-${commentId}">${disc.recommended_response}</p>
                            </div>
                            ${disc.advice_to_author ? `
                                <div class="mt-3 p-3 bg-amber-50 border border-amber-200 rounded-lg">
                                    <h5 class="text-sm font-semibold text-amber-800 mb-1 flex items-center gap-2">
                                        <i class="fas fa-lightbulb"></i>
                                        Advice to Author
                                    </h5>
                                    <p class="text-xs text-amber-900">${disc.advice_to_author}</p>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            const html = `
                <!-- Expert Insights Header -->
                <div class="mb-6 bg-gradient-to-r from-emerald-600 to-teal-600 rounded-xl p-6 text-white shadow-lg">
                    <div class="flex items-start gap-4">
                        <div class="w-14 h-14 bg-white bg-opacity-20 rounded-full flex items-center justify-center flex-shrink-0">
                            <i class="fas fa-microscope text-2xl"></i>
                        </div>
                        <div class="flex-1">
                            <h3 class="text-xl font-bold mb-2">Comprehensive Expert Analysis & Discussion</h3>
                            <p class="text-white text-opacity-90">
                                Domain experts analyze the supplementary data and provide specific advice for ALL ${allCommentIds.length} reviewer comments.
                                Each panel shows expert interpretation of the data, recommended responses, and strategic advice.
                            </p>
                            <div class="mt-3 flex gap-2 flex-wrap">
                                <button onclick="regenerateAllExpertAnalysis()" class="px-4 py-2 bg-white bg-opacity-20 hover:bg-opacity-30 rounded-lg text-sm font-medium transition-all">
                                    <i class="fas fa-sync-alt mr-2"></i>Regenerate All Expert Analysis
                                </button>
                                <button onclick="regenerateExpertForComment()" class="px-4 py-2 bg-white bg-opacity-20 hover:bg-opacity-30 rounded-lg text-sm font-medium transition-all">
                                    <i class="fas fa-wand-magic-sparkles mr-2"></i>Regenerate Single Comment
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Key Statistics Banner -->
                <div class="grid grid-cols-2 md:grid-cols-6 gap-3 mb-6">
                    <div class="bg-white rounded-xl p-3 shadow-sm border border-gray-100 text-center">
                        <div class="text-2xl font-bold text-emerald-600">30.3%</div>
                        <div class="text-xs text-gray-500">Mean Damage</div>
                    </div>
                    <!-- Stats are dynamically generated from manuscript data -->
                    <div id="expert-stats-container" class="text-sm text-gray-500 text-center py-2">
                        Statistics will appear here after loading manuscript data
                    </div>
                </div>

                <!-- Reviewer Summary - dynamically generated -->
                <div class="mb-6 bg-white rounded-xl shadow-sm border p-4">
                    <h4 class="font-semibold text-gray-700 mb-3 flex items-center gap-2">
                        <i class="fas fa-users text-gray-500"></i>
                        Reviewer Summary
                    </h4>
                    <div id="reviewer-summary-container" class="grid grid-cols-1 md:grid-cols-3 gap-3 text-sm">
                        ${reviewData?.reviewers?.map((r, i) => `
                        <div class="p-3 bg-blue-50 rounded-lg cursor-pointer hover:bg-blue-100" onclick="setExpertFilter('${r.id}')">
                            <span class="font-bold text-blue-800">${r.name}</span>
                            <p class="text-xs text-blue-600">${r.expertise || 'Reviewer'} - ${r.comments?.length || 0} comments</p>
                        </div>
                        `).join('') || '<p class="text-gray-500">No reviewer data loaded</p>'}
                    </div>
                </div>

                <!-- Filter Controls -->
                <div class="mb-6 bg-white rounded-xl shadow-sm border p-4">
                    <h4 class="font-semibold text-gray-700 mb-3 flex items-center gap-2">
                        <i class="fas fa-filter text-gray-500"></i>
                        Filter Expert Discussions
                    </h4>
                    <div class="flex flex-wrap gap-2">
                        <button onclick="setExpertFilter('all')"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-colors ${expertFilter === 'all' ? 'bg-gray-800 text-white' : 'bg-gray-100 hover:bg-gray-200'}">
                            All (${allCommentIds.length})
                        </button>
                        <button onclick="setExpertFilter('major')"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-colors ${expertFilter === 'major' ? 'bg-red-600 text-white' : 'bg-red-100 text-red-700 hover:bg-red-200'}">
                            Major (${majorCount})
                        </button>
                        <button onclick="setExpertFilter('minor')"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-colors ${expertFilter === 'minor' ? 'bg-gray-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}">
                            Minor (${minorCount})
                        </button>
                        <span class="border-l border-gray-300 mx-2"></span>
                        <button onclick="setExpertFilter('R1')"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-colors ${expertFilter === 'R1' ? 'bg-blue-600 text-white' : 'bg-blue-100 text-blue-700 hover:bg-blue-200'}">
                            R1 (${r1Count})
                        </button>
                        <button onclick="setExpertFilter('R3')"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-colors ${expertFilter === 'R3' ? 'bg-green-600 text-white' : 'bg-green-100 text-green-700 hover:bg-green-200'}">
                            R3 (${r3Count})
                        </button>
                        <button onclick="setExpertFilter('R4')"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-colors ${expertFilter === 'R4' ? 'bg-purple-600 text-white' : 'bg-purple-100 text-purple-700 hover:bg-purple-200'}">
                            R4 (${r4Count})
                        </button>
                    </div>
                </div>

                <!-- Quick Navigation -->
                <div class="mb-6 bg-white rounded-xl shadow-sm border p-4">
                    <h4 class="font-semibold text-gray-700 mb-3 flex items-center gap-2">
                        <i class="fas fa-list text-gray-500"></i>
                        Quick Navigation (${filteredIds.length} comments shown)
                    </h4>
                    <div class="flex flex-wrap gap-2">
                        ${filteredIds.map(id => {
                            const d = expertDiscussions.expert_discussions[id];
                            const bgClass = d?.type === 'major' ? 'bg-red-100 text-red-700 hover:bg-red-200' : 'bg-gray-100 text-gray-700 hover:bg-gray-200';
                            return `<a href="#expert-${id}" class="px-2 py-1 rounded text-xs font-medium ${bgClass}">${id}</a>`;
                        }).join('')}
                    </div>
                </div>

                <!-- Expert Discussions by Comment -->
                <h3 class="text-lg font-semibold text-gray-800 mb-4 flex items-center gap-2">
                    <i class="fas fa-comments text-purple-500"></i>
                    Expert Discussions (${filteredIds.length} comments)
                </h3>
                ${discussionCards || '<p class="text-gray-500">Loading expert discussions...</p>'}

                <!-- Bottom Actions -->
                <div class="mt-8 bg-white rounded-xl shadow-sm border p-6">
                    <h4 class="font-semibold text-gray-700 mb-4">Bulk Actions</h4>
                    <div class="flex flex-wrap gap-3">
                        <button onclick="copyAllResponses()" class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700">
                            <i class="fas fa-copy mr-2"></i>Copy All Responses
                        </button>
                        <button onclick="exportExpertReport()" class="px-4 py-2 bg-emerald-600 text-white rounded-lg hover:bg-emerald-700">
                            <i class="fas fa-file-alt mr-2"></i>Export Report
                        </button>
                        <button onclick="applyAllResponses()" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
                            <i class="fas fa-check-double mr-2"></i>Apply All to Draft
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('content-area').innerHTML = html;
        }

        function setExpertFilter(filter) {
            expertFilter = filter;
            renderExperts();
        }

        // Regenerate expert analysis for a single comment using OpenCode
        // Build manuscript context for expert analysis prompts
        function buildManuscriptContextForExperts() {
            const manuscript = reviewData?.manuscript || {};
            const manuscriptData = reviewData?.manuscript_data || {};
            const categories = manuscriptData.categories || [];
            const thematicGroups = manuscriptData.thematic_groups || [];

            // Get comment statistics
            const allComments = getAllComments();
            const reviewerCount = reviewData?.reviewers?.length || 0;
            const majorCount = allComments.filter(c => c.type === 'major').length;
            const minorCount = allComments.filter(c => c.type === 'minor').length;

            let context = `MANUSCRIPT: "${manuscript.title || 'Untitled'}"
AUTHORS: ${manuscript.authors || 'Unknown'}
FIELD: ${manuscript.field || 'Not specified'}

REVIEW STATISTICS:
- ${reviewerCount} reviewers
- ${allComments.length} total comments (${majorCount} major, ${minorCount} minor)
${categories.length > 0 ? `- Categories: ${categories.join(', ')}` : ''}
${thematicGroups.length > 0 ? `- Thematic groups: ${thematicGroups.map(g => g.name || g).join(', ')}` : ''}`;

            // Add any key data points from manuscript_data if available
            if (manuscriptData.key_statistics) {
                context += `\n\nKEY DATA POINTS:\n`;
                for (const [key, value] of Object.entries(manuscriptData.key_statistics)) {
                    context += `- ${key}: ${value}\n`;
                }
            }

            return context;
        }

        // Get expert types based on comment category
        function getRelevantExpertTypes(category) {
            const expertsByCategory = {
                'Authentication': ['DNA Damage Expert', 'Contamination Expert', 'Geochronology Expert'],
                'Methods': ['Bioinformatics Expert', 'Statistics Expert', 'Methodology Expert'],
                'Analysis': ['Data Analysis Expert', 'Bioinformatics Expert', 'Visualization Expert'],
                'Interpretation': ['Domain Expert', 'Scientific Communication Expert', 'Ecology Expert'],
                'Terminology': ['Scientific Communication Expert', 'Domain Expert'],
                'Novelty': ['Literature Expert', 'Domain Expert', 'Scientific Communication Expert'],
                'Clarity': ['Scientific Communication Expert', 'Technical Writing Expert'],
                'Figure': ['Visualization Expert', 'Data Presentation Expert'],
                'Citation': ['Literature Expert'],
                'Formatting': ['Technical Writing Expert'],
                'Accuracy': ['Domain Expert', 'Fact-Checking Expert'],
                'Validation': ['Methods Expert', 'Statistics Expert', 'Quality Control Expert'],
                'Database': ['Bioinformatics Expert', 'Data Management Expert'],
                'Results': ['Data Analysis Expert', 'Statistics Expert', 'Domain Expert'],
                'Discussion': ['Domain Expert', 'Scientific Communication Expert'],
                'Focus': ['Scientific Communication Expert', 'Editorial Expert']
            };

            return expertsByCategory[category] || ['Domain Expert', 'Methodology Expert'];
        }

        async function regenerateExpertForComment(commentId = null) {
            // If no ID provided, prompt user
            if (!commentId) {
                const allIds = Object.keys(expertDiscussions?.expert_discussions || {});
                commentId = prompt('Enter comment ID to regenerate (e.g., R1-1):', allIds[0] || 'R1-1');
                if (!commentId) return;
            }

            const comment = getAllComments().find(c => c.id === commentId);
            if (!comment) {
                showNotification(`Comment ${commentId} not found`, 'error');
                return;
            }

            showNotification(`Regenerating expert analysis for ${commentId}...`, 'info');

            // Build context-aware prompt
            const manuscriptContext = buildManuscriptContextForExperts();
            const suggestedExperts = getRelevantExpertTypes(comment.category);

            const expertPrompt = `You are a panel of domain experts analyzing this reviewer comment for a scientific manuscript.

${manuscriptContext}

---

COMMENT TO ANALYZE:
ID: ${commentId}
REVIEWER: ${comment.reviewer}
TYPE: ${comment.type.toUpperCase()} (${comment.priority} priority)
CATEGORY: ${comment.category}
${comment.location ? `LOCATION: ${comment.location}` : ''}

REVIEWER'S COMMENT:
"${comment.original_text}"

${comment.full_context ? `ADDITIONAL CONTEXT: ${comment.full_context}` : ''}

---

TASK: Provide multi-expert analysis. Consider using experts like: ${suggestedExperts.join(', ')}

Return your analysis in this exact JSON format:

{
  "experts": [
    {
      "name": "Expert Title (e.g., DNA Damage Authentication Expert)",
      "icon": "dna",
      "color": "blue",
      "verdict": "AGREE/DISAGREE/PARTIALLY AGREE - brief summary of position",
      "assessment": "2-3 sentence detailed assessment of the reviewer's point and its validity",
      "data_analysis": [
        "Specific finding or data point 1",
        "Specific finding or data point 2",
        "Specific finding or data point 3"
      ],
      "recommendation": "Concrete action to take in response",
      "key_data_points": ["stat1", "stat2", "stat3"]
    }
  ],
  "recommended_response": "A complete, professional draft response (2-4 paragraphs) that thanks the reviewer, addresses their concern with specific data, and explains what actions were taken. Use past tense for completed actions.",
  "advice_to_author": "Strategic meta-advice on tone, framing, and what to emphasize when responding to this comment"
}

GUIDELINES:
- Include 1-3 experts based on topic complexity
- Use specific numbers/data when available
- For valid criticisms: agree graciously and explain fixes
- For misunderstandings: respectfully clarify with evidence
- Icons: dna, flask, code, tree, leaf, mountain, shield-virus, cogs, pen, globe, code-branch, chart-bar
- Colors: blue, green, red, orange, purple, cyan, brown, gray`;

            try {
                const response = await fetch(`${API_BASE}/ask`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: expertPrompt,
                        comment_id: `regenerate-expert-${commentId}`,
                        model: aiSettings.model,
                        agent: aiSettings.agent,
                        variant: aiSettings.variant
                    })
                });

                if (response.ok) {
                    const result = await response.json();

                    // Try to parse JSON from response
                    try {
                        const jsonMatch = result.response.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const newExpertData = JSON.parse(jsonMatch[0]);

                            // Update the expert discussions
                            if (!expertDiscussions) expertDiscussions = { expert_discussions: {} };

                            expertDiscussions.expert_discussions[commentId] = {
                                ...expertDiscussions.expert_discussions[commentId],
                                reviewer_comment: comment.original_text,
                                full_context: comment.full_context || '',
                                priority: comment.priority,
                                type: comment.type,
                                category: comment.category,
                                experts: newExpertData.experts || [],
                                recommended_response: newExpertData.recommended_response || '',
                                advice_to_author: newExpertData.advice_to_author || '',
                                regenerated_at: new Date().toISOString()
                            };

                            // Save and re-render
                            await saveExpertDiscussions();
                            renderExperts();
                            showNotification(`Expert analysis regenerated for ${commentId}!`, 'success');
                        } else {
                            showNotification('Could not parse expert analysis response', 'error');
                            console.log('Raw response:', result.response);
                        }
                    } catch (parseError) {
                        showNotification('Error parsing expert analysis: ' + parseError.message, 'error');
                        console.log('Parse error, raw response:', result.response);
                    }
                } else {
                    showNotification('Failed to regenerate expert analysis', 'error');
                }
            } catch (e) {
                showNotification('Error: ' + e.message, 'error');
            }
        }

        // Regenerate expert analysis for ALL comments (batch process)
        async function regenerateAllExpertAnalysis() {
            // Context check removed - OpenCode session may already have context loaded externally

            const allComments = getAllComments();
            const confirm = window.confirm(`This will regenerate expert analysis for all ${allComments.length} comments using OpenCode. This may take several minutes. Continue?`);
            if (!confirm) return;

            // Show progress modal
            const modal = document.createElement('div');
            modal.id = 'regenerate-progress-modal';
            modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl w-full max-w-md p-6">
                    <h3 class="font-bold text-lg mb-4">Regenerating Expert Analysis</h3>
                    <div class="mb-4">
                        <div class="w-full bg-gray-200 rounded-full h-3">
                            <div id="regen-progress-bar" class="bg-emerald-600 h-3 rounded-full transition-all" style="width: 0%"></div>
                        </div>
                        <p id="regen-progress-text" class="text-sm text-gray-600 mt-2">Starting...</p>
                    </div>
                    <div id="regen-log" class="max-h-40 overflow-y-auto text-xs text-gray-500 bg-gray-50 rounded p-2 font-mono"></div>
                    <button onclick="document.getElementById('regenerate-progress-modal')?.remove()" class="mt-4 w-full py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300">
                        Close (regeneration continues in background)
                    </button>
                </div>
            `;
            document.body.appendChild(modal);

            const progressBar = document.getElementById('regen-progress-bar');
            const progressText = document.getElementById('regen-progress-text');
            const logEl = document.getElementById('regen-log');

            const addLog = (msg) => {
                logEl.innerHTML += msg + '<br>';
                logEl.scrollTop = logEl.scrollHeight;
            };

            let completed = 0;
            let failed = 0;

            for (let i = 0; i < allComments.length; i++) {
                const comment = allComments[i];
                const progress = ((i + 1) / allComments.length * 100).toFixed(0);

                progressBar.style.width = progress + '%';
                progressText.textContent = `Processing ${comment.id} (${i + 1}/${allComments.length})`;
                addLog(` ${comment.id}...`);

                try {
                    await regenerateExpertForCommentSilent(comment);
                    addLog(` ${comment.id} done`);
                    completed++;
                } catch (e) {
                    addLog(` ${comment.id} failed: ${e.message}`);
                    failed++;
                }

                // Small delay to avoid overwhelming the API
                await new Promise(r => setTimeout(r, 500));
            }

            progressText.textContent = `Complete! ${completed} regenerated, ${failed} failed`;
            addLog(`\n=== DONE ===`);
            showNotification(`Regenerated ${completed}/${allComments.length} expert analyses`, completed === allComments.length ? 'success' : 'warning');
            renderExperts();
        }

        // Silent version for batch processing
        async function regenerateExpertForCommentSilent(comment) {
            const manuscriptContext = buildManuscriptContextForExperts();
            const suggestedExperts = getRelevantExpertTypes(comment.category);

            const batchPrompt = `Expert panel analysis for reviewer comment on scientific manuscript.

${manuscriptContext}

COMMENT: ${comment.id} (${comment.type.toUpperCase()}, ${comment.priority} priority)
CATEGORY: ${comment.category}
${comment.location ? `LOCATION: ${comment.location}` : ''}

"${comment.original_text}"

${comment.full_context ? `CONTEXT: ${comment.full_context}` : ''}

Consider experts like: ${suggestedExperts.join(', ')}

Return JSON:
{
  "experts": [{"name": "Expert Title", "icon": "dna/flask/code/tree/leaf/cogs/pen", "color": "blue/green/red/orange/purple", "verdict": "AGREE/DISAGREE - summary", "assessment": "Detailed assessment", "data_analysis": ["Point 1", "Point 2"], "recommendation": "Action to take", "key_data_points": ["stat1", "stat2"]}],
  "recommended_response": "Professional 2-4 paragraph response thanking reviewer, addressing concern with data, explaining actions taken (past tense)",
  "advice_to_author": "Strategic advice on tone and framing"
}

Use 1-3 experts. Be specific with data. For valid criticisms: agree graciously. For misunderstandings: clarify respectfully.`;

            const response = await fetch(`${API_BASE}/ask`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt: batchPrompt,
                    comment_id: `regen-${comment.id}`,
                    model: aiSettings.model,
                    agent: aiSettings.agent,
                    variant: aiSettings.variant
                })
            });

            if (!response.ok) throw new Error('API request failed');

            const result = await response.json();
            const jsonMatch = result.response.match(/\{[\s\S]*\}/);
            if (!jsonMatch) throw new Error('No JSON in response');

            const newExpertData = JSON.parse(jsonMatch[0]);

            if (!expertDiscussions) expertDiscussions = { expert_discussions: {} };

            expertDiscussions.expert_discussions[comment.id] = {
                reviewer_comment: comment.original_text,
                full_context: comment.full_context || '',
                priority: comment.priority,
                type: comment.type,
                category: comment.category,
                experts: newExpertData.experts || [],
                recommended_response: newExpertData.recommended_response || '',
                advice_to_author: newExpertData.advice_to_author || '',
                regenerated_at: new Date().toISOString()
            };

            // Auto-save after batch update
            await saveExpertDiscussions();
        }

        // Save expert discussions to localStorage and optionally to server
        async function saveExpertDiscussions() {
            if (!expertDiscussions) return;

            // Save to localStorage
            try {
                localStorage.setItem('expertDiscussions', JSON.stringify(expertDiscussions));
                console.log('Expert discussions saved to localStorage');
            } catch (e) {
                console.error('Failed to save expert discussions to localStorage:', e);
            }

            // Also try to save to server if available
            try {
                const response = await fetch(`${API_BASE}/expert-discussions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(expertDiscussions)
                });
                if (response.ok) {
                    console.log('Expert discussions saved to server');
                }
            } catch (e) {
                // Server save is optional, don't show error
                console.log('Server save not available, using localStorage only');
            }
        }

        // Load expert discussions from localStorage on startup
        function loadExpertDiscussionsFromStorage() {
            try {
                const saved = localStorage.getItem('expertDiscussions');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    if (parsed && parsed.expert_discussions) {
                        expertDiscussions = parsed;
                        console.log('Loaded expert discussions from localStorage:', Object.keys(parsed.expert_discussions).length, 'comments');
                        return true;
                    }
                }
            } catch (e) {
                console.error('Failed to load expert discussions from localStorage:', e);
            }
            return false;
        }

        function useExpertResponse(commentId) {
            if (!expertDiscussions || !expertDiscussions.expert_discussions[commentId]) return;

            const disc = expertDiscussions.expert_discussions[commentId];

            // Find the matching comment in reviewData
            for (const reviewer of reviewData.reviewers) {
                const comment = reviewer.comments.find(c => c.id === commentId);
                if (comment) {
                    comment.draft_response = disc.recommended_response;
                    comment.status = 'in_progress';
                    saveProgress();
                    alert(`Response applied to ${commentId}! Status set to "in progress".`);
                    return;
                }
            }
            alert('Comment not found in review data.');
        }

        function copyAllResponses() {
            if (!expertDiscussions) return;

            let allResponses = '';
            const ids = Object.keys(expertDiscussions.expert_discussions).sort();

            for (const id of ids) {
                const disc = expertDiscussions.expert_discussions[id];
                allResponses += `=== ${id} ===\n${disc.recommended_response}\n\n`;
            }

            navigator.clipboard.writeText(allResponses).then(() => {
                alert('All responses copied to clipboard!');
            });
        }

        function applyAllResponses() {
            if (!expertDiscussions || !confirm('This will apply all expert responses as drafts. Continue?')) return;

            let applied = 0;
            for (const reviewer of reviewData.reviewers) {
                for (const comment of reviewer.comments) {
                    const disc = expertDiscussions.expert_discussions[comment.id];
                    if (disc && disc.recommended_response) {
                        comment.draft_response = disc.recommended_response;
                        if (comment.status === 'pending') comment.status = 'in_progress';
                        applied++;
                    }
                }
            }

            saveProgress();
            updateSidebar();
            alert(`Applied ${applied} expert responses as drafts!`);
        }

        function exportExpertReport() {
            if (!expertDiscussions) return;

            let report = '# Expert Review Analysis Report\n\n';
            report += `Generated: ${new Date().toISOString()}\n\n`;
            report += '## Data Summary\n';
            report += `- Taxonomic entries: ${expertDiscussions.data_sources.taxonomic_entries}\n`;
            report += `- Mean damage (ancient): ${(expertDiscussions.data_sources.mean_damage_ancient * 100).toFixed(1)}%\n`;
            report += `- Mean damage (controls): ${(expertDiscussions.data_sources.mean_damage_controls * 100).toFixed(1)}%\n`;
            report += `- Differential: ${expertDiscussions.data_sources.damage_differential}x\n\n`;

            const ids = Object.keys(expertDiscussions.expert_discussions).sort();
            for (const id of ids) {
                const disc = expertDiscussions.expert_discussions[id];
                report += `## ${id} (${disc.type}, ${disc.priority} priority)\n\n`;
                report += `**Reviewer Comment:** ${disc.reviewer_comment}\n\n`;
                report += `**Category:** ${disc.category}\n\n`;
                if (disc.experts && disc.experts.length > 0) {
                    report += '**Expert Analysis:**\n';
                    for (const e of disc.experts) {
                        report += `- ${e.name}: ${e.verdict}\n`;
                    }
                    report += '\n';
                }
                report += `**Recommended Response:**\n${disc.recommended_response}\n\n`;
                if (disc.advice_to_author) {
                    report += `**Advice:** ${disc.advice_to_author}\n\n`;
                }
                report += '---\n\n';
            }

            const blob = new Blob([report], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'expert_review_report.md';
            a.click();
            URL.revokeObjectURL(url);
        }

        function copyResponse(commentId) {
            const el = document.getElementById('response-' + commentId);
            if (el) {
                navigator.clipboard.writeText(el.textContent).then(() => {
                    alert('Response copied to clipboard!');
                });
            }
        }

        // =====================================================
        // TASK QUEUE - AI-OPTIMIZED PRODUCTIVITY ORDER
        // =====================================================
        // Uses AI/OpenCode to determine optimal task order based on:
        // - Productivity psychology (momentum, energy management)
        // - Task dependencies and complexity
        // - Quick wins vs deep work balance

        let taskOrderCache = null; // Cache AI-generated order
        let isOptimizingTasks = false;

        async function getAIOptimizedTaskOrder(comments) {
            if (isOptimizingTasks) return comments; // Prevent concurrent calls

            const pendingComments = comments.filter(c => c.status !== 'completed');
            if (pendingComments.length === 0) return comments;

            // Check if we already have AI-generated order in cache
            if (taskOrderCache && taskOrderCache.length === pendingComments.length) {
                return applyAIOrder(pendingComments, taskOrderCache);
            }

            isOptimizingTasks = true;

            try {
                const taskSummaries = pendingComments.map(c => ({
                    id: c.id,
                    type: c.type,
                    priority: c.priority,
                    category: c.category,
                    location: c.location,
                    requires_analysis: c.requires_new_analysis,
                    text_preview: (c.original_text || '').substring(0, 100)
                }));

                const prompt = `You are a productivity expert helping a researcher respond to peer review comments.

ORDER these ${taskSummaries.length} tasks for OPTIMAL PRODUCTIVITY using research-backed strategies:

## PRODUCTIVITY PRINCIPLES TO APPLY:
1. **Quick Wins First (2-3 tasks)**: Start with minor/easy tasks to build momentum and confidence
2. **Peak Energy Tasks Next**: Major/high-priority items when motivation is established
3. **Batch Similar Work**: Group related categories together (e.g., all Figure tasks, all Methods tasks)
4. **Analysis Tasks Together**: Items requiring new analysis should be batched
5. **End with Low Stakes**: Save low-priority minor items for the end when energy wanes

## TASKS TO ORDER:
${JSON.stringify(taskSummaries, null, 2)}

## OUTPUT FORMAT:
Return ONLY a JSON array of task IDs in the recommended order, with a brief reason for each position.
Example: [{"id": "R1-5", "reason": "Quick formatting fix - build momentum"}, {"id": "R2-1", "reason": "Critical methods concern - tackle early"}, ...]

Return the complete ordered list as JSON:`;

                const response = await fetch(`${API_BASE}/ask`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        model: currentModel,
                        stream: false
                    })
                });

                if (!response.ok) {
                    throw new Error('AI optimization failed');
                }

                const result = await response.json();
                const aiResponse = result.response || '';

                // Parse the AI response
                const jsonMatch = aiResponse.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    const orderedTasks = JSON.parse(jsonMatch[0]);
                    taskOrderCache = orderedTasks;
                    return applyAIOrder(pendingComments, orderedTasks);
                }
            } catch (e) {
                console.error('AI task optimization failed:', e);
                showNotification('AI optimization unavailable, using default order', 'warning');
            } finally {
                isOptimizingTasks = false;
            }

            // Fallback: return original order
            return pendingComments;
        }

        function applyAIOrder(comments, aiOrder) {
            // Map AI order to comments with reasons
            const orderedComments = [];
            const commentMap = new Map(comments.map(c => [c.id, c]));

            for (const item of aiOrder) {
                const id = typeof item === 'string' ? item : item.id;
                const reason = typeof item === 'object' ? item.reason : null;
                const comment = commentMap.get(id);
                if (comment) {
                    orderedComments.push({
                        ...comment,
                        _reason: reason || ''
                    });
                    commentMap.delete(id);
                }
            }

            // Add any remaining comments not in AI order
            for (const comment of commentMap.values()) {
                orderedComments.push(comment);
            }

            return orderedComments;
        }

        // Simple fallback ordering when AI is unavailable
        function getSimpleTaskOrder(comments) {
            return [...comments].sort((a, b) => {
                // Sort by: completed last, then by priority (high first), then by type (major first)
                if (a.status === 'completed' && b.status !== 'completed') return 1;
                if (b.status === 'completed' && a.status !== 'completed') return -1;

                const priorityOrder = { high: 0, medium: 1, low: 2 };
                const typeOrder = { major: 0, minor: 1 };

                const priorityDiff = (priorityOrder[a.priority] || 1) - (priorityOrder[b.priority] || 1);
                if (priorityDiff !== 0) return priorityDiff;

                return (typeOrder[a.type] || 1) - (typeOrder[b.type] || 1);
            });
        }

        let draggedTaskId = null;

        async function renderTaskQueue() {
            const allComments = getAllComments();
            const pendingComments = allComments.filter(c => c.status !== 'completed');
            const completedComments = allComments.filter(c => c.status === 'completed');

            // Check if we have custom ordering (sort_order set)
            const hasCustomOrder = pendingComments.some(c => c.sort_order && c.sort_order > 0);

            // Show loading state first
            document.getElementById('content-area').innerHTML = `
                <div class="flex items-center justify-center py-20">
                    <div class="text-center">
                        <i class="fas fa-spinner fa-spin text-4xl text-blue-500 mb-4"></i>
                        <p class="text-gray-600">${hasCustomOrder ? 'Loading tasks...' : 'AI is optimizing task order...'}</p>
                        <p class="text-sm text-gray-400 mt-2">Analyzing ${pendingComments.length} tasks for optimal productivity</p>
                    </div>
                </div>
            `;

            // Get ordered comments (either custom or AI-optimized)
            let orderedComments;
            if (hasCustomOrder) {
                orderedComments = [...pendingComments].sort((a, b) => (a.sort_order || 0) - (b.sort_order || 0));
            } else if (taskOrderCache) {
                // Use cached AI order
                orderedComments = applyAIOrder(pendingComments, taskOrderCache);
            } else {
                // Fall back to simple order on initial load, AI optimize on button click
                orderedComments = getSimpleTaskOrder(pendingComments);
            }

            const html = `
                <!-- Header with controls -->
                <div class="flex items-center justify-between mb-6">
                    <div>
                        <div class="flex items-center gap-3">
                            <span class="text-2xl font-bold text-gray-800">${pendingComments.length}</span>
                            <span class="text-gray-500">tasks remaining</span>
                            ${completedComments.length > 0 ? `
                                <span class="text-sm text-green-600 bg-green-50 px-2 py-1 rounded-full">
                                    <i class="fas fa-check mr-1"></i>${completedComments.length} completed
                                </span>
                            ` : ''}
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="optimizeTasksWithAI()" id="ai-optimize-btn" class="px-3 py-1.5 text-sm border border-purple-300 bg-purple-50 text-purple-700 rounded-lg hover:bg-purple-100">
                            <i class="fas fa-wand-magic-sparkles mr-1"></i>AI Optimize
                        </button>
                        <button onclick="saveTaskOrder()" class="px-3 py-1.5 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700">
                            <i class="fas fa-save mr-1"></i>Save Order
                        </button>
                    </div>
                </div>

                <!-- Productivity tip -->
                <div class="mb-6 bg-gradient-to-r from-purple-50 to-blue-50 border border-purple-200 rounded-xl p-4">
                    <div class="flex items-start gap-3">
                        <div class="w-10 h-10 bg-purple-100 rounded-full flex items-center justify-center flex-shrink-0">
                            <i class="fas fa-lightbulb text-purple-600"></i>
                        </div>
                        <div>
                            <h4 class="font-semibold text-gray-800">Productivity Strategy</h4>
                            <p class="text-sm text-gray-600 mt-1">
                                ${taskOrderCache ? 'AI has ordered tasks for optimal productivity.' : 'Click "AI Optimize" to have AI order tasks for optimal productivity.'}
                                Start with quick wins to build momentum, tackle critical items while energy is high. Drag to customize.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Task list with drag-drop -->
                <div id="task-queue-list" class="space-y-2">
                    ${orderedComments.map((c, idx) => `
                        <div class="task-queue-item bg-white border border-gray-200 rounded-xl p-4 cursor-move hover:shadow-md transition-all ${c.status === 'in_progress' ? 'ring-2 ring-blue-400' : ''}"
                             draggable="true"
                             data-task-id="${c.id}"
                             ondragstart="handleTaskDragStart(event)"
                             ondragover="handleTaskDragOver(event)"
                             ondrop="handleTaskDrop(event)"
                             ondragend="handleTaskDragEnd(event)">
                            <div class="flex items-start gap-4">
                                <!-- Drag handle and position -->
                                <div class="flex flex-col items-center">
                                    <span class="text-xs text-gray-400 mb-1">#${idx + 1}</span>
                                    <i class="fas fa-grip-vertical text-gray-300"></i>
                                </div>

                                <!-- Status checkbox -->
                                <div class="pt-1">
                                    <button onclick="toggleTaskStatus('${c.id}')"
                                            class="w-6 h-6 rounded-full border-2 flex items-center justify-center transition-all
                                                   ${c.status === 'completed' ? 'bg-green-500 border-green-500 text-white' :
                                                     c.status === 'in_progress' ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-blue-400'}">
                                        ${c.status === 'completed' ? '<i class="fas fa-check text-xs"></i>' :
                                          c.status === 'in_progress' ? '<div class="w-2 h-2 bg-blue-500 rounded-full"></div>' : ''}
                                    </button>
                                </div>

                                <!-- Task content -->
                                <div class="flex-1 min-w-0">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span class="px-2 py-0.5 text-xs font-medium rounded-full
                                               ${c.type === 'major' ? 'bg-red-100 text-red-700' : 'bg-gray-100 text-gray-600'}">
                                            ${c.type}
                                        </span>
                                        <span class="px-2 py-0.5 text-xs font-medium rounded-full
                                               ${c.priority === 'high' ? 'bg-orange-100 text-orange-700' :
                                                 c.priority === 'medium' ? 'bg-yellow-100 text-yellow-700' : 'bg-green-100 text-green-700'}">
                                            ${c.priority}
                                        </span>
                                        <span class="text-xs text-gray-400">${c.category || 'General'}</span>
                                        ${c._reason ? `<span class="text-xs text-purple-500 italic">${c._reason}</span>` : ''}
                                    </div>
                                    <p class="text-sm text-gray-700 line-clamp-2 ${c.status === 'completed' ? 'line-through text-gray-400' : ''}">
                                        ${(c.original_text || '').substring(0, 150)}${(c.original_text || '').length > 150 ? '...' : ''}
                                    </p>
                                    <div class="flex items-center gap-3 mt-2">
                                        <span class="text-xs text-gray-400">
                                            <i class="fas fa-user mr-1"></i>${c._reviewerName || 'Reviewer'}
                                        </span>
                                        ${c.location ? `<span class="text-xs text-gray-400"><i class="fas fa-map-marker-alt mr-1"></i>${c.location}</span>` : ''}
                                        ${c.requires_new_analysis ? `<span class="text-xs text-blue-500"><i class="fas fa-flask mr-1"></i>Needs analysis</span>` : ''}
                                    </div>
                                </div>

                                <!-- Actions -->
                                <div class="flex items-center gap-2">
                                    <button onclick="openCommentForEdit('${c.id}')"
                                            class="px-3 py-1.5 text-xs bg-blue-50 text-blue-600 rounded-lg hover:bg-blue-100">
                                        <i class="fas fa-edit mr-1"></i>Respond
                                    </button>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>

                ${completedComments.length > 0 ? `
                    <!-- Completed section -->
                    <div class="mt-8">
                        <button onclick="toggleCompletedTasks()" class="flex items-center gap-2 text-gray-500 hover:text-gray-700 mb-4">
                            <i class="fas fa-chevron-down" id="completed-toggle-icon"></i>
                            <span>Completed tasks (${completedComments.length})</span>
                        </button>
                        <div id="completed-tasks-list" class="space-y-2 hidden">
                            ${completedComments.map(c => `
                                <div class="bg-gray-50 border border-gray-200 rounded-xl p-4 opacity-60">
                                    <div class="flex items-start gap-4">
                                        <div class="pt-1">
                                            <button onclick="toggleTaskStatus('${c.id}')"
                                                    class="w-6 h-6 rounded-full bg-green-500 border-2 border-green-500 text-white flex items-center justify-center">
                                                <i class="fas fa-check text-xs"></i>
                                            </button>
                                        </div>
                                        <div class="flex-1">
                                            <p class="text-sm text-gray-500 line-through">
                                                ${(c.original_text || '').substring(0, 100)}...
                                            </p>
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
            `;

            document.getElementById('content-area').innerHTML = html;
        }

        function handleTaskDragStart(e) {
            draggedTaskId = e.target.dataset.taskId;
            e.target.classList.add('opacity-50', 'border-blue-400');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleTaskDragOver(e) {
            e.preventDefault();
            const item = e.target.closest('.task-queue-item');
            if (item && item.dataset.taskId !== draggedTaskId) {
                item.classList.add('border-blue-400', 'bg-blue-50');
            }
        }

        function handleTaskDrop(e) {
            e.preventDefault();
            const targetItem = e.target.closest('.task-queue-item');
            if (!targetItem || targetItem.dataset.taskId === draggedTaskId) return;

            const targetId = targetItem.dataset.taskId;

            // Reorder in reviewData
            const allComments = getAllComments();
            const draggedIdx = allComments.findIndex(c => c.id === draggedTaskId);
            const targetIdx = allComments.findIndex(c => c.id === targetId);

            if (draggedIdx === -1 || targetIdx === -1) return;

            // Update sort_order for all pending tasks
            const pendingComments = allComments.filter(c => c.status !== 'completed');
            const draggedComment = pendingComments.find(c => c.id === draggedTaskId);
            const targetComment = pendingComments.find(c => c.id === targetId);

            if (!draggedComment || !targetComment) return;

            // Get current order
            const currentOrder = pendingComments
                .sort((a, b) => (a.sort_order || 0) - (b.sort_order || 0))
                .map(c => c.id);

            // Remove dragged and insert at target position
            const draggedOrderIdx = currentOrder.indexOf(draggedTaskId);
            const targetOrderIdx = currentOrder.indexOf(targetId);

            currentOrder.splice(draggedOrderIdx, 1);
            currentOrder.splice(targetOrderIdx, 0, draggedTaskId);

            // Update sort_order for all
            currentOrder.forEach((id, idx) => {
                const comment = findCommentById(id);
                if (comment) {
                    comment.sort_order = idx + 1;
                }
            });

            // Re-render
            renderTaskQueue();
            scheduleAutoSave();
        }

        function handleTaskDragEnd(e) {
            document.querySelectorAll('.task-queue-item').forEach(item => {
                item.classList.remove('opacity-50', 'border-blue-400', 'bg-blue-50');
            });
            draggedTaskId = null;
        }

        function toggleTaskStatus(commentId) {
            const comment = findCommentById(commentId);
            if (!comment) return;

            // Cycle: pending -> in_progress -> completed -> pending
            if (comment.status === 'pending') {
                comment.status = 'in_progress';
            } else if (comment.status === 'in_progress') {
                comment.status = 'completed';
            } else {
                comment.status = 'pending';
            }

            renderTaskQueue();
            scheduleAutoSave();
        }

        function toggleCompletedTasks() {
            const list = document.getElementById('completed-tasks-list');
            const icon = document.getElementById('completed-toggle-icon');
            if (list.classList.contains('hidden')) {
                list.classList.remove('hidden');
                icon.classList.remove('fa-chevron-down');
                icon.classList.add('fa-chevron-up');
            } else {
                list.classList.add('hidden');
                icon.classList.remove('fa-chevron-up');
                icon.classList.add('fa-chevron-down');
            }
        }

        async function optimizeTasksWithAI() {
            const btn = document.getElementById('ai-optimize-btn');
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>Optimizing...';
            }

            try {
                // Clear custom order and cache
                const allComments = getAllComments();
                allComments.forEach(c => {
                    c.sort_order = 0;
                });
                taskOrderCache = null;

                // Get AI optimization
                const pendingComments = allComments.filter(c => c.status !== 'completed');
                const optimizedComments = await getAIOptimizedTaskOrder(pendingComments);

                // Apply the new order
                optimizedComments.forEach((c, idx) => {
                    const originalComment = findCommentById(c.id);
                    if (originalComment) {
                        originalComment.sort_order = idx + 1;
                    }
                });

                await renderTaskQueue();
                scheduleAutoSave();
                showNotification('Tasks reordered by AI for optimal productivity', 'success');
            } catch (e) {
                console.error('AI optimization failed:', e);
                showNotification('AI optimization failed, using default order', 'error');
                await renderTaskQueue();
            } finally {
                const btn = document.getElementById('ai-optimize-btn');
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-wand-magic-sparkles mr-1"></i>AI Optimize';
                }
            }
        }

        function resetTaskOrder() {
            // Clear all sort_order values to reset to default
            const allComments = getAllComments();
            allComments.forEach(c => {
                c.sort_order = 0;
            });
            taskOrderCache = null;
            renderTaskQueue();
            scheduleAutoSave();
            showNotification('Task order reset', 'success');
        }

        async function saveTaskOrder() {
            await saveCommentsToDb();
            showNotification('Task order saved', 'success');
        }

        function openCommentForEdit(commentId) {
            openModal(commentId);
        }

        // Render Export
        function renderExport() {
            const allComments = getAllComments();
            const completed = allComments.filter(c => c.status === 'completed');

            const html = `
                <!-- Manuscript Editing Feature - Main Action -->
                <div class="mb-8 bg-gradient-to-r from-indigo-600 to-purple-600 rounded-xl p-6 text-white shadow-lg">
                    <div class="flex items-start gap-4">
                        <div class="w-14 h-14 bg-white bg-opacity-20 rounded-full flex items-center justify-center flex-shrink-0">
                            <i class="fas fa-magic text-2xl"></i>
                        </div>
                        <div class="flex-1">
                            <h3 class="text-xl font-bold mb-2">Auto-Edit Manuscript</h3>
                            <p class="text-white text-opacity-90 mb-4">
                                Automatically apply reviewer-requested changes to your manuscript with track changes.
                                OpenCode will edit terminology, fix framing issues, and improve scientific accuracy while preserving your data and conclusions.
                            </p>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-4">
                                <div class="bg-white bg-opacity-20 rounded-lg p-3 text-center">
                                    <div class="text-2xl font-bold">8</div>
                                    <div class="text-xs text-white text-opacity-80">Changes Applied</div>
                                </div>
                                <div class="bg-white bg-opacity-20 rounded-lg p-3 text-center">
                                    <div class="text-2xl font-bold">5</div>
                                    <div class="text-xs text-white text-opacity-80">Terminology Fixes</div>
                                </div>
                                <div class="bg-white bg-opacity-20 rounded-lg p-3 text-center">
                                    <div class="text-2xl font-bold">2</div>
                                    <div class="text-xs text-white text-opacity-80">Period Corrections</div>
                                </div>
                                <div class="bg-white bg-opacity-20 rounded-lg p-3 text-center">
                                    <div class="text-2xl font-bold">1</div>
                                    <div class="text-xs text-white text-opacity-80">Method Fix</div>
                                </div>
                            </div>
                            <div class="flex flex-wrap gap-3">
                                <a href="#" id="download-revised-link" download
                                   class="px-6 py-3 bg-white text-indigo-600 rounded-lg font-semibold hover:bg-opacity-90 transition-colors">
                                    <i class="fas fa-download mr-2"></i>Download Revised Manuscript
                                </a>
                                <button onclick="showEditDetails()" class="px-6 py-3 bg-white bg-opacity-20 rounded-lg font-semibold hover:bg-opacity-30 transition-colors">
                                    <i class="fas fa-list mr-2"></i>View Changes
                                </button>
                                <button onclick="requestNewEdit()" class="px-6 py-3 bg-white bg-opacity-20 rounded-lg font-semibold hover:bg-opacity-30 transition-colors">
                                    <i class="fas fa-redo mr-2"></i>Request New Edit
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-white rounded-xl p-6 shadow-sm border border-gray-100">
                        <h3 class="font-semibold text-gray-800 mb-4">
                            <i class="fas fa-file-word text-blue-600 mr-2"></i>Export Response Document
                        </h3>
                        <p class="text-sm text-gray-600 mb-4">Generate a formatted response letter with all your reviewer responses.</p>
                        <div class="space-y-3 mb-4">
                            <label class="flex items-center gap-2">
                                <input type="checkbox" checked id="export-completed" class="rounded">
                                <span class="text-sm">Include completed responses (${completed.length})</span>
                            </label>
                            <label class="flex items-center gap-2">
                                <input type="checkbox" id="export-draft" class="rounded">
                                <span class="text-sm">Include draft responses</span>
                            </label>
                            <label class="flex items-center gap-2">
                                <input type="checkbox" checked id="export-original" class="rounded">
                                <span class="text-sm">Include original reviewer comments</span>
                            </label>
                        </div>
                        <button onclick="exportToWord()" class="w-full px-4 py-3 export-btn text-white rounded-lg font-medium">
                            <i class="fas fa-download mr-2"></i>Generate Response Document
                        </button>
                    </div>

                    <div class="bg-white rounded-xl p-6 shadow-sm border border-gray-100">
                        <h3 class="font-semibold text-gray-800 mb-4">
                            <i class="fas fa-file-code text-green-600 mr-2"></i>Export JSON Data
                        </h3>
                        <p class="text-sm text-gray-600 mb-4">Export all review data as JSON for backup or import into another platform.</p>
                        <button onclick="exportJSON()" class="w-full px-4 py-3 bg-green-600 text-white rounded-lg font-medium hover:bg-green-700">
                            <i class="fas fa-download mr-2"></i>Download JSON
                        </button>
                    </div>

                    <div class="bg-white rounded-xl p-6 shadow-sm border border-gray-100">
                        <h3 class="font-semibold text-gray-800 mb-4">
                            <i class="fas fa-chart-bar text-purple-600 mr-2"></i>Export Summary Report
                        </h3>
                        <p class="text-sm text-gray-600 mb-4">Generate a summary report of the review process and responses.</p>
                        <button onclick="exportSummary()" class="w-full px-4 py-3 bg-purple-600 text-white rounded-lg font-medium hover:bg-purple-700">
                            <i class="fas fa-file-alt mr-2"></i>Generate Summary
                        </button>
                    </div>

                    <div class="bg-white rounded-xl p-6 shadow-sm border border-gray-100">
                        <h3 class="font-semibold text-gray-800 mb-4">
                            <i class="fas fa-sync text-teal-600 mr-2"></i>Sync Progress
                        </h3>
                        <p class="text-sm text-gray-600 mb-4">Save your progress to browser storage or load previous work.</p>
                        <div class="flex gap-3">
                            <button onclick="saveProgress()" class="flex-1 px-4 py-3 bg-teal-600 text-white rounded-lg font-medium hover:bg-teal-700">
                                <i class="fas fa-save mr-2"></i>Save
                            </button>
                            <button onclick="loadNewManuscript()" class="flex-1 px-4 py-3 bg-gray-100 text-gray-700 rounded-lg font-medium hover:bg-gray-200">
                                <i class="fas fa-upload mr-2"></i>Load
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Changes Applied Section -->
                <div id="edit-details" class="mt-6 bg-white rounded-xl p-6 shadow-sm border border-gray-100 hidden">
                    <h3 class="font-semibold text-gray-800 mb-4">
                        <i class="fas fa-check-circle text-green-600 mr-2"></i>Track Changes Applied
                    </h3>
                    <div class="space-y-3">
                        <div class="flex items-start gap-3 p-3 bg-green-50 rounded-lg">
                            <span class="px-2 py-1 text-xs bg-green-200 text-green-800 rounded">R1-3a</span>
                            <div>
                                <p class="text-sm font-medium text-gray-800">Replaced "time-traveling" with "long-dormant"</p>
                                <p class="text-xs text-gray-500">Present terminology as hypothesis rather than established fact</p>
                            </div>
                        </div>
                        <div class="flex items-start gap-3 p-3 bg-green-50 rounded-lg">
                            <span class="px-2 py-1 text-xs bg-green-200 text-green-800 rounded">R1-3b</span>
                            <div>
                                <p class="text-sm font-medium text-gray-800">Replaced "time-travelling" with "long-dormant"</p>
                                <p class="text-xs text-gray-500">British spelling variant also updated</p>
                            </div>
                        </div>
                        <div class="flex items-start gap-3 p-3 bg-green-50 rounded-lg">
                            <span class="px-2 py-1 text-xs bg-green-200 text-green-800 rounded">R3-1a</span>
                            <div>
                                <p class="text-sm font-medium text-gray-800">Replaced "pioneer microbial communities" with "depositional-era microbial communities"</p>
                                <p class="text-xs text-gray-500">More neutral, scientifically precise terminology</p>
                            </div>
                        </div>
                        <div class="flex items-start gap-3 p-3 bg-green-50 rounded-lg">
                            <span class="px-2 py-1 text-xs bg-green-200 text-green-800 rounded">R3-1b</span>
                            <div>
                                <p class="text-sm font-medium text-gray-800">Replaced "pioneer methanogens" with "ancient methanogens"</p>
                                <p class="text-xs text-gray-500">Avoids loaded "pioneer" terminology</p>
                            </div>
                        </div>
                        <div class="flex items-start gap-3 p-3 bg-green-50 rounded-lg">
                            <span class="px-2 py-1 text-xs bg-green-200 text-green-800 rounded">R3-1c</span>
                            <div>
                                <p class="text-sm font-medium text-gray-800">Replaced "pioneering microbes" with "depositional-era microbes"</p>
                                <p class="text-xs text-gray-500">Consistent terminology throughout</p>
                            </div>
                        </div>
                        <div class="flex items-start gap-3 p-3 bg-blue-50 rounded-lg">
                            <span class="px-2 py-1 text-xs bg-blue-200 text-blue-800 rounded">R1-5</span>
                            <div>
                                <p class="text-sm font-medium text-gray-800">Replaced "Pliocene/Pleistocene transition" with "Early Pleistocene interglacial"</p>
                                <p class="text-xs text-gray-500">Correct geological period based on dating evidence</p>
                            </div>
                        </div>
                        <div class="flex items-start gap-3 p-3 bg-purple-50 rounded-lg">
                            <span class="px-2 py-1 text-xs bg-purple-200 text-purple-800 rounded">R1-29</span>
                            <div>
                                <p class="text-sm font-medium text-gray-800">Removed "novel" from "novel method"</p>
                                <p class="text-xs text-gray-500">Appropriate for describing cited methods</p>
                            </div>
                        </div>
                        <div class="flex items-start gap-3 p-3 bg-purple-50 rounded-lg">
                            <span class="px-2 py-1 text-xs bg-purple-200 text-purple-800 rounded">R1-29b</span>
                            <div>
                                <p class="text-sm font-medium text-gray-800">Removed "novel" from "novel approach"</p>
                                <p class="text-xs text-gray-500">Consistent modesty in method descriptions</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="mt-6 bg-white rounded-xl p-6 shadow-sm border border-gray-100">
                    <h3 class="font-semibold text-gray-800 mb-4">Response Preview</h3>
                    <div class="bg-gray-50 rounded-lg p-4 max-h-96 overflow-auto">
                        <div id="response-preview" class="prose prose-sm max-w-none">
                            ${generateResponsePreview()}
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('content-area').innerHTML = html;
        }

        function showEditDetails() {
            const details = document.getElementById('edit-details');
            details.classList.toggle('hidden');
        }

        function requestNewEdit() {
            const prompt = "Please generate a new revised manuscript addressing additional reviewer comments. Focus on:\\n1. Any remaining terminology issues\\n2. Abstract/introduction/conclusion alignment\\n3. Scientific accuracy improvements\\n4. Any specific comments I mark as 'ready for edit'";
            copyPrompt(prompt);
            alert('Prompt copied! Paste it in the chat to request specific manuscript edits.');
        }

        function generateResponsePreview() {
            let preview = '<h2>Response to Reviewers</h2>';
            reviewData.reviewers.forEach(reviewer => {
                preview += `<h3>${reviewer.name}</h3>`;
                reviewer.comments.forEach(comment => {
                    if (comment.draft_response) {
                        preview += `
                            <div class="mb-4">
                                <p><strong>Comment ${comment.id}:</strong> ${comment.original_text.substring(0, 100)}...</p>
                                <p><em>Response:</em> ${comment.draft_response}</p>
                            </div>
                        `;
                    }
                });
            });
            return preview;
        }

        // Helper functions
        function getStatusClass(status) {
            const classes = {
                'completed': 'bg-green-100 text-green-700',
                'in_progress': 'bg-blue-100 text-blue-700',
                'pending': 'bg-yellow-100 text-yellow-700'
            };
            return classes[status] || classes['pending'];
        }

        function getTypeClass(type) {
            return type === 'major' ? 'bg-red-100 text-red-700' : 'bg-gray-100 text-gray-700';
        }

        // Filter functions
        function filterByPriority(priority) {
            currentFilter = { type: 'priority', value: priority };
            setView('comments');
        }

        function filterByType(type) {
            currentFilter = { type: 'type', value: type };
            setView('comments');
        }

        function filterByCategory(category) {
            currentFilter = { type: 'category', value: category };
            setView('comments');
        }

        function filterByAnalysis(value) {
            currentFilter = { type: 'analysis', value: value };
            setView('comments');
        }

        function clearFilter() {
            currentFilter = null;
            setView('comments');
        }

        function searchComments(query) {
            // Implement search functionality
            if (!query) {
                setView(currentView);
                return;
            }
            // Filter and display matching comments
        }

        // Comment operations
        function setCommentStatus(reviewerId, commentId, status) {
            const reviewer = reviewData.reviewers.find(r => r.id === reviewerId);
            if (reviewer) {
                const comment = reviewer.comments.find(c => c.id === commentId);
                if (comment) {
                    comment.status = status;
                    updateSidebar();
                    setView(currentView);
                    scheduleAutoSave(); // Auto-save to database after status change
                }
            }
        }

        function openCommentModal(reviewerId, commentId) {
            const reviewer = reviewData.reviewers.find(r => r.id === reviewerId);
            const comment = reviewer?.comments.find(c => c.id === commentId);
            if (!comment) return;

            editingComment = { reviewerId, commentId };
            document.getElementById('modal-title').textContent = `Response Builder - ${comment.id}`;

            // Initialize actions_taken if not present
            if (!comment.actions_taken) comment.actions_taken = [];
            if (!comment.potential_solutions) comment.potential_solutions = generatePotentialSolutions(comment);

            document.getElementById('modal-content').innerHTML = `
                <!-- Original Comment - Full Width at Top -->
                <div class="bg-white rounded-xl border border-gray-200 p-4 mb-4 shadow-sm">
                    <div class="flex items-start justify-between mb-3">
                        <label class="text-sm font-semibold text-gray-800 flex items-center gap-2">
                            <div class="w-8 h-8 bg-blue-100 rounded-lg flex items-center justify-center">
                                <i class="fas fa-comment-alt text-blue-600"></i>
                            </div>
                            Reviewer Comment
                        </label>
                        <div class="flex flex-wrap gap-2">
                            ${comment.location && comment.location !== 'null' ? `<span class="bg-gray-100 text-gray-600 px-2 py-1 rounded-lg text-xs"><i class="fas fa-map-marker-alt mr-1"></i>${comment.location}</span>` : ''}
                            <span class="bg-purple-100 text-purple-700 px-2 py-1 rounded-lg text-xs"><i class="fas fa-tag mr-1"></i>${comment.type || 'general'}</span>
                            <span class="bg-blue-100 text-blue-700 px-2 py-1 rounded-lg text-xs"><i class="fas fa-folder mr-1"></i>${comment.category || 'Uncategorized'}</span>
                        </div>
                    </div>
                    <div class="bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-100 rounded-lg p-4 text-sm text-gray-700 leading-relaxed">${comment.original_text}</div>
                </div>

                <!-- Two Column Layout -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                    <!-- Left Column: Solutions & AI -->
                    <div class="space-y-4">
                        <!-- Potential Solutions Box -->
                        <div class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm">
                            <label class="text-sm font-semibold text-gray-800 mb-3 flex items-center gap-2">
                                <div class="w-8 h-8 bg-amber-100 rounded-lg flex items-center justify-center">
                                    <i class="fas fa-lightbulb text-amber-600"></i>
                                </div>
                                Potential Solutions
                            </label>
                            <div class="space-y-1 mt-3 max-h-40 overflow-y-auto" id="solutions-checklist">
                                ${comment.potential_solutions.length > 0 ? comment.potential_solutions.map((sol, idx) => `
                                    <label class="flex items-start gap-2 p-2 rounded-lg hover:bg-amber-50 cursor-pointer text-sm">
                                        <input type="checkbox" class="mt-0.5 rounded solution-checkbox"
                                               data-idx="${idx}"
                                               ${comment.actions_taken.includes(sol) ? 'checked' : ''}
                                               onchange="toggleSolution(${idx})">
                                        <span class="text-gray-700">${sol}</span>
                                    </label>
                                `).join('') : '<p class="text-gray-400 text-sm italic">No suggested solutions for this comment type</p>'}
                            </div>
                            <div class="mt-3 pt-3 border-t border-gray-100">
                                <input type="text" id="custom-solution" placeholder="Add custom action..."
                                       class="w-full px-3 py-2 text-sm border border-gray-200 rounded-lg bg-gray-50 focus:bg-white focus:border-amber-400 focus:ring-2 focus:ring-amber-100"
                                       onkeypress="if(event.key==='Enter')addCustomSolution()">
                            </div>
                        </div>

                        <!-- Actions Taken Summary -->
                        <div class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm">
                            <label class="text-sm font-semibold text-gray-800 mb-2 flex items-center gap-2">
                                <div class="w-8 h-8 bg-green-100 rounded-lg flex items-center justify-center">
                                    <i class="fas fa-check-circle text-green-600"></i>
                                </div>
                                Actions Taken
                            </label>
                            <div id="actions-taken-list" class="text-sm text-gray-700 mt-3">
                                ${comment.actions_taken.length > 0
                                    ? '<ul class="space-y-1">' + comment.actions_taken.map(a => `<li class="flex items-start gap-2"><i class="fas fa-check text-green-500 mt-1 text-xs"></i><span>${a}</span></li>`).join('') + '</ul>'
                                    : '<p class="text-gray-400 italic text-sm">Check solutions above to add actions</p>'}
                            </div>
                        </div>

                        <!-- Ask OpenCode -->
                        <div class="bg-gradient-to-br from-emerald-50 to-teal-50 rounded-xl border border-emerald-200 p-4">
                            <div class="flex items-center justify-between mb-3">
                                <label class="text-sm font-medium text-gray-700 flex items-center gap-2">
                                    <div class="w-7 h-7 bg-blue-100 rounded flex items-center justify-center">
                                        <i class="fas fa-pen-nib text-blue-600 text-xs"></i>
                                    </div>
                                    Draft response
                                </label>
                                <span id="ws-status-modal" class="text-xs px-2 py-1 rounded-full bg-gray-100 text-gray-600">
                                    <i class="fas fa-circle text-[8px] mr-1 text-green-500"></i>Ready
                                </span>
                            </div>

                            <!-- Skills Selection -->
                            <div class="mb-3">
                                <div class="flex flex-wrap gap-1.5" id="skill-checkboxes">
                                    <label class="inline-flex items-center bg-white border border-gray-200 rounded-lg px-2 py-1 text-xs cursor-pointer hover:border-emerald-400 transition-colors">
                                        <input type="checkbox" class="skill-checkbox mr-1.5 rounded" value="manuscript-reviewer" checked>
                                        <span>Reviewer</span>
                                    </label>
                                    <label class="inline-flex items-center bg-white border border-gray-200 rounded-lg px-2 py-1 text-xs cursor-pointer hover:border-emerald-400 transition-colors">
                                        <input type="checkbox" class="skill-checkbox mr-1.5 rounded" value="dna-damage-auth" id="skill-dna">
                                        <span>DNA Auth</span>
                                    </label>
                                    <label class="inline-flex items-center bg-white border border-gray-200 rounded-lg px-2 py-1 text-xs cursor-pointer hover:border-emerald-400 transition-colors">
                                        <input type="checkbox" class="skill-checkbox mr-1.5 rounded" value="microbial-ecology" id="skill-ecology">
                                        <span>Ecology</span>
                                    </label>
                                    <label class="inline-flex items-center bg-white border border-gray-200 rounded-lg px-2 py-1 text-xs cursor-pointer hover:border-emerald-400 transition-colors">
                                        <input type="checkbox" class="skill-checkbox mr-1.5 rounded" value="phylogenetics-evolution" id="skill-phylo">
                                        <span>Evolution</span>
                                    </label>
                                    <label class="inline-flex items-center bg-white border border-gray-200 rounded-lg px-2 py-1 text-xs cursor-pointer hover:border-emerald-400 transition-colors">
                                        <input type="checkbox" class="skill-checkbox mr-1.5 rounded" value="ancient-virome" id="skill-virome">
                                        <span>Virome</span>
                                    </label>
                                    <label class="inline-flex items-center bg-white border border-gray-200 rounded-lg px-2 py-1 text-xs cursor-pointer hover:border-emerald-400 transition-colors">
                                        <input type="checkbox" class="skill-checkbox mr-1.5 rounded" value="bioinformatics-methods" id="skill-methods">
                                        <span>Methods</span>
                                    </label>
                                </div>
                            </div>

                            <!-- Context Status -->
                            <div class="mb-3 p-2 rounded-lg flex items-center justify-between ${contextLoaded ? 'bg-emerald-100' : 'bg-amber-100'}" id="ask-context-status">
                                <div class="flex items-center gap-2">
                                    <span class="w-2 h-2 rounded-full ${contextLoaded ? 'bg-emerald-500' : 'bg-amber-500'}" id="ask-context-dot"></span>
                                    <span class="text-xs ${contextLoaded ? 'text-emerald-700' : 'text-amber-700'}" id="ask-context-text">
                                        ${contextLoaded ? 'Context loaded' : 'No context'}
                                    </span>
                                </div>
                                <button onclick="openContextModal()" class="text-xs text-blue-600 hover:underline font-medium">
                                    ${contextLoaded ? 'Reload' : 'Load Context'}
                                </button>
                            </div>

                            <div class="flex items-center justify-between mb-3 text-xs text-gray-600">
                                <span>Model: <strong id="current-model-display">gpt-5.2</strong></span>
                                <a href="#" onclick="openSettingsModal(); return false;" class="text-emerald-600 hover:underline">Change</a>
                            </div>

                            <button onclick="askOpenCodeForResponse()"
                                    class="w-full px-4 py-3 bg-gradient-to-r from-emerald-600 to-teal-600 text-white rounded-xl font-medium hover:from-emerald-700 hover:to-teal-700 shadow-sm transition-all"
                                    id="ask-opencode-btn">
                                <i class="fas fa-magic mr-2"></i>Generate Response
                            </button>
                            <div id="opencode-loading" class="hidden mt-3 text-center py-3">
                                <i class="fas fa-spinner fa-spin text-emerald-500 text-xl mb-2"></i>
                                <p class="text-sm text-gray-600">Generating response...</p>
                            </div>
                        </div>
                    </div>

                    <!-- Right Column: Response Editor & Preview -->
                    <div class="space-y-4">
                        <!-- Response Editor -->
                        <div class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm">
                            <div class="flex items-center justify-between mb-3">
                                <label class="text-sm font-semibold text-gray-800 flex items-center gap-2">
                                    <div class="w-8 h-8 bg-indigo-100 rounded-lg flex items-center justify-center">
                                        <i class="fas fa-pen text-indigo-600"></i>
                                    </div>
                                    Your Response
                                </label>
                                <div class="flex items-center gap-2">
                                    <button onclick="showVersionHistory('${comment.id}')" class="text-xs px-2 py-1.5 border border-gray-200 rounded-lg hover:bg-gray-50 text-gray-600" title="View version history">
                                        <i class="fas fa-history mr-1"></i>History
                                    </button>
                                    <select id="edit-status" class="text-xs px-3 py-1.5 border rounded-lg bg-gray-50" onchange="updateCommentStatus(this.value)">
                                        <option value="pending" ${comment.status === 'pending' ? 'selected' : ''}>Pending</option>
                                        <option value="in_progress" ${comment.status === 'in_progress' ? 'selected' : ''}>In Progress</option>
                                        <option value="completed" ${comment.status === 'completed' ? 'selected' : ''}>Completed</option>
                                    </select>
                                </div>
                            </div>
                            <textarea id="edit-response" class="w-full px-4 py-3 border border-gray-200 rounded-xl bg-gray-50 focus:bg-white focus:border-indigo-400 focus:ring-2 focus:ring-indigo-100 transition-all"
                                      style="min-height: 200px;"
                                      placeholder="Your response will appear here...">${comment.draft_response || ''}</textarea>
                        </div>

                        <!-- Preview -->
                        <div class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm">
                            <label class="text-sm font-semibold text-gray-800 mb-3 flex items-center gap-2">
                                <div class="w-8 h-8 bg-gray-100 rounded-lg flex items-center justify-center">
                                    <i class="fas fa-eye text-gray-600"></i>
                                </div>
                                Preview
                            </label>
                            <div id="response-markdown-preview" class="markdown-preview rounded-xl p-4 text-sm prose max-w-none border border-gray-100 bg-gray-50 mt-3" style="min-height: 150px;">
                                ${marked.parse(comment.draft_response || '*Response will appear here*')}
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Add live preview
            document.getElementById('edit-response').addEventListener('input', (e) => {
                document.getElementById('response-markdown-preview').innerHTML = marked.parse(e.target.value || '*Response will appear here*');
            });

            document.getElementById('comment-modal').classList.remove('hidden');

            // Auto-select skills based on comment content
            autoSelectSkills(comment);

            // Update model display
            const modelDisplay = document.getElementById('current-model-display');
            if (modelDisplay) {
                modelDisplay.textContent = aiSettings.model.split('/').pop() || 'GPT-5.2';
            }

            // Update API status in modal
            checkApiConnection();
        }

        function generatePotentialSolutions(comment) {
            // Generate relevant solutions based on comment category and type
            const baseSolutions = [];

            if (comment.requires_new_analysis) {
                comment.analysis_type.forEach(type => {
                    baseSolutions.push(`Performed ${type} analysis`);
                });
            }

            const categorySolutions = {
                'Authentication': [
                    'Added C-to-T deamination plots (Supplementary Figure)',
                    'Performed MapDamage/Pydamage validation',
                    'Added damage threshold justification',
                    'Clarified authentication criteria in Methods'
                ],
                'Terminology': [
                    'Revised terminology throughout manuscript',
                    'Changed "time-traveling" to hypothesis framing',
                    'Replaced "pioneer" with "depositional-era"',
                    'Added clarifying definitions'
                ],
                'Analysis': [
                    'Performed additional statistical analysis',
                    'Added new supplementary figures',
                    'Expanded methods description',
                    'Ran sensitivity analysis'
                ],
                'Methods': [
                    'Clarified methodology in text',
                    'Added parameter justification',
                    'Expanded supplementary methods',
                    'Added workflow diagram'
                ],
                'Interpretation': [
                    'Revised discussion to reflect evidence strength',
                    'Added alternative interpretations',
                    'Moderated claims appropriately',
                    'Added caveats and limitations'
                ],
                'Database': [
                    'Expanded reference database',
                    'Added permafrost metagenome references',
                    'Re-ran source tracking with updated database',
                    'Documented database composition'
                ],
                'Figure': [
                    'Revised figure as requested',
                    'Added statistical annotations',
                    'Improved visualization clarity',
                    'Added to supplementary materials'
                ],
                'Results': [
                    'Added quantitative details',
                    'Expanded results description',
                    'Added supporting statistics',
                    'Moved details to supplement'
                ]
            };

            const catSols = categorySolutions[comment.category] || [];
            return [...baseSolutions, ...catSols].slice(0, 6);
        }

        function toggleSolution(idx) {
            if (!editingComment) return;
            const reviewer = reviewData.reviewers.find(r => r.id === editingComment.reviewerId);
            const comment = reviewer?.comments.find(c => c.id === editingComment.commentId);
            if (!comment) return;

            const solution = comment.potential_solutions[idx];
            if (comment.actions_taken.includes(solution)) {
                comment.actions_taken = comment.actions_taken.filter(a => a !== solution);
            } else {
                comment.actions_taken.push(solution);
            }
            updateActionsTakenDisplay(comment);
        }

        function addCustomSolution() {
            const input = document.getElementById('custom-solution');
            const text = input.value.trim();
            if (!text) return;

            const reviewer = reviewData.reviewers.find(r => r.id === editingComment.reviewerId);
            const comment = reviewer?.comments.find(c => c.id === editingComment.commentId);
            if (!comment) return;

            comment.potential_solutions.push(text);
            comment.actions_taken.push(text);
            input.value = '';

            // Re-render the solutions list
            openCommentModal(editingComment.reviewerId, editingComment.commentId);
        }

        function updateActionsTakenDisplay(comment) {
            const container = document.getElementById('actions-taken-list');
            if (comment.actions_taken.length > 0) {
                container.innerHTML = '<ul class="list-disc list-inside space-y-1">' +
                    comment.actions_taken.map(a => `<li>${a}</li>`).join('') + '</ul>';
            } else {
                container.innerHTML = '<p class="text-gray-400 italic">Check solutions above to add actions</p>';
            }
        }

        function updateCommentStatus(status) {
            if (!editingComment) return;
            const reviewer = reviewData.reviewers.find(r => r.id === editingComment.reviewerId);
            const comment = reviewer?.comments.find(c => c.id === editingComment.commentId);
            if (comment) {
                comment.status = status;
            }
        }

        function closeModal() {
            document.getElementById('comment-modal').classList.add('hidden');
            editingComment = null;
        }

        async function saveComment() {
            if (!editingComment) return;

            const reviewer = reviewData.reviewers.find(r => r.id === editingComment.reviewerId);
            const comment = reviewer?.comments.find(c => c.id === editingComment.commentId);
            if (!comment) return;

            // Get old values for version tracking
            const oldValues = {
                draft_response: comment.draft_response || '',
                status: comment.status || 'pending',
                priority: comment.priority || 'medium',
                type: comment.type || 'minor'
            };

            // Get new values
            const newValues = {
                location: document.getElementById('edit-location').value,
                priority: document.getElementById('edit-priority').value,
                type: document.getElementById('edit-type').value,
                status: document.getElementById('edit-status').value,
                requires_new_analysis: document.getElementById('edit-needs-analysis').checked,
                draft_response: document.getElementById('edit-response').value
            };

            // Track version history for important field changes
            const fieldsToTrack = ['draft_response', 'status'];
            for (const field of fieldsToTrack) {
                if (oldValues[field] !== newValues[field]) {
                    await saveVersionHistoryEntry(
                        comment.id,
                        currentPaperId,
                        field,
                        oldValues[field],
                        newValues[field],
                        'user'
                    );
                }
            }

            // Apply new values
            comment.location = newValues.location;
            comment.priority = newValues.priority;
            comment.type = newValues.type;
            comment.status = newValues.status;
            comment.requires_new_analysis = newValues.requires_new_analysis;
            comment.draft_response = newValues.draft_response;

            // If response changed, check for related comments and notify
            const responseChanged = oldValues.draft_response !== newValues.draft_response && newValues.draft_response.length > 0;
            if (responseChanged) {
                checkRelatedCommentsConsistency(comment.id, newValues.draft_response);
            }

            closeModal();
            updateSidebar();
            setView(currentView);
            scheduleAutoSave(); // Auto-save to database after edit
        }

        // Save version history entry to server
        async function saveVersionHistoryEntry(commentId, paperId, fieldName, oldValue, newValue, source = 'user') {
            try {
                await fetch(`${API_BASE}/db/version`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        comment_id: commentId,
                        paper_id: paperId,
                        field_name: fieldName,
                        old_value: oldValue,
                        new_value: newValue,
                        source: source
                    })
                });
            } catch (e) {
                console.log('Version history save failed:', e);
            }
        }

        // Get version history for a comment
        async function getCommentVersionHistory(commentId) {
            try {
                const response = await fetch(`${API_BASE}/db/version/${encodeURIComponent(commentId)}`);
                if (response.ok) {
                    const result = await response.json();
                    return result.history || [];
                }
            } catch (e) {
                console.log('Failed to load version history:', e);
            }
            return [];
        }

        // Revert to a previous version
        async function revertToVersion(versionId) {
            try {
                const response = await fetch(`${API_BASE}/db/version/revert/${versionId}`, {
                    method: 'POST'
                });
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        // Update local data
                        const comment = findCommentById(result.comment_id);
                        if (comment) {
                            comment[result.field] = result.value;
                        }
                        showNotification('Reverted to previous version', 'success');
                        // Refresh the modal if open
                        if (editingComment && editingComment.commentId === result.comment_id) {
                            openModal(result.comment_id);
                        }
                        return true;
                    }
                }
            } catch (e) {
                console.error('Revert failed:', e);
            }
            showNotification('Failed to revert', 'error');
            return false;
        }

        // Show version history modal
        async function showVersionHistory(commentId) {
            const history = await getCommentVersionHistory(commentId);

            const modal = document.createElement('div');
            modal.id = 'version-history-modal';
            modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-[60] p-4';
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };

            const formatDate = (dateStr) => {
                const date = new Date(dateStr);
                return date.toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            };

            const getSourceIcon = (source) => {
                switch (source) {
                    case 'ai': return '<i class="fas fa-robot text-emerald-500"></i>';
                    case 'revert': return '<i class="fas fa-undo text-amber-500"></i>';
                    default: return '<i class="fas fa-user text-blue-500"></i>';
                }
            };

            const getFieldLabel = (field) => {
                switch (field) {
                    case 'draft_response': return 'Response';
                    case 'status': return 'Status';
                    default: return field;
                }
            };

            modal.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[80vh] overflow-hidden flex flex-col">
                    <div class="p-4 bg-gradient-to-r from-purple-600 to-indigo-600 text-white flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <i class="fas fa-history text-xl"></i>
                            <div>
                                <h3 class="font-bold">Version History</h3>
                                <p class="text-xs opacity-80">${commentId}</p>
                            </div>
                        </div>
                        <button onclick="document.getElementById('version-history-modal').remove()" class="w-8 h-8 flex items-center justify-center rounded-lg hover:bg-white/20">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="flex-1 overflow-y-auto p-4">
                        ${history.length === 0 ? `
                            <div class="text-center py-12 text-gray-400">
                                <i class="fas fa-clock text-4xl mb-3"></i>
                                <p>No version history yet</p>
                                <p class="text-sm mt-1">Changes will be tracked when you edit this response</p>
                            </div>
                        ` : `
                            <div class="space-y-3">
                                ${history.map(v => `
                                    <div class="border border-gray-200 rounded-lg p-3 hover:border-purple-300 transition-colors">
                                        <div class="flex items-center justify-between mb-2">
                                            <div class="flex items-center gap-2">
                                                ${getSourceIcon(v.source)}
                                                <span class="text-sm font-medium text-gray-700">${getFieldLabel(v.field_name)}</span>
                                                <span class="text-xs px-2 py-0.5 bg-gray-100 rounded-full text-gray-500">${v.source}</span>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <span class="text-xs text-gray-400">${formatDate(v.created_at)}</span>
                                                <button onclick="confirmRevert(${v.id}, '${v.field_name}')"
                                                        class="text-xs px-2 py-1 bg-amber-50 text-amber-700 rounded hover:bg-amber-100"
                                                        title="Revert to this version">
                                                    <i class="fas fa-undo mr-1"></i>Revert
                                                </button>
                                            </div>
                                        </div>
                                        ${v.field_name === 'draft_response' ? `
                                            <div class="mt-2 space-y-2">
                                                <div class="bg-red-50 border border-red-100 rounded p-2">
                                                    <div class="text-xs text-red-600 font-medium mb-1">Previous:</div>
                                                    <div class="text-xs text-gray-600 line-clamp-3">${v.old_value || '<em class="text-gray-400">Empty</em>'}</div>
                                                </div>
                                                <div class="bg-green-50 border border-green-100 rounded p-2">
                                                    <div class="text-xs text-green-600 font-medium mb-1">Changed to:</div>
                                                    <div class="text-xs text-gray-600 line-clamp-3">${v.new_value || '<em class="text-gray-400">Empty</em>'}</div>
                                                </div>
                                            </div>
                                        ` : `
                                            <div class="text-sm mt-1">
                                                <span class="text-red-500 line-through">${v.old_value || 'none'}</span>
                                                <i class="fas fa-arrow-right mx-2 text-gray-300"></i>
                                                <span class="text-green-600">${v.new_value || 'none'}</span>
                                            </div>
                                        `}
                                    </div>
                                `).join('')}
                            </div>
                        `}
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // Confirm revert action
        function confirmRevert(versionId, fieldName) {
            if (confirm(`Revert the ${fieldName === 'draft_response' ? 'response' : fieldName} to this previous version?`)) {
                revertToVersion(versionId);
                document.getElementById('version-history-modal')?.remove();
            }
        }

        // Check related comments for consistency after response change
        function checkRelatedCommentsConsistency(commentId, newResponse) {
            const related = getRelatedComments(commentId);
            const relatedWithResponses = [...related.direct, ...related.thematic].filter(c => c.draft_response);

            if (relatedWithResponses.length === 0) return;

            // Flag related comments that might need review
            const needsReview = relatedWithResponses.filter(c => {
                // Check if response mentions different key points
                const currentHasDamageStats = c.draft_response.includes('30.31%') || c.draft_response.includes('28');
                const newHasDamageStats = newResponse.includes('30.31%') || newResponse.includes('28');

                // If one mentions damage stats and the other doesn't in a damage-related category
                if (c.category === 'Authentication' || commentRelationships[commentId]?.groups.includes('dna_damage_authentication')) {
                    if (currentHasDamageStats !== newHasDamageStats) return true;
                }

                return false;
            });

            if (needsReview.length > 0) {
                showRelatedUpdateNotification(commentId, needsReview);
            } else if (relatedWithResponses.length > 0) {
                // Show subtle notification about related comments
                showNotification(`Response saved. ${relatedWithResponses.length} related comments may need review for consistency.`, 'info');
            }
        }

        // Show notification about related comments that may need updates
        function showRelatedUpdateNotification(sourceCommentId, relatedComments) {
            const modal = document.createElement('div');
            modal.id = 'related-update-modal';
            modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50';
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };

            modal.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden">
                    <div class="p-4 bg-gradient-to-r from-amber-500 to-orange-500 text-white">
                        <div class="flex items-center gap-3">
                            <i class="fas fa-exclamation-triangle text-xl"></i>
                            <div>
                                <h3 class="font-bold">Related Comments May Need Updates</h3>
                                <p class="text-sm opacity-80">Your response to ${sourceCommentId} was saved</p>
                            </div>
                        </div>
                    </div>
                    <div class="p-4">
                        <p class="text-sm text-gray-600 mb-3">
                            The following related comments may need to be reviewed for consistency:
                        </p>
                        <div class="space-y-2 max-h-60 overflow-y-auto">
                            ${relatedComments.map(c => `
                                <div class="p-3 bg-amber-50 rounded-lg border border-amber-200 cursor-pointer hover:bg-amber-100"
                                     onclick="openCommentModal('${c.reviewerId}', '${c.id}'); document.getElementById('related-update-modal')?.remove();">
                                    <div class="flex items-center justify-between">
                                        <span class="font-bold text-amber-800">${c.id}</span>
                                        <span class="text-xs bg-amber-200 text-amber-800 px-2 py-0.5 rounded">${c.category}</span>
                                    </div>
                                    <p class="text-xs text-amber-700 mt-1 line-clamp-2">${c.original_text.substring(0, 100)}...</p>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <div class="p-4 bg-gray-50 border-t flex justify-between">
                        <button onclick="regenerateRelatedResponses('${sourceCommentId}')" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-sm">
                            <i class="fas fa-sync-alt mr-2"></i>Auto-Update Related
                        </button>
                        <button onclick="document.getElementById('related-update-modal')?.remove()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 text-sm">
                            Review Later
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // Regenerate responses for related comments based on the source comment
        async function regenerateRelatedResponses(sourceCommentId) {
            const sourceComment = getAllComments().find(c => c.id === sourceCommentId);
            if (!sourceComment) return;

            const related = getRelatedComments(sourceCommentId);
            const relatedWithResponses = [...related.direct, ...related.thematic].filter(c => c.draft_response);

            document.getElementById('related-update-modal')?.remove();

            if (relatedWithResponses.length === 0) {
                showNotification('No related comments with responses to update', 'info');
                return;
            }

            showNotification(`Updating ${relatedWithResponses.length} related responses...`, 'info');

            // Ask OpenCode to review and suggest updates for related comments
            const prompt = `I just updated my response to reviewer comment ${sourceCommentId}:

**Comment ${sourceCommentId} (${sourceComment.category}):**
"${sourceComment.original_text.substring(0, 300)}"

**My new response:**
"${sourceComment.draft_response?.substring(0, 500) || 'No response yet'}"

Please review these related comments and suggest if their responses need to be updated for consistency:

${relatedWithResponses.slice(0, 3).map(c => `
**${c.id} (${c.category}):**
Comment: "${c.original_text.substring(0, 200)}"
Current response: "${c.draft_response?.substring(0, 200) || 'None'}"
`).join('\n')}

For each, briefly say whether the response needs updating and why (or "OK - consistent").`;

            try {
                const response = await fetch(`${API_BASE}/ask`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        comment_id: `consistency-check-${sourceCommentId}`,
                        model: aiSettings.model,
                        agent: aiSettings.agent,
                        variant: aiSettings.variant
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    // Show the consistency analysis in chat
                    if (!chatIsOpen) toggleChat();
                    addChatMessage('assistant', ` **Consistency Check for ${sourceCommentId}**\n\n${result.response}`);
                    showNotification('Consistency analysis complete - see chat', 'success');
                } else {
                    showNotification('Could not analyze consistency', 'error');
                }
            } catch (e) {
                showNotification('Error checking consistency: ' + e.message, 'error');
            }
        }

        // Agent functions - Direct OpenCode integration
        const agentSkillMap = {
            'dna-damage': {
                name: 'DNA Damage Authentication Expert',
                skill: 'dna-damage-auth',
                prompt: 'DNA damage patterns, authentication criteria, deamination analysis'
            },
            'phylogenetics': {
                name: 'Phylogenetics & Evolution Expert',
                skill: 'phylogenetics-evolution',
                prompt: 'Molecular clocks, tip dating, evolutionary analyses'
            },
            'microbial-ecology': {
                name: 'Microbial Ecology Expert',
                skill: 'microbial-ecology',
                prompt: 'Community composition, wetlands, methanogens'
            },
            'virology': {
                name: 'Ancient Virome Expert',
                skill: 'ancient-virome',
                prompt: 'Viral detection, IMG/VR, protein-based profiling'
            },
            'methods': {
                name: 'Bioinformatics Methods Expert',
                skill: 'bioinformatics-methods',
                prompt: 'Pipelines, parameters, validation approaches'
            }
        };

        // Current agent consultation state
        let currentAgentConsultation = null;

        function startAgentConsultation(agentId, commentContext = null) {
            const agent = agentSkillMap[agentId];
            currentAgentConsultation = { agentId, agent, commentContext };

            document.getElementById('agent-modal-title').textContent = `Consult: ${agent.name}`;
            document.getElementById('agent-modal-content').innerHTML = `
                <div class="space-y-4">
                    <!-- Connection Status -->
                    <div class="flex items-center justify-between p-3 rounded-lg ${apiConnected ? 'bg-green-50 border border-green-200' : 'bg-yellow-50 border border-yellow-200'}">
                        <div class="flex items-center gap-2">
                            <span class="w-2 h-2 rounded-full ${apiConnected ? 'bg-green-500' : 'bg-yellow-500'}"></span>
                            <span class="text-sm ${apiConnected ? 'text-green-700' : 'text-yellow-700'}">
                                ${apiConnected ? 'OpenCode Ready - ' + aiSettings.model : 'OpenCode API offline - prompts will be copied'}
                            </span>
                        </div>
                        ${!apiConnected ? '<button onclick="checkApiConnection()" class="text-xs px-2 py-1 bg-yellow-100 rounded">Retry</button>' : ''}
                    </div>

                    <!-- Agent Info -->
                    <div class="bg-gradient-to-r ${agent.color || 'from-green-500 to-teal-500'} rounded-lg p-4 text-white">
                        <div class="flex items-center gap-3 mb-2">
                            <i class="fas ${agent.icon || 'fa-robot'} text-xl"></i>
                            <span class="font-semibold">${agent.name}</span>
                        </div>
                        <p class="text-sm text-white text-opacity-90">${agent.description || agent.prompt}</p>
                    </div>

                    <!-- Question Input -->
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Your Question</label>
                        <textarea id="agent-question" class="w-full px-4 py-3 border border-gray-300 rounded-lg text-sm" rows="4"
                                  placeholder="Ask the ${agent.name} anything...">${commentContext ? `Help me respond to comment ${commentContext.id}:\n\nReviewer said: "${commentContext.original_text.substring(0, 300)}${commentContext.original_text.length > 300 ? '...' : ''}"\n\nSuggest improvements or a better response.` : ''}</textarea>
                    </div>

                    <!-- Response Area -->
                    <div id="agent-response-area" class="hidden">
                        <label class="block text-sm font-medium text-gray-700 mb-2">OpenCode Response</label>
                        <div id="agent-response" class="bg-gray-50 border rounded-lg p-4 text-sm prose max-w-none"></div>
                    </div>

                    <!-- Loading -->
                    <div id="agent-loading" class="hidden text-center py-4">
                        <i class="fas fa-spinner fa-spin text-green-500 text-2xl mb-2"></i>
                        <p class="text-sm text-gray-600">OpenCode is thinking...</p>
                    </div>

                    <!-- Actions -->
                    <div class="flex justify-end gap-2 pt-2">
                        <button onclick="closeAgentModal()" class="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 text-sm">
                            Cancel
                        </button>
                        <button onclick="sendAgentQuestion()" id="send-agent-btn"
                                class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 text-sm disabled:opacity-50">
                            <i class="fas fa-paper-plane mr-2"></i>Ask OpenCode
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('agent-modal').classList.remove('hidden');
        }

        async function sendAgentQuestion() {
            const question = document.getElementById('agent-question').value.trim();
            if (!question) {
                alert('Please enter a question.');
                return;
            }

            const agent = currentAgentConsultation?.agent;
            // Map agent skill to OpenCode skill name
            const skillMap = {
                'dna-damage-auth': '@dna-damage-auth',
                'microbial-ecology': '@microbial-ecology',
                'phylogenetics-evolution': '@phylogenetics-evolution',
                'ancient-virome': '@ancient-virome',
                'bioinformatics-methods': '@bioinformatics-methods'
            };
            const skill = skillMap[agent?.skill] || '@manuscript-reviewer';

            const prompt = `${skill}

QUESTION: ${question}

Provide expert guidance based on the manuscript context you have loaded. Be scientifically precise and use PAST TENSE when suggesting responses.`;

            document.getElementById('agent-loading').classList.remove('hidden');
            document.getElementById('send-agent-btn').disabled = true;

            try {
                const response = await fetch(`${API_BASE}/ask`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        comment_id: currentAgentConsultation?.commentContext?.id || 'agent-consultation',
                        model: aiSettings.model,
                        agent: aiSettings.agent,
                        variant: aiSettings.variant
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    handleAgentResponse(result.response);
                } else {
                    throw new Error('API request failed');
                }
            } catch (e) {
                navigator.clipboard.writeText(prompt).then(() => {
                    alert('OpenCode server not available.\n\nPrompt copied to clipboard!\nRun: node opencode-server.js');
                });
                document.getElementById('agent-loading').classList.add('hidden');
                document.getElementById('send-agent-btn').disabled = false;
            }
        }

        function handleAgentResponse(response) {
            document.getElementById('agent-loading').classList.add('hidden');
            document.getElementById('send-agent-btn').disabled = false;
            document.getElementById('agent-response-area').classList.remove('hidden');
            document.getElementById('agent-response').innerHTML = marked.parse(response);
        }

        function closeAgentModal() {
            document.getElementById('agent-modal').classList.add('hidden');
            currentAgentConsultation = null;
        }

        // Settings Modal Functions
        let aiSettings = {
            model: 'openai/gpt-5.2-codex',
            agent: 'build',
            variant: 'high'
        };

        // API_BASE is defined earlier in the file

        async function loadAISettings() {
            try {
                // Try to load config from API server first
                const response = await fetch(`${API_BASE}/config`);
                if (response.ok) {
                    const config = await response.json();
                    aiSettings = {
                        model: config.model || aiSettings.model,
                        agent: config.agent || aiSettings.agent,
                        variant: config.variant || aiSettings.variant
                    };
                    return;
                }
            } catch (e) {
                // API not available, try static file
            }

            try {
                // Fallback to static config file
                const response = await fetch('opencode-config.json');
                if (response.ok) {
                    const config = await response.json();
                    aiSettings = {
                        model: config.model || aiSettings.model,
                        agent: config.agent || aiSettings.agent,
                        variant: config.variant || aiSettings.variant
                    };
                }
            } catch (e) {
                console.log('Using default AI settings');
            }
        }

        async function loadSessionInfo() {
            try {
                // Try paper-specific session first
                if (currentPaperId) {
                    const response = await fetch(`${API_BASE}/session/${currentPaperId}`);
                    if (response.ok) {
                        const session = await response.json();
                        return {
                            sessionId: session.opencode_session_id || null,
                            messageCount: session.messages?.length || 0,
                            model: session.model,
                            agent: session.agent,
                            variant: session.variant
                        };
                    }
                }
            } catch (e) {
                // Paper session not available
            }

            try {
                // Fallback to default session
                const response = await fetch(`${API_BASE}/session`);
                if (response.ok) {
                    const session = await response.json();
                    return {
                        sessionId: session.opencode_session_id || null,
                        messageCount: session.messages?.length || 0
                    };
                }
            } catch (e) {
                // API not available
            }
            return { sessionId: null, messageCount: 0 };
        }

        // Cache for available models
        let availableModels = null;

        async function loadModels(forceRefresh = false) {
            if (availableModels && !forceRefresh) {
                return availableModels;
            }

            const statusEl = document.getElementById('models-status');
            const selectEl = document.getElementById('settings-model');

            try {
                if (statusEl) statusEl.textContent = 'Fetching available models from OpenCode...';

                const response = await fetch(`${API_BASE}/models`);
                if (response.ok) {
                    const data = await response.json();
                    availableModels = data.models;

                    // Populate the select dropdown
                    populateModelsDropdown(selectEl, availableModels, aiSettings.model);

                    if (statusEl) {
                        statusEl.textContent = `${availableModels.list.length} models available`;
                        statusEl.className = 'text-xs text-green-600 mt-1';
                    }

                    return availableModels;
                }
            } catch (e) {
                console.log('Could not fetch models from API:', e);
            }

            // Fallback: show error
            if (statusEl) {
                statusEl.textContent = 'Could not load models. Start opencode-server.js';
                statusEl.className = 'text-xs text-red-500 mt-1';
            }

            // Add a fallback option
            selectEl.innerHTML = `<option value="${aiSettings.model}">${aiSettings.model}</option>`;

            return null;
        }

        function populateModelsDropdown(selectEl, models, currentModel) {
            selectEl.innerHTML = '';

            if (!models || !models.grouped) {
                selectEl.innerHTML = `<option value="">No models available</option>`;
                return;
            }

            // Create optgroups by provider
            const providers = Object.keys(models.grouped).sort();

            for (const provider of providers) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = formatProviderName(provider);

                for (const model of models.grouped[provider]) {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.name || model.id.split('/')[1];
                    if (model.description) {
                        option.textContent += ` (${model.description})`;
                    }
                    if (model.current) {
                        option.textContent += ' ';
                    }
                    if (model.id === currentModel) {
                        option.selected = true;
                    }
                    optgroup.appendChild(option);
                }

                selectEl.appendChild(optgroup);
            }
        }

        function formatProviderName(provider) {
            const names = {
                'openai': 'OpenAI',
                'opencode': 'OpenCode',
                'anthropic': 'Anthropic',
                'google': 'Google',
                'github-copilot': 'GitHub Copilot'
            };
            return names[provider] || provider.charAt(0).toUpperCase() + provider.slice(1);
        }

        async function refreshModels() {
            const btn = event.target.closest('button');
            const icon = btn.querySelector('i');
            icon.classList.add('fa-spin');

            await loadModels(true);

            icon.classList.remove('fa-spin');
            showNotification('Models refreshed', 'success');
        }

        async function openSettingsModal() {
            await loadAISettings();
            const sessionInfo = await loadSessionInfo();

            // Show modal first
            document.getElementById('settings-modal').classList.remove('hidden');

            // Load models dynamically
            await loadModels();

            // Update select values (after models are loaded)
            const modelSelect = document.getElementById('settings-model');
            if (modelSelect.querySelector(`option[value="${aiSettings.model}"]`)) {
                modelSelect.value = aiSettings.model;
            }
            document.getElementById('settings-agent').value = aiSettings.agent;
            document.getElementById('settings-variant').value = aiSettings.variant;

            // Update session info
            document.getElementById('settings-session-id').textContent = sessionInfo.sessionId || 'None (new session)';
            document.getElementById('settings-message-count').textContent = sessionInfo.messageCount;
        }

        function closeSettingsModal() {
            document.getElementById('settings-modal').classList.add('hidden');
        }

        async function saveSettings() {
            const newSettings = {
                model: document.getElementById('settings-model').value,
                agent: document.getElementById('settings-agent').value,
                variant: document.getElementById('settings-variant').value
            };

            try {
                // Try to save via API server
                const response = await fetch(`${API_BASE}/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newSettings)
                });

                if (response.ok) {
                    const result = await response.json();
                    aiSettings = newSettings;
                    closeSettingsModal();
                    showNotification('Settings saved! Model: ' + newSettings.model, 'success');
                    updateChatModelIndicator();
                    return;
                }
            } catch (e) {
                console.log('API not available, saving locally');
            }

            // Fallback: save to localStorage
            localStorage.setItem('opencode-settings', JSON.stringify(newSettings));
            aiSettings = newSettings;
            closeSettingsModal();
            updateChatModelIndicator();
            showNotification('Settings saved locally (start opencode-server.js to persist)', 'info');
        }

        async function resetSession() {
            if (!confirm('This will start a fresh conversation with the AI. Previous context will be lost. Continue?')) {
                return;
            }

            try {
                // Try to reset via API server
                const response = await fetch(`${API_BASE}/session/reset`, {
                    method: 'POST'
                });

                if (response.ok) {
                    // Update UI
                    document.getElementById('settings-session-id').textContent = 'None (new session)';
                    document.getElementById('settings-message-count').textContent = '0';
                    showNotification('Session reset. Next message will start fresh.', 'success');
                    return;
                }
            } catch (e) {
                console.log('API not available');
            }

            // Fallback: just clear localStorage
            localStorage.removeItem('opencode-session');
            document.getElementById('settings-session-id').textContent = 'None (new session)';
            document.getElementById('settings-message-count').textContent = '0';
            showNotification('Session reset locally', 'info');
        }

        function showNotification(message, type = 'info') {
            const notif = document.createElement('div');
            notif.className = `fixed bottom-4 right-4 px-4 py-3 rounded-lg shadow-lg z-50 ${
                type === 'success' ? 'bg-green-500 text-white' :
                type === 'error' ? 'bg-red-500 text-white' :
                'bg-blue-500 text-white'
            }`;
            notif.innerHTML = `
                <div class="flex items-center gap-2">
                    <i class="fas ${type === 'success' ? 'fa-check-circle' : type === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle'}"></i>
                    <span>${message}</span>
                </div>
            `;
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 3000);
        }

        // Load settings on startup
        loadAISettings();

        function copyToClipboard() {
            const text = document.getElementById('agent-question').value;
            navigator.clipboard.writeText(text).then(() => {
                const btn = event.target.closest('button');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check mr-2"></i>Copied!';
                setTimeout(() => btn.innerHTML = originalHTML, 2000);
            });
        }

        function copyPrompt(text) {
            navigator.clipboard.writeText(text).then(() => {
                const btn = event.target.closest('button');
                if (btn) {
                    const originalHTML = btn.innerHTML;
                    btn.innerHTML = '<i class="fas fa-check text-green-500 mr-2"></i>Copied!';
                    btn.classList.add('bg-green-50');
                    setTimeout(() => {
                        btn.innerHTML = originalHTML;
                        btn.classList.remove('bg-green-50');
                    }, 2000);
                }
            });
        }

        function consultAgent(reviewerId, commentId) {
            const reviewer = reviewData.reviewers.find(r => r.id === reviewerId);
            const comment = reviewer?.comments.find(c => c.id === commentId);
            if (!comment) return;

            // Determine best agent based on comment category
            const categoryAgentMap = {
                'Authentication': 'dna-damage',
                'Analysis': 'methods',
                'Validation': 'dna-damage',
                'Figure': 'methods',
                'Methods': 'methods',
                'Interpretation': 'microbial-ecology',
                'Novelty': 'microbial-ecology',
                'Terminology': 'microbial-ecology',
                'Database': 'methods',
                'Results': 'microbial-ecology',
                'Discussion': 'microbial-ecology',
                'Focus': 'methods'
            };

            const agentId = categoryAgentMap[comment.category] || 'methods';
            startAgentConsultation(agentId, comment);
        }

        // Export functions
        function exportJSON() {
            const dataStr = JSON.stringify(reviewData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            const exportName = 'review_data_' + new Date().toISOString().split('T')[0] + '.json';

            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportName);
            linkElement.click();
        }

        function exportToWord() {
            alert('Word export will be generated. This integrates with the docx skill in OpenCode.');
            // This would trigger the docx generation through OpenCode
        }

        function exportSummary() {
            const allComments = getAllComments();
            const summary = {
                manuscript: reviewData.manuscript,
                statistics: {
                    total: allComments.length,
                    completed: allComments.filter(c => c.status === 'completed').length,
                    major: allComments.filter(c => c.type === 'major').length,
                    needsAnalysis: allComments.filter(c => c.requires_new_analysis).length
                },
                reviewers: reviewData.reviewers.map(r => ({
                    name: r.name,
                    comments: r.comments.length,
                    completed: r.comments.filter(c => c.status === 'completed').length
                }))
            };

            const dataStr = JSON.stringify(summary, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', 'review_summary.json');
            linkElement.click();
        }

        function generateTrackChanges() {
            alert('Track changes script will be generated for manuscript modifications. This integrates with the docx skill.');
        }

        // Save progress (uses database functions defined earlier)
        async function saveProgress() {
            const saved = await saveCommentsToDb();
            if (saved) {
                showNotification(`Progress saved to ${dbStatus.storage}!`, 'success');
            } else {
                showNotification('Progress saved to browser storage (start server for persistence)', 'info');
            }
        }

        function loadNewManuscript() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                const text = await file.text();
                reviewData = JSON.parse(text);
                updateSidebar();
                setView('overview');
            };
            input.click();
        }
    </script>
</body>
</html>
